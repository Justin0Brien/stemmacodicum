<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Stemma Codicum</title>
  <meta name="theme-color" content="#1d4ed8" />
  <meta name="msapplication-TileColor" content="#1d4ed8" />
  <meta name="msapplication-TileImage" content="/static/icons/mstile-150x150.png" />
  <meta name="msapplication-config" content="/browserconfig.xml" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Stemma Codicum" />
  <!-- Standard favicon support -->
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
  <!-- PNG favicon for modern browsers -->
  <link rel="icon" type="image/png" sizes="16x16" href="/static/icons/favicon-16x16.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="/static/icons/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="48x48" href="/static/icons/favicon-48x48.png" />
  <!-- Apple touch icon for Safari bookmarks and home screen -->
  <link rel="apple-touch-icon" href="/static/icons/apple-touch-icon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/static/icons/apple-touch-icon.png" />
  <!-- Web manifest for PWA support -->
  <link rel="manifest" href="/site.webmanifest" />
  <style>
    :root {
      --font-display: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Arial, sans-serif;
      --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Arial, sans-serif;
      --font-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      --bg: #f4f6f9;
      --card: #ffffff;
      --text: #111827;
      --muted: #5f6b7a;
      --accent: #2563eb;
      --accent-2: #1d4ed8;
      --border: #dbe3ee;
      --error: #b42318;
      --button-secondary-bg: #e5ebf5;
      --button-secondary-text: #1f2a38;
      --pre-bg: #0f172a;
      --pre-fg: #dbeafe;
      --drop-bg: #f8fafd;
      --drop-drag-bg: #eef2f8;
      --help-overlay: rgba(8, 12, 18, 0.54);
      --help-panel-bg: #ffffff;
      --help-code-bg: #eef2f8;
      --help-code-fg: #111827;
      --help-icon-bg: #edf1f7;
      --help-icon-fg: #334155;
      --hero-grad-start: #f9fbfe;
      --hero-grad-end: #f9fbfe;
      --surface-tint: rgba(255, 255, 255, 0.9);
      --surface-shadow: 0 8px 20px rgba(15, 23, 42, 0.06);
      --surface-shadow-soft: 0 2px 8px rgba(15, 23, 42, 0.05);
      --focus-ring: 0 0 0 3px rgba(37, 99, 235, 0.22);
    }
    body[data-theme="harmonious-light"] {
      --bg: #f4f6f9;
      --card: #ffffff;
      --text: #111827;
      --muted: #5f6b7a;
      --accent: #2563eb;
      --accent-2: #1d4ed8;
      --border: #dbe3ee;
      --button-secondary-bg: #e5ebf5;
      --button-secondary-text: #1f2a38;
      --pre-bg: #0f172a;
      --pre-fg: #dbeafe;
      --drop-bg: #f8fafd;
      --drop-drag-bg: #eef2f8;
      --help-overlay: rgba(8, 12, 18, 0.54);
      --help-panel-bg: #ffffff;
      --help-code-bg: #eef2f8;
      --help-code-fg: #111827;
      --help-icon-bg: #edf1f7;
      --help-icon-fg: #334155;
      --hero-grad-start: #f9fbfe;
      --hero-grad-end: #f9fbfe;
      --surface-tint: rgba(255, 255, 255, 0.9);
      --surface-shadow: 0 8px 20px rgba(15, 23, 42, 0.06);
      --surface-shadow-soft: 0 2px 8px rgba(15, 23, 42, 0.05);
      --focus-ring: 0 0 0 3px rgba(37, 99, 235, 0.22);
    }
    body[data-theme="restful-dark"] {
      --bg: #0d1117;
      --card: #151b23;
      --text: #e6edf5;
      --muted: #99a8bb;
      --accent: #5b8cff;
      --accent-2: #7c89ff;
      --border: #273142;
      --button-secondary-bg: #202a39;
      --button-secondary-text: #dce6f5;
      --pre-bg: #0a0f16;
      --pre-fg: #d8e5f8;
      --drop-bg: #111a25;
      --drop-drag-bg: #172230;
      --help-overlay: rgba(2, 5, 9, 0.76);
      --help-panel-bg: #151b23;
      --help-code-bg: #1f2937;
      --help-code-fg: #e6edf5;
      --help-icon-bg: #273244;
      --help-icon-fg: #f4f8ff;
      --hero-grad-start: #151b23;
      --hero-grad-end: #151b23;
      --surface-tint: rgba(255, 255, 255, 0.02);
      --surface-shadow: 0 10px 24px rgba(0, 0, 0, 0.3);
      --surface-shadow-soft: 0 4px 12px rgba(0, 0, 0, 0.22);
      --focus-ring: 0 0 0 3px rgba(91, 140, 255, 0.34);
    }
    body[data-theme="sunset-paper"] {
      --bg: #f8f4ee;
      --card: #fffdfa;
      --text: #30262c;
      --muted: #6f6168;
      --accent: #c35c2c;
      --accent-2: #9f4a24;
      --border: #eadfd5;
      --button-secondary-bg: #eee4dd;
      --button-secondary-text: #3f343a;
      --pre-bg: #2e242e;
      --pre-fg: #f4e8f2;
      --drop-bg: #fcf4eb;
      --drop-drag-bg: #f8ebde;
      --help-overlay: rgba(30, 17, 20, 0.62);
      --help-panel-bg: #fffdfa;
      --help-code-bg: #f6ece6;
      --help-code-fg: #30262c;
      --help-icon-bg: #f2e4d8;
      --help-icon-fg: #594146;
      --hero-grad-start: #fffdfa;
      --hero-grad-end: #fffdfa;
      --surface-tint: rgba(255, 253, 250, 0.92);
      --surface-shadow: 0 8px 20px rgba(66, 42, 49, 0.1);
      --surface-shadow-soft: 0 3px 10px rgba(66, 42, 49, 0.07);
      --focus-ring: 0 0 0 3px rgba(195, 92, 44, 0.24);
    }
    body[data-theme="forest-mist"] {
      --bg: #f1f6f3;
      --card: #fbfffd;
      --text: #1f302a;
      --muted: #526860;
      --accent: #1f8f63;
      --accent-2: #197552;
      --border: #d2e2d9;
      --button-secondary-bg: #e2efe8;
      --button-secondary-text: #264138;
      --pre-bg: #132b26;
      --pre-fg: #c8f2e7;
      --drop-bg: #effaf5;
      --drop-drag-bg: #dcf2e7;
      --help-overlay: rgba(12, 28, 24, 0.58);
      --help-panel-bg: #fbfffd;
      --help-code-bg: #e5f3ed;
      --help-code-fg: #1f302a;
      --help-icon-bg: #d9ebe4;
      --help-icon-fg: #193e36;
      --hero-grad-start: #fbfffd;
      --hero-grad-end: #fbfffd;
      --surface-tint: rgba(251, 255, 253, 0.9);
      --surface-shadow: 0 8px 20px rgba(19, 52, 44, 0.09);
      --surface-shadow-soft: 0 3px 10px rgba(19, 52, 44, 0.07);
      --focus-ring: 0 0 0 3px rgba(31, 143, 99, 0.27);
    }
    body[data-theme="midnight-contrast"] {
      --bg: #0b1018;
      --card: #141c28;
      --text: #f0f4fb;
      --muted: #a9b6ca;
      --accent: #7a88ff;
      --accent-2: #5970ff;
      --border: #293648;
      --button-secondary-bg: #212c3e;
      --button-secondary-text: #edf3ff;
      --pre-bg: #080c14;
      --pre-fg: #e9f1ff;
      --drop-bg: #111a28;
      --drop-drag-bg: #172235;
      --help-overlay: rgba(0, 0, 0, 0.78);
      --help-panel-bg: #141c28;
      --help-code-bg: #243246;
      --help-code-fg: #f0f4fb;
      --help-icon-bg: #2b3b50;
      --help-icon-fg: #ffffff;
      --hero-grad-start: #141c28;
      --hero-grad-end: #141c28;
      --surface-tint: rgba(255, 255, 255, 0.02);
      --surface-shadow: 0 10px 24px rgba(0, 0, 0, 0.36);
      --surface-shadow-soft: 0 4px 12px rgba(0, 0, 0, 0.26);
      --focus-ring: 0 0 0 3px rgba(122, 136, 255, 0.3);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: var(--font-sans);
      color: var(--text);
      min-height: 100vh;
      background: var(--bg);
      position: relative;
      overflow-x: hidden;
    }
    body::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      opacity: 0.11;
      background: radial-gradient(1200px 560px at 14% -8%, color-mix(in srgb, var(--accent) 16%, transparent), transparent 64%);
      z-index: -2;
    }
    body::after {
      content: none;
    }
    header {
      padding: 10px 16px 8px;
      background: color-mix(in srgb, var(--card) 98%, var(--bg));
      color: var(--text);
      position: relative;
      overflow: hidden;
      border-bottom: 1px solid var(--border);
    }
    header::after {
      content: none;
    }
    .header-top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      margin-bottom: 2px;
      position: relative;
      z-index: 1;
    }
    .brand-block {
      max-width: 760px;
    }
    .brand-identity {
      display: inline-flex;
      align-items: center;
      gap: 10px;
    }
    .app-icon {
      width: 40px;
      height: 40px;
      object-fit: contain;
      display: block;
      filter: drop-shadow(0 1px 3px rgba(0, 0, 0, 0.22));
      opacity: 0.98;
    }
    header h1 {
      margin: 0;
      font-family: var(--font-display);
      font-size: clamp(18px, 2.4vw, 24px);
      line-height: 1.05;
      letter-spacing: 0;
      font-weight: 650;
    }
    .hero-subtitle {
      margin: 2px 0 0;
      font-size: 12px;
      line-height: 1.2;
      max-width: 640px;
      color: var(--muted);
    }
    .theme-picker {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      color: var(--muted);
      font-weight: 500;
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 8px;
      background: color-mix(in srgb, var(--card) 96%, var(--surface-tint));
      border: 1px solid var(--border);
      box-shadow: var(--surface-shadow-soft);
    }
    .theme-picker select {
      min-width: 152px;
      border-color: var(--border);
      background: color-mix(in srgb, var(--card) 96%, var(--surface-tint));
      color: var(--text);
      padding: 4px 8px;
    }
    .theme-picker select option {
      color: var(--text);
      background: var(--card);
    }
    @media (max-width: 720px) {
      header {
        padding: 10px 12px 8px;
      }
      .header-top {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
      }
      .theme-picker {
        width: 100%;
      }
      .theme-picker select {
        min-width: 0;
        width: 100%;
      }
      .brand-identity {
        gap: 8px;
      }
      .app-icon {
        width: 30px;
        height: 30px;
      }
    }
    .app-shell {
      max-width: none;
      margin: 0;
      padding: 10px 14px 16px 274px;
      display: grid;
      grid-template-columns: minmax(0, 1fr);
      gap: 10px;
      align-items: start;
      position: relative;
    }
    .nav-column {
      background: color-mix(in srgb, var(--card) 98%, var(--surface-tint));
      border: 1px solid var(--border);
      border-radius: 10px;
      box-shadow: var(--surface-shadow-soft);
      padding: 10px;
      position: fixed;
      top: 74px;
      left: 10px;
      bottom: 10px;
      width: 248px;
      max-height: none;
      overflow: auto;
      z-index: 10;
    }
    .nav-title {
      margin: 0 0 4px;
      font-size: 11px;
      font-weight: 500;
      color: var(--text);
      opacity: 0.84;
    }
    .nav-copy {
      margin: 0 0 8px;
      font-size: 11px;
      line-height: 1.25;
    }
    .nav-list {
      display: grid;
      gap: 6px;
    }
    .nav-btn {
      text-align: left;
      width: 100%;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 7px 9px;
      font-size: 12px;
      font-weight: 400;
      color: var(--text);
      background: color-mix(in srgb, var(--card) 99%, var(--surface-tint));
      transition: transform 120ms ease, background 170ms ease, border-color 170ms ease, box-shadow 170ms ease;
      animation: navSlideIn 220ms ease both;
    }
    .nav-list .nav-btn:nth-child(1) { animation-delay: 20ms; }
    .nav-list .nav-btn:nth-child(2) { animation-delay: 35ms; }
    .nav-list .nav-btn:nth-child(3) { animation-delay: 50ms; }
    .nav-list .nav-btn:nth-child(4) { animation-delay: 65ms; }
    .nav-list .nav-btn:nth-child(5) { animation-delay: 80ms; }
    .nav-list .nav-btn:nth-child(6) { animation-delay: 95ms; }
    .nav-list .nav-btn:nth-child(7) { animation-delay: 110ms; }
    .nav-list .nav-btn:nth-child(8) { animation-delay: 125ms; }
    .nav-list .nav-btn:nth-child(9) { animation-delay: 140ms; }
    .nav-list .nav-btn:nth-child(10) { animation-delay: 155ms; }
    .nav-list .nav-btn:nth-child(11) { animation-delay: 170ms; }
    .nav-list .nav-btn:nth-child(12) { animation-delay: 185ms; }
    .nav-list .nav-btn:nth-child(13) { animation-delay: 200ms; }
    .nav-list .nav-btn:nth-child(14) { animation-delay: 215ms; }
    .nav-list .nav-btn:nth-child(15) { animation-delay: 230ms; }
    .nav-list .nav-btn:nth-child(16) { animation-delay: 245ms; }
    .nav-list .nav-btn:nth-child(17) { animation-delay: 260ms; }
    .nav-list .nav-btn:nth-child(18) { animation-delay: 275ms; }
    .nav-list .nav-btn:nth-child(19) { animation-delay: 290ms; }
    .nav-list .nav-btn:nth-child(20) { animation-delay: 305ms; }
    .nav-list .nav-btn:nth-child(21) { animation-delay: 320ms; }
    .nav-list .nav-btn:nth-child(22) { animation-delay: 335ms; }
    .nav-list .nav-btn:nth-child(23) { animation-delay: 350ms; }
    .nav-list .nav-btn:nth-child(24) { animation-delay: 365ms; }
    .nav-list .nav-btn:nth-child(25) { animation-delay: 380ms; }
    .nav-btn:hover {
      transform: translateX(1px);
      border-color: color-mix(in srgb, var(--accent) 32%, var(--border));
      box-shadow: 0 6px 14px rgba(15, 23, 42, 0.08);
      filter: none;
    }
    .nav-btn.active {
      background: var(--accent);
      color: #f8fbff;
      border-color: color-mix(in srgb, var(--accent) 78%, transparent);
      box-shadow: 0 8px 16px color-mix(in srgb, var(--accent) 28%, transparent);
    }
    .workspace {
      min-width: 0;
    }
    .workspace-head {
      background: color-mix(in srgb, var(--card) 98%, var(--surface-tint));
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 9px 12px;
      margin-bottom: 8px;
      box-shadow: var(--surface-shadow-soft);
    }
    .workspace-head h2 {
      margin: 0 0 1px;
      font-size: 12px;
      font-weight: 500;
      opacity: 0.8;
    }
    .workspace-head p {
      margin: 0;
      color: color-mix(in srgb, var(--text) 72%, var(--muted));
      font-size: 18px;
      font-weight: 700;
      letter-spacing: 0;
    }
    .workspace-panel {
      display: none;
    }
    .workspace-panel.active {
      display: block;
      animation: panelFade 220ms ease;
    }
    .card {
      background: color-mix(in srgb, var(--card) 99%, var(--surface-tint));
      border: 1px solid var(--border);
      border-radius: 10px;
      box-shadow: var(--surface-shadow-soft);
      padding: 12px;
      position: relative;
      overflow: visible;
    }
    .card::after {
      content: none;
    }
    .card h2 {
      margin: 0 0 10px;
      font-size: 18px;
      font-weight: 700;
      letter-spacing: 0;
      line-height: 1.1;
      position: relative;
      z-index: 1;
    }
    .row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 8px;
      position: relative;
      z-index: 1;
    }
    input, textarea, button, select {
      font: inherit;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 10px;
      background: color-mix(in srgb, var(--card) 99%, var(--surface-tint));
      color: var(--text);
    }
    input, select { flex: 1 1 180px; }
    textarea { width: 100%; min-height: 96px; line-height: 1.45; }
    input:focus,
    textarea:focus,
    select:focus,
    button:focus-visible {
      outline: none;
      box-shadow: var(--focus-ring);
      border-color: color-mix(in srgb, var(--accent) 55%, var(--border));
    }
    input::placeholder,
    textarea::placeholder {
      color: color-mix(in srgb, var(--muted) 88%, transparent);
    }
    button {
      background: var(--accent);
      color: #fff;
      border: 1px solid color-mix(in srgb, var(--accent) 72%, transparent);
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0;
      box-shadow: 0 4px 12px color-mix(in srgb, var(--accent) 20%, transparent);
      transition: transform 120ms ease, filter 140ms ease, box-shadow 140ms ease;
    }
    button.secondary {
      background: var(--button-secondary-bg);
      color: var(--button-secondary-text);
      border-color: color-mix(in srgb, var(--button-secondary-text) 14%, var(--border));
    }
    button:hover {
      filter: brightness(1.02);
      transform: translateY(-1px);
      box-shadow: 0 8px 16px rgba(15, 23, 42, 0.12);
    }
    button:active {
      transform: translateY(0);
      box-shadow: 0 3px 10px rgba(15, 23, 42, 0.09);
    }
    pre {
      background: var(--pre-bg);
      color: var(--pre-fg);
      border-radius: 8px;
      padding: 10px;
      overflow: auto;
      max-height: none;
      margin: 10px 0 0;
      font-size: 11px;
      line-height: 1.5;
      font-family: var(--font-mono);
      border: 1px solid color-mix(in srgb, var(--pre-fg) 15%, transparent);
    }
    pre[id^="out-"] {
      min-height: 18rem;
      height: 18rem;
      resize: vertical;
    }
    .db-grid-controls input,
    .db-grid-controls select {
      flex: 1 1 220px;
    }
    .db-grid-controls input:disabled,
    .db-grid-controls button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    #db-grid-view {
      display: none;
      margin-top: 8px;
    }
    #db-grid-view.open {
      display: block;
    }
    .db-grid-scroll {
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: auto;
      max-height: 70vh;
      background: color-mix(in srgb, var(--card) 99%, var(--surface-tint));
    }
    .db-grid-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
      line-height: 1.35;
    }
    .db-grid-table th,
    .db-grid-table td {
      border-bottom: 1px solid var(--border);
      padding: 6px 8px;
      text-align: left;
      vertical-align: top;
    }
    .db-grid-table thead th {
      position: sticky;
      top: 0;
      z-index: 2;
      background: color-mix(in srgb, var(--card) 96%, var(--surface-tint));
    }
    .db-grid-table .db-filter-row th {
      top: 35px;
      z-index: 1;
    }
    .db-grid-table tbody tr:nth-child(even) {
      background: color-mix(in srgb, var(--accent-2) 10%, transparent);
    }
    .db-sort-btn {
      appearance: none;
      border: none;
      background: transparent;
      color: var(--text);
      cursor: pointer;
      font: inherit;
      font-weight: 700;
      padding: 0;
      line-height: 1.2;
    }
    .db-sort-btn:hover {
      text-decoration: underline;
    }
    .db-filter-input {
      width: 100%;
      min-width: 120px;
      padding: 4px 6px;
      font-size: 12px;
    }
    .inspector-list {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: color-mix(in srgb, var(--card) 99%, var(--surface-tint));
      padding: 12px;
      max-height: 24rem;
      overflow: auto;
      margin-top: 10px;
    }
    .inspector-card {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 11px;
      margin-bottom: 10px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
    }
    .inspector-card:last-child {
      margin-bottom: 0;
    }
    .inspector-card h4 {
      margin: 0 0 4px;
      font-size: 13px;
    }
    .inspector-meta {
      font-size: 12px;
      color: var(--muted);
      margin: 0 0 6px;
      word-break: break-word;
    }
    .inspector-copy-row {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .inspector-copy-row button {
      padding: 5px 8px;
      font-size: 12px;
    }
    .inspector-copy-status {
      margin-top: 6px;
      font-size: 12px;
      color: var(--muted);
    }
    .db-cell {
      max-width: 560px;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .dropzone {
      border: 1.5px dashed color-mix(in srgb, var(--accent) 42%, var(--border));
      border-radius: 10px;
      padding: 14px;
      text-align: center;
      color: var(--muted);
      background: var(--drop-bg);
      margin-bottom: 10px;
      transition: background 150ms ease, border-color 150ms ease, transform 150ms ease;
    }
    .dropzone.drag {
      background: var(--drop-drag-bg);
      border-color: var(--accent);
      transform: translateY(-1px);
    }
    .import-live {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: color-mix(in srgb, var(--card) 99%, var(--surface-tint));
      padding: 10px;
      margin-bottom: 10px;
      display: grid;
      grid-template-columns: 186px minmax(0, 1fr);
      gap: 10px;
      position: relative;
      z-index: 1;
    }
    .import-live.current-focus {
      border-color: color-mix(in srgb, var(--accent) 38%, var(--border));
      box-shadow: 0 0 0 1px color-mix(in srgb, var(--accent) 18%, transparent);
      background: color-mix(in srgb, var(--accent) 7%, var(--card));
    }
    .import-live.empty {
      grid-template-columns: 1fr;
    }
    .import-queue {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: color-mix(in srgb, var(--card) 99%, var(--surface-tint));
      padding: 8px;
      margin-bottom: 10px;
      max-height: 16.5rem;
      overflow: auto;
      display: grid;
      gap: 8px;
      position: relative;
      z-index: 1;
    }
    .import-queue-head {
      margin: 0 0 2px;
      font-size: 12px;
      color: var(--muted);
      letter-spacing: 0;
      font-weight: 500;
    }
    .import-queue-item {
      border: 1px solid var(--border);
      border-radius: 9px;
      padding: 8px 9px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
      font-size: 12px;
      line-height: 1.35;
      word-break: break-word;
    }
    .import-queue-item.processing {
      border-color: color-mix(in srgb, var(--accent) 52%, var(--border));
      box-shadow: 0 0 0 1px color-mix(in srgb, var(--accent) 20%, transparent);
      background: color-mix(in srgb, var(--accent) 10%, var(--card));
    }
    .import-queue-item.done {
      border-color: color-mix(in srgb, #14965a 45%, var(--border));
    }
    .import-queue-item.failed {
      border-color: color-mix(in srgb, #b42318 48%, var(--border));
      background: color-mix(in srgb, #b42318 8%, var(--card));
    }
    .import-queue-item-head {
      margin: 0 0 3px;
      font-size: 12px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 6px;
      justify-content: space-between;
    }
    .import-queue-item-meta {
      margin: 0;
      color: var(--muted);
      font-size: 11px;
      line-height: 1.3;
    }
    .import-queue-item-detail {
      margin: 4px 0 0;
      color: var(--muted);
      font-size: 11px;
      line-height: 1.35;
    }
    .import-preview {
      border: 1px solid var(--border);
      border-radius: 8px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
      min-height: 210px;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--muted);
      font-size: 12px;
      text-align: center;
      padding: 10px;
    }
    .import-preview embed,
    .import-preview iframe {
      width: 100%;
      height: 232px;
      border: 0;
      background: #fff;
    }
    .import-preview img {
      max-width: 100%;
      max-height: 232px;
      object-fit: contain;
      display: block;
    }
    .import-preview-pdf {
      width: 100%;
      display: grid;
      justify-items: center;
      gap: 8px;
    }
    .import-preview-pdf-canvas-wrap {
      width: min(178px, 100%);
      min-height: 222px;
      position: relative;
      display: grid;
      place-items: center;
      background: #0f172a;
      border-radius: 8px;
      border: 1px solid rgba(15, 23, 42, 0.25);
      overflow: hidden;
      box-shadow: 0 8px 18px rgba(2, 6, 23, 0.28);
    }
    .import-preview-pdf-canvas {
      display: block;
      position: relative;
      z-index: 1;
      width: auto;
      height: auto;
      max-width: 100%;
      max-height: 220px;
      background: #ffffff;
    }
    .import-preview-pdf-placeholder {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      padding: 10px;
      font-size: 11px;
      line-height: 1.35;
      color: #e2e8f0;
      text-align: center;
      word-break: break-word;
      background: rgba(15, 23, 42, 0.58);
      z-index: 2;
    }
    .import-preview-pdf-title {
      margin: 0;
      max-width: 178px;
      font-size: 10px;
      line-height: 1.25;
      color: var(--muted);
      word-break: break-word;
      text-align: center;
    }
    .import-preview-caption {
      margin: 0;
      font-size: 11px;
      color: var(--muted);
      font-weight: 500;
      letter-spacing: 0;
    }
    .import-title {
      margin: 0 0 4px;
      font-size: 16px;
      font-weight: 600;
      line-height: 1.2;
      word-break: break-word;
    }
    .import-meta {
      margin: 0 0 10px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.4;
      word-break: break-word;
    }
    .import-progress-track {
      width: 100%;
      height: 10px;
      border-radius: 999px;
      background: color-mix(in srgb, var(--accent-2) 16%, transparent);
      border: 1px solid color-mix(in srgb, var(--accent-2) 24%, transparent);
      overflow: hidden;
      margin-bottom: 8px;
    }
    .import-progress-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--accent), color-mix(in srgb, var(--accent-2) 72%, var(--accent)));
      border-radius: inherit;
      transition: width 180ms ease;
      position: relative;
    }
    .import-progress-bar.active::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(120deg, transparent 0%, rgba(255, 255, 255, 0.35) 45%, transparent 70%);
      animation: importShimmer 900ms linear infinite;
    }
    .import-status-line {
      margin: 0 0 8px;
      font-size: 12px;
      color: var(--muted);
      min-height: 18px;
    }
    .import-counters {
      margin: 0 0 10px;
      font-size: 12px;
      color: var(--muted);
      min-height: 18px;
    }
    .import-steps {
      display: grid;
      gap: 8px;
      margin-bottom: 12px;
    }
    .import-step {
      border: 1px solid var(--border);
      border-radius: 9px;
      padding: 8px 10px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
      font-size: 12px;
      line-height: 1.3;
      word-break: break-word;
    }
    .import-step-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 5px;
    }
    .import-step-head strong {
      font-size: 12px;
    }
    .step-progress-track {
      width: 100%;
      height: 7px;
      border-radius: 999px;
      background: color-mix(in srgb, var(--accent-2) 16%, transparent);
      border: 1px solid color-mix(in srgb, var(--accent-2) 24%, transparent);
      overflow: hidden;
      margin-bottom: 4px;
    }
    .step-progress-bar {
      height: 100%;
      width: 0%;
      border-radius: inherit;
      transition: width 160ms ease;
      background: linear-gradient(90deg, var(--accent), color-mix(in srgb, var(--accent-2) 72%, var(--accent)));
      position: relative;
    }
    .step-progress-bar.active::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(120deg, transparent 0%, rgba(255, 255, 255, 0.34) 45%, transparent 70%);
      animation: importShimmer 900ms linear infinite;
    }
    .import-step-detail {
      margin: 0;
      color: var(--muted);
      font-size: 11px;
      line-height: 1.35;
      min-height: 14px;
    }
    .import-step .step-badge {
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0;
      text-transform: none;
      border: 1px solid transparent;
    }
    .import-step.pending .step-badge {
      background: rgba(100, 116, 139, 0.14);
      border-color: rgba(100, 116, 139, 0.22);
      color: var(--muted);
    }
    .import-step.pending .step-progress-bar {
      background: rgba(100, 116, 139, 0.32);
    }
    .import-step.active .step-badge {
      background: rgba(14, 116, 144, 0.18);
      border-color: rgba(14, 116, 144, 0.36);
      color: #0f6a7d;
    }
    .import-step.done .step-badge {
      background: rgba(20, 150, 90, 0.18);
      border-color: rgba(20, 150, 90, 0.36);
      color: #0f7a4f;
    }
    .import-step.skipped .step-badge {
      background: rgba(100, 116, 139, 0.18);
      border-color: rgba(100, 116, 139, 0.32);
      color: var(--text);
    }
    .import-step.skipped .step-progress-bar {
      background: rgba(100, 116, 139, 0.5);
    }
    .import-step.error .step-badge {
      background: rgba(180, 35, 24, 0.16);
      border-color: rgba(180, 35, 24, 0.36);
      color: #9f1e14;
    }
    .import-step.error .step-progress-bar {
      background: linear-gradient(90deg, #b42318, #9f1e14);
    }
    .import-metrics {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
      gap: 10px;
      margin-bottom: 12px;
    }
    .import-metric {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 9px 10px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
    }
    .import-metric p {
      margin: 0;
      line-height: 1.25;
    }
    .import-metric .k {
      font-size: 12px;
      letter-spacing: 0;
      text-transform: none;
      color: var(--muted);
      font-weight: 500;
    }
    .import-metric .v {
      font-size: 16px;
      font-weight: 600;
      margin-top: 2px;
    }
    .import-history-title {
      margin: 12px 0 7px;
      font-size: 13px;
      color: var(--muted);
      text-transform: none;
      letter-spacing: 0;
      font-weight: 600;
    }
    .import-history {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: color-mix(in srgb, var(--card) 99%, var(--surface-tint));
      padding: 12px;
      max-height: 17rem;
      overflow: auto;
      display: grid;
      gap: 8px;
      position: relative;
      z-index: 1;
    }
    .import-history-item {
      border: 1px solid var(--border);
      border-radius: 9px;
      padding: 9px 10px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
      font-size: 12px;
      line-height: 1.35;
      word-break: break-word;
    }
    .import-history-item h4 {
      margin: 0 0 3px;
      font-size: 12px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .viewer-toolbar {
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
    }
    .viewer-toggle {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      font-size: 12px;
      color: var(--muted);
      user-select: none;
    }
    .viewer-toggle input {
      accent-color: var(--accent);
    }
    .doc-viewer-layout {
      display: grid;
      grid-template-columns: minmax(0, 2fr) minmax(300px, 1fr);
      gap: 12px;
      align-items: start;
    }
    .doc-viewer-stage {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
      min-height: 480px;
      padding: 8px;
    }
    .doc-viewer-scroll {
      position: relative;
      width: 100%;
      height: 100%;
      min-height: 460px;
      overflow: auto;
      border-radius: 8px;
      background: color-mix(in srgb, var(--page-bg) 90%, var(--card));
      border: 1px solid var(--border);
      cursor: default;
    }
    .doc-viewer-scroll.pan-enabled {
      cursor: grab;
    }
    .doc-viewer-scroll.pan-enabled.panning {
      cursor: grabbing;
    }
    #viewer-pdf-canvas {
      display: none;
      margin: 0 auto;
      background: #fff;
      box-shadow: 0 10px 22px rgba(2, 6, 23, 0.16);
    }
    #viewer-overlay-canvas {
      display: none;
      position: absolute;
      pointer-events: none;
      z-index: 3;
      border: 0;
    }
    .doc-viewer-fallback {
      min-height: 450px;
      display: grid;
      place-items: center;
      color: var(--muted);
      text-align: center;
      padding: 10px;
    }
    .doc-viewer-fallback iframe,
    .doc-viewer-fallback object {
      width: 100%;
      min-height: 440px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: #fff;
    }
    .doc-viewer-fallback img {
      max-width: 100%;
      max-height: 620px;
      border-radius: 8px;
      box-shadow: 0 8px 20px rgba(2, 6, 23, 0.14);
    }
    .doc-viewer-side {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
      padding: 10px;
      display: grid;
      gap: 10px;
      min-height: 480px;
      align-content: start;
    }
    .viewer-overlay-item {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 9px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
      cursor: pointer;
    }
    .viewer-overlay-item.active {
      border-color: color-mix(in srgb, var(--accent) 58%, var(--border));
      box-shadow: 0 0 0 1px color-mix(in srgb, var(--accent) 28%, transparent);
    }
    .viewer-overlay-item h4 {
      margin: 0 0 4px;
      font-size: 12px;
      line-height: 1.3;
    }
    .viewer-overlay-item p {
      margin: 0;
      font-size: 11px;
      line-height: 1.35;
      color: var(--muted);
      word-break: break-word;
    }
    .viewer-table {
      width: 100%;
      border-collapse: collapse;
      min-width: 360px;
      font-size: 12px;
    }
    .viewer-table th,
    .viewer-table td {
      border: 1px solid var(--border);
      padding: 4px 6px;
      vertical-align: top;
      text-align: left;
      word-break: break-word;
    }
    .viewer-table thead th {
      background: color-mix(in srgb, var(--card) 82%, var(--surface-tint));
      font-weight: 600;
    }
    .viewer-table td.viewer-cell-active {
      background: color-mix(in srgb, var(--accent) 14%, var(--card));
      outline: 1px solid color-mix(in srgb, var(--accent) 48%, transparent);
      outline-offset: -1px;
    }
    .viewer-annotation-item {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 9px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
      font-size: 11px;
      line-height: 1.35;
      word-break: break-word;
    }
    .viewer-annotation-item h4 {
      margin: 0 0 3px;
      font-size: 12px;
      line-height: 1.3;
    }
    .viewer-annotation-item p {
      margin: 0;
      color: var(--muted);
    }
    @keyframes importShimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(200%); }
    }
    .small {
      color: var(--muted);
      font-size: 12px;
      line-height: 1.45;
      position: relative;
      z-index: 1;
    }
    .err { color: var(--error); font-size: 12px; }
    .metric-grid,
    .dashboard-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
      gap: 12px;
      margin: 12px 0;
    }
    .metric-card {
      border: 1px solid color-mix(in srgb, var(--border) 84%, transparent);
      border-radius: 12px;
      padding: 12px 14px;
      background: color-mix(in srgb, var(--card) 99%, var(--surface-tint));
      box-shadow: 0 2px 7px rgba(0, 0, 0, 0.05);
      position: relative;
      overflow: hidden;
    }
    .metric-card::before {
      content: none;
    }
    .metric-label {
      margin: 0 0 6px;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.2;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      text-transform: none;
      letter-spacing: 0;
      font-family: var(--font-sans);
      font-weight: 500;
    }
    .metric-value {
      margin: 0;
      font-size: 24px;
      font-weight: 600;
      line-height: 1.2;
      word-break: break-word;
    }
    .status-pill {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 11px;
      font-weight: 600;
      border: 1px solid transparent;
      letter-spacing: 0;
      text-transform: none;
    }
    .status-ok {
      background: rgba(20, 150, 90, 0.18);
      color: #0f7a4f;
      border-color: rgba(20, 150, 90, 0.36);
    }
    .status-warn {
      background: rgba(217, 119, 6, 0.18);
      color: #9a5a00;
      border-color: rgba(217, 119, 6, 0.36);
    }
    .status-error {
      background: rgba(180, 35, 24, 0.16);
      color: #9f1e14;
      border-color: rgba(180, 35, 24, 0.36);
    }
    .status-neutral {
      background: rgba(100, 116, 139, 0.18);
      color: var(--text);
      border-color: rgba(100, 116, 139, 0.32);
    }
    .issue-list {
      margin-top: 10px;
      display: grid;
      gap: 10px;
    }
    .issue-item {
      border: 1px solid var(--border);
      border-left: 4px solid transparent;
      border-radius: 10px;
      padding: 10px 11px;
      background: color-mix(in srgb, var(--card) 99%, var(--surface-tint));
      font-size: 13px;
      line-height: 1.35;
      word-break: break-word;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.04);
    }
    .issue-item strong {
      margin-right: 6px;
      text-transform: none;
      font-size: 11px;
      letter-spacing: 0;
      font-weight: 600;
    }
    .issue-item.issue-error {
      border-left-color: #b42318;
    }
    .issue-item.issue-warning {
      border-left-color: #d97706;
    }
    .issue-item.issue-info {
      border-left-color: #475569;
    }
    .dashboard-storage-panel {
      margin-top: 10px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: color-mix(in srgb, var(--card) 99%, var(--surface-tint));
      padding: 10px;
    }
    .dashboard-storage-layout {
      display: grid;
      grid-template-columns: minmax(280px, 1.05fr) minmax(280px, 1fr);
      gap: 14px;
      align-items: start;
    }
    .storage-column {
      min-width: 0;
    }
    .storage-kicker {
      margin: 0 0 8px;
      color: var(--muted);
      font-size: 11px;
      font-weight: 500;
      letter-spacing: 0.02em;
      text-transform: uppercase;
    }
    .storage-donut-wrap {
      display: grid;
      justify-items: center;
      gap: 8px;
    }
    .storage-donut {
      width: 200px;
      height: 200px;
      border-radius: 999px;
      position: relative;
      border: 1px solid color-mix(in srgb, var(--border) 76%, transparent);
      box-shadow: inset 0 0 0 1px color-mix(in srgb, var(--card) 52%, transparent);
    }
    .storage-donut::after {
      content: "";
      position: absolute;
      inset: 24px;
      border-radius: 999px;
      background: color-mix(in srgb, var(--card) 99%, var(--surface-tint));
      border: 1px solid color-mix(in srgb, var(--border) 76%, transparent);
    }
    .storage-donut-center {
      position: absolute;
      inset: 0;
      z-index: 1;
      display: grid;
      place-content: center;
      text-align: center;
      gap: 2px;
      pointer-events: none;
    }
    .storage-donut-label {
      font-size: 11px;
      color: var(--muted);
      font-weight: 500;
    }
    .storage-donut-value {
      font-size: 18px;
      font-weight: 650;
      color: var(--text);
      line-height: 1.1;
    }
    .storage-legend {
      margin: 0;
      padding: 0;
      list-style: none;
      display: grid;
      gap: 6px;
      width: 100%;
    }
    .storage-legend-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      border: 1px solid color-mix(in srgb, var(--border) 82%, transparent);
      border-radius: 8px;
      padding: 6px 8px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
      font-size: 12px;
    }
    .storage-legend-main {
      display: inline-flex;
      align-items: center;
      gap: 7px;
      min-width: 0;
    }
    .storage-swatch {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      flex: 0 0 auto;
      border: 1px solid color-mix(in srgb, #000000 16%, transparent);
    }
    .storage-legend-name {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      color: var(--text);
    }
    .storage-legend-size {
      color: var(--muted);
      font-variant-numeric: tabular-nums;
      flex: 0 0 auto;
    }
    .storage-device-block {
      display: grid;
      gap: 8px;
    }
    .storage-device-meta {
      font-size: 12px;
      color: var(--muted);
      line-height: 1.35;
    }
    .storage-device-bar {
      height: 16px;
      border-radius: 999px;
      border: 1px solid color-mix(in srgb, var(--border) 84%, transparent);
      overflow: hidden;
      display: flex;
      background: color-mix(in srgb, var(--card) 96%, var(--surface-tint));
    }
    .storage-device-used {
      background: linear-gradient(90deg, color-mix(in srgb, var(--accent) 75%, #64748b), color-mix(in srgb, var(--accent-2) 78%, #64748b));
      min-width: 2px;
    }
    .storage-device-free {
      background: color-mix(in srgb, #16a34a 42%, var(--card));
      min-width: 2px;
      border-left: 1px solid color-mix(in srgb, var(--border) 68%, transparent);
    }
    .storage-path-list {
      margin: 0;
      padding: 0;
      list-style: none;
      display: grid;
      gap: 6px;
    }
    .storage-path-item {
      border: 1px solid color-mix(in srgb, var(--border) 82%, transparent);
      border-radius: 8px;
      padding: 6px 8px;
      font-size: 11px;
      line-height: 1.35;
      color: var(--muted);
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
      word-break: break-word;
    }
    .storage-path-item strong {
      font-size: 11px;
      font-weight: 600;
      color: var(--text);
      display: inline-block;
      margin-right: 6px;
    }
    .info-icon {
      display: inline-flex;
      width: 16px;
      height: 16px;
      border-radius: 999px;
      border: 1px solid var(--border);
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: 700;
      background: var(--help-icon-bg);
      color: var(--help-icon-fg);
      cursor: help;
      user-select: none;
      line-height: 1;
      transition: transform 130ms ease, filter 130ms ease;
    }
    .info-icon:hover {
      transform: translateY(-1px);
      filter: brightness(1.07);
    }
    details.raw-json {
      margin-top: 10px;
      border: 1px solid var(--border);
      border-radius: 11px;
      background: color-mix(in srgb, var(--card) 95%, var(--surface-tint));
      overflow: hidden;
    }
    details.raw-json > summary {
      cursor: pointer;
      color: var(--muted);
      font-size: 12px;
      font-weight: 600;
      list-style: none;
      text-transform: none;
      letter-spacing: 0;
      padding: 10px 12px;
      background: color-mix(in srgb, var(--accent-2) 10%, transparent);
    }
    details.raw-json > summary::-webkit-details-marker {
      display: none;
    }
    .dashboard-section-title {
      margin: 13px 0 7px;
      font-size: 13px;
      color: var(--muted);
      font-weight: 600;
      letter-spacing: 0;
      text-transform: none;
    }
    .vector-card-list {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: color-mix(in srgb, var(--card) 99%, var(--surface-tint));
      padding: 12px;
      max-height: 22rem;
      overflow: auto;
      margin-top: 10px;
      display: grid;
      gap: 10px;
    }
    .vector-card {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 11px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
      word-break: break-word;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.04);
    }
    .vector-card h4 {
      margin: 0 0 5px;
      font-size: 13px;
    }
    .vector-card p {
      margin: 0;
      font-size: 12px;
      color: color-mix(in srgb, var(--muted) 90%, var(--text));
      white-space: pre-wrap;
      line-height: 1.45;
    }
    .help-icon {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 30px;
      height: 30px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: var(--help-icon-bg);
      color: var(--help-icon-fg);
      font-weight: 700;
      line-height: 1;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      min-width: 30px;
      box-shadow: 0 7px 16px rgba(0, 0, 0, 0.16);
      transition: transform 140ms ease, filter 140ms ease;
      z-index: 2;
    }
    .help-icon:hover {
      filter: brightness(1.08);
      transform: translateY(-1px);
    }
    .help-modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: var(--help-overlay);
      z-index: 999;
      padding: 18px;
    }
    .help-modal.open {
      display: flex;
      animation: fadeIn 170ms ease;
    }
    .help-panel {
      width: min(920px, 100%);
      max-height: 86vh;
      overflow: auto;
      background: linear-gradient(170deg, color-mix(in srgb, var(--help-panel-bg) 92%, var(--surface-tint)), var(--help-panel-bg));
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 16px;
      box-shadow: 0 24px 60px rgba(12, 25, 41, 0.35);
      animation: panelFloatIn 190ms ease;
    }
    .help-panel::-webkit-scrollbar,
    .nav-column::-webkit-scrollbar,
    .vector-card-list::-webkit-scrollbar,
    .inspector-list::-webkit-scrollbar,
    .db-grid-scroll::-webkit-scrollbar,
    pre::-webkit-scrollbar {
      width: 10px;
      height: 10px;
    }
    .help-panel::-webkit-scrollbar-thumb,
    .nav-column::-webkit-scrollbar-thumb,
    .vector-card-list::-webkit-scrollbar-thumb,
    .inspector-list::-webkit-scrollbar-thumb,
    .db-grid-scroll::-webkit-scrollbar-thumb,
    pre::-webkit-scrollbar-thumb {
      background: color-mix(in srgb, var(--accent) 32%, var(--border));
      border-radius: 999px;
      border: 2px solid transparent;
      background-clip: padding-box;
    }
    .help-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      gap: 10px;
    }
    .help-head h3 { margin: 0; font-size: 18px; }
    .help-content h4 { margin: 12px 0 6px; }
    .help-content p { margin: 0 0 8px; }
    .help-content ul { margin: 0 0 12px 18px; padding: 0; }
    .help-content li { margin-bottom: 4px; }
    .help-content code {
      font-family: var(--font-mono);
      background: var(--help-code-bg);
      color: var(--help-code-fg);
      border-radius: 4px;
      padding: 1px 4px;
    }
    .help-content pre {
      margin: 8px 0 12px;
      max-height: none;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .help-content pre code {
      background: transparent;
      color: inherit;
      padding: 0;
      border-radius: 0;
    }
    @keyframes panelFade {
      from {
        opacity: 0;
        transform: translateY(7px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    @keyframes navSlideIn {
      from {
        opacity: 0;
        transform: translateX(-8px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }
    @keyframes panelFloatIn {
      from {
        opacity: 0;
        transform: translateY(10px) scale(0.99);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    @media (max-width: 980px) {
      .app-shell {
        grid-template-columns: 1fr;
        padding: 14px 12px 22px;
      }
      .nav-column {
        position: static;
        top: auto;
        left: auto;
        bottom: auto;
        width: auto;
        max-height: none;
        z-index: auto;
      }
      .nav-list {
        display: flex;
        flex-wrap: nowrap;
        overflow-x: auto;
      }
      .nav-btn {
        flex: 0 0 auto;
        width: auto;
        min-width: 178px;
      }
      .workspace-head p {
        font-size: 17px;
      }
      .card h2 {
        font-size: 17px;
      }
    }
    @media (prefers-reduced-motion: reduce) {
      .workspace-panel.active,
      .help-panel,
      .help-modal.open,
      .nav-btn {
        animation: none;
      }
      button,
      .help-icon,
      .nav-btn,
      .dropzone,
      .info-icon {
        transition: none;
      }
    }
    @media (max-width: 640px) {
      .workspace-head {
        padding: 10px;
      }
      .workspace-head p {
        font-size: 16px;
      }
      .card {
        padding: 10px;
      }
      .metric-grid,
      .dashboard-grid {
        grid-template-columns: 1fr;
      }
      .vector-card-list,
      .inspector-list {
        max-height: 18rem;
      }
      .import-live {
        grid-template-columns: 1fr;
      }
      .doc-viewer-layout {
        grid-template-columns: 1fr;
      }
      .import-preview {
        min-height: 190px;
      }
      .import-preview embed,
      .import-preview iframe,
      .import-preview img {
        height: 190px;
        max-height: 190px;
      }
      .import-preview-pdf-canvas-wrap {
        width: min(150px, 94%);
      }
      .dashboard-storage-layout {
        grid-template-columns: 1fr;
        gap: 10px;
      }
      .storage-donut {
        width: 170px;
        height: 170px;
      }
      .storage-donut::after {
        inset: 20px;
      }
    }
  </style>
</head>
<body data-theme="harmonious-light">
  <header>
    <div class="header-top">
      <div class="brand-block">
        <div class="brand-identity">
          <img class="app-icon" src="/static/icons/icon-header-gold.png" alt="Stemma Codicum icon" />
          <h1>Stemma Codicum</h1>
        </div>
      </div>
      <div class="theme-picker">
        <label for="theme-select">Theme</label>
        <select id="theme-select" onchange="setTheme(this.value)">
          <option value="harmonious-light">Soft Light</option>
          <option value="restful-dark">Slate Dark</option>
          <option value="forest-mist">Forest Mist</option>
          <option value="sunset-paper">Paper Warm</option>
          <option value="midnight-contrast">Midnight Slate</option>
        </select>
      </div>
    </div>
  </header>
  <main class="app-shell">
    <aside class="nav-column">
      <div class="nav-list">
        <button class="secondary nav-btn" type="button" data-pane="dashboard">Home</button>
        <button class="secondary nav-btn" type="button" data-pane="project">Project and Health</button>
        <button class="secondary nav-btn" type="button" data-pane="database">Database Explorer</button>
        <button class="secondary nav-btn" type="button" data-pane="viewer">Document Viewer</button>
        <button class="secondary nav-btn" type="button" data-pane="ingest">Import</button>
        <button class="secondary nav-btn" type="button" data-pane="references">References</button>
        <button class="secondary nav-btn" type="button" data-pane="extraction">Extraction</button>
        <button class="secondary nav-btn" type="button" data-pane="vector">Vector</button>
        <button class="secondary nav-btn" type="button" data-pane="claims">Claims</button>
        <button class="secondary nav-btn" type="button" data-pane="binding">Binding</button>
        <button class="secondary nav-btn" type="button" data-pane="verification">Verification and Reports</button>
        <button class="secondary nav-btn" type="button" data-pane="trace">Trace</button>
        <button class="secondary nav-btn" type="button" data-pane="ceapf">CEAPF</button>
      </div>
    </aside>

    <section class="workspace">
      <div class="workspace-head">
        <h2 id="workspace-title">Function Workspace</h2>
        <p id="workspace-subtitle">Home</p>
      </div>

      <section class="card workspace-panel" data-pane="dashboard" data-help-key="dashboard">
      <h2>Home</h2>
      <div class="row">
        <button onclick="loadDashboard()">Refresh Summary</button>
        <button class="secondary" onclick="loadDashboard(true)">Refresh + Doctor</button>
      </div>
      <p id="dashboard-status" class="small">Load summary to view overall system status.</p>
      <h3 class="dashboard-section-title">System Snapshot</h3>
      <div id="dashboard-kpis" class="dashboard-grid"></div>
      <h3 class="dashboard-section-title">Storage and Paths</h3>
      <div id="dashboard-storage" class="dashboard-storage-panel">
        <p class="small">No storage summary loaded yet.</p>
      </div>
      <h3 class="dashboard-section-title">Recent Runs</h3>
      <div id="dashboard-runs" class="issue-list">
        <p class="small">No dashboard summary loaded yet.</p>
      </div>
      <details class="raw-json">
        <summary>Raw JSON</summary>
        <pre id="out-dashboard"></pre>
      </details>
      </section>

      <section class="card workspace-panel" data-pane="project" data-help-key="project">
      <h2>Project and Health</h2>
      <div class="row">
        <button onclick="runInitProject()">Init Project</button>
        <button class="secondary" onclick="runDoctor()">Doctor</button>
      </div>
      <p id="project-health-status" class="small">Run Doctor to load health diagnostics.</p>
      <div id="project-health-visual" class="metric-grid"></div>
      <div id="project-health-issues" class="issue-list">
        <p class="small">No health issues loaded.</p>
      </div>
      <details class="raw-json">
        <summary>Raw JSON</summary>
        <pre id="out-project"></pre>
      </details>
      </section>

      <section class="card workspace-panel" data-pane="database" data-help-key="database">
      <h2>Database Explorer</h2>
      <div class="row">
        <button class="secondary" onclick="dbListTables()">List Tables</button>
        <select id="db-table-select">
          <option value="">Select table</option>
        </select>
      </div>
      <div class="row">
        <input id="db-limit" value="50" placeholder="Row limit" />
        <input id="db-offset" value="0" placeholder="Offset" />
        <button onclick="dbViewTable()">View Rows</button>
        <button class="secondary" onclick="dbDescribeTable()">Table Schema</button>
      </div>
      <div id="db-grid-controls" class="row db-grid-controls">
        <select id="db-view-mode" onchange="dbSetViewMode(this.value)">
          <option value="spreadsheet">Spreadsheet View</option>
          <option value="json">JSON View</option>
        </select>
        <input id="db-search" placeholder="Search current view (all columns)" />
        <button id="db-clear-filters" class="secondary" onclick="dbClearFilters()">Clear Filters</button>
      </div>
      <p class="small">Inspect table names, row counts, schema, and sample rows.</p>
      <div id="db-grid-view">
        <p class="small" id="db-grid-meta">Load a table to inspect data in spreadsheet mode.</p>
        <div class="db-grid-scroll">
          <table id="db-grid-table" class="db-grid-table"></table>
        </div>
      </div>
      <pre id="out-db"></pre>
      </section>

      <section class="card workspace-panel" data-pane="viewer" data-help-key="viewer">
      <h2>Document Viewer</h2>
      <div class="row">
        <select id="viewer-resource-select">
          <option value="">Select resource</option>
        </select>
        <button class="secondary" onclick="viewerRefreshResources()">Refresh Resources</button>
        <button onclick="viewerOpenSelected()">Open Selected</button>
      </div>
      <div class="row">
        <input id="viewer-resource-id" placeholder="Resource ID or digest" />
        <button class="secondary" onclick="viewerOpenFromInput()">Open ID/Digest</button>
      </div>
      <div class="row viewer-toolbar">
        <button class="secondary" onclick="viewerPrevPage()">Prev Page</button>
        <button class="secondary" onclick="viewerNextPage()">Next Page</button>
        <span id="viewer-page-label" class="small">Page 1 / 1</span>
        <button class="secondary" onclick="viewerZoomOut()">-</button>
        <button class="secondary" onclick="viewerZoomIn()">+</button>
        <span id="viewer-zoom-label" class="small">100%</span>
        <label class="viewer-toggle"><input id="viewer-toggle-tables" type="checkbox" checked onchange="viewerRenderOverlay()">Tables</label>
        <label class="viewer-toggle"><input id="viewer-toggle-segments" type="checkbox" checked onchange="viewerRenderOverlay()">Segments</label>
        <label class="viewer-toggle"><input id="viewer-toggle-annotations" type="checkbox" checked onchange="viewerRenderOverlay()">Annotations</label>
        <label class="viewer-toggle"><input id="viewer-pan-toggle" type="checkbox" onchange="viewerTogglePan(this.checked)">Pan Drag</label>
      </div>
      <p id="viewer-status" class="small">Select a resource to inspect original source content, metadata, extracted tables, and annotation structure.</p>
      <div class="doc-viewer-layout">
        <div class="doc-viewer-stage">
          <div id="viewer-scroll" class="doc-viewer-scroll">
            <canvas id="viewer-pdf-canvas"></canvas>
            <canvas id="viewer-overlay-canvas"></canvas>
            <div id="viewer-fallback" class="doc-viewer-fallback">
              <p class="small">Open a resource to render a source view and overlays.</p>
            </div>
          </div>
        </div>
        <div class="doc-viewer-side">
          <h3 class="dashboard-section-title">Metadata</h3>
          <div id="viewer-metadata" class="metric-grid">
            <p class="small">No resource loaded.</p>
          </div>
          <h3 class="dashboard-section-title">Overlay Objects</h3>
          <div id="viewer-overlay-list" class="inspector-list">
            <p class="small">No overlays yet.</p>
          </div>
          <h3 class="dashboard-section-title">Table Inspector</h3>
          <div class="row">
            <input id="viewer-cell-row" placeholder="Row (1-based)" />
            <input id="viewer-cell-col" placeholder="Col (1-based)" />
            <button class="secondary" onclick="viewerFocusCell()">Focus Cell</button>
          </div>
          <p id="viewer-cell-status" class="small"></p>
          <div id="viewer-table-grid" class="db-grid-scroll">
            <p class="small">No table selected.</p>
          </div>
          <h3 class="dashboard-section-title">Annotations</h3>
          <div id="viewer-annotation-list" class="inspector-list">
            <p class="small">No annotations loaded.</p>
          </div>
        </div>
      </div>
      <details class="raw-json">
        <summary>Raw JSON</summary>
        <pre id="out-viewer"></pre>
      </details>
      </section>

      <section class="card workspace-panel" data-pane="ingest" data-help-key="ingest">
      <h2>Import</h2>
      <div id="dropzone" class="dropzone">Drag & drop one or more documents here to import (dedupe-aware)</div>
      <div class="row">
        <input id="ingest-path" placeholder="Absolute file path" />
        <button onclick="ingestPath()">Import File Path</button>
      </div>
      <div class="row">
        <input id="resources-limit" value="20" />
        <button class="secondary" onclick="listResources()">List Resources</button>
      </div>
      <h3 class="import-history-title">Current Import</h3>
      <div id="import-live" class="import-live current-focus empty">
        <p class="small">Drop one or more documents to begin. This panel shows the currently processing file with thumbnail preview, staged progress, extraction/table/vector status, and confirmation metadata.</p>
      </div>
      <h3 class="import-history-title">Drop Queue</h3>
      <div id="import-drop-queue" class="import-queue">
        <p class="small">No files queued.</p>
      </div>
      <h3 class="import-history-title">Recent Imports</h3>
      <div id="import-history" class="import-history">
        <p class="small">No imports yet.</p>
      </div>
      <h3 class="dashboard-section-title">Mass Import (Recursive)</h3>
      <div class="row">
        <input id="pipe-root" value="/Volumes/X10/data/Institution" placeholder="Root directory" />
        <input id="pipe-max" placeholder="Max files (optional)" value="25" />
        <input id="pipe-timeout" placeholder="Extract timeout sec" value="300" />
        <select id="pipe-skip">
          <option value="false">extract enabled</option>
          <option value="true">skip extraction</option>
        </select>
        <button class="secondary" onclick="runMassImport()">Run Mass Import</button>
      </div>
      <p class="small">Mass import recursively scans the root path and processes all supported document types.</p>
      <details class="raw-json">
        <summary>Raw JSON</summary>
        <pre id="out-ingest"></pre>
      </details>
      </section>

      <section class="card workspace-panel" data-pane="references" data-help-key="references">
      <h2>References</h2>
      <div class="row">
        <input id="bib-path" placeholder="/path/to/references.bib" />
        <button onclick="importBib()">Import BibTeX</button>
      </div>
      <div class="row">
        <input id="link-cite-id" placeholder="Cite ID" />
        <input id="link-digest" placeholder="Resource digest" />
        <button onclick="linkReference()">Link Ref->Resource</button>
      </div>
      <div class="row">
        <button class="secondary" onclick="callApi('GET','/api/refs',null,'out-refs')">List Refs</button>
        <button class="secondary" onclick="callApi('GET','/api/citations',null,'out-refs')">List Citations</button>
      </div>
      <pre id="out-refs"></pre>
      </section>

      <section class="card workspace-panel" data-pane="extraction" data-help-key="extraction">
      <h2>Extraction</h2>
      <div class="row">
        <input id="extract-resource-id" placeholder="Resource ID (optional)" />
        <input id="extract-digest" placeholder="Resource digest (optional)" />
        <button onclick="extractRun()">Run Extract</button>
      </div>
      <div class="row">
        <input id="extract-tables-id" placeholder="Resource ID (optional)" />
        <input id="extract-tables-digest" placeholder="Resource digest (optional)" />
        <button class="secondary" onclick="extractTables()">List Tables</button>
      </div>
      <p class="small">Extraction Inspector: inspect canonical text, standoff segments, annotations, and full extraction dumps.</p>
      <div class="row">
        <input id="inspect-resource-id" placeholder="Inspector resource ID (optional)" />
        <input id="inspect-resource-digest" placeholder="Inspector resource digest (optional)" />
        <input id="inspect-run-id" placeholder="Inspector run ID (optional, latest if empty)" />
      </div>
      <div class="row">
        <input id="inspect-segment-type" placeholder="Segment type filter (e.g. layout:paragraph)" />
        <input id="inspect-layer" placeholder="Layer filter (e.g. domain_financial)" />
        <input id="inspect-category" placeholder="Category filter (e.g. metric)" />
        <input id="inspect-limit" value="200" placeholder="Limit" />
      </div>
      <div class="row">
        <input id="inspect-segment-limit" value="2000" placeholder="Dump segment limit" />
        <input id="inspect-annotation-limit" value="2000" placeholder="Dump annotation limit" />
        <input id="inspect-table-limit" value="500" placeholder="Dump table limit" />
      </div>
      <div class="row">
        <button class="secondary" onclick="extractInspectorText()">Inspect Text</button>
        <button class="secondary" onclick="extractInspectorSegments()">Inspect Segments</button>
        <button class="secondary" onclick="extractInspectorAnnotations()">Inspect Annotations</button>
        <button class="secondary" onclick="extractInspectorDump()">Inspect Dump</button>
      </div>
      <div id="extract-inspector-list" class="inspector-list">
        <p class="small">No inspector items loaded yet.</p>
      </div>
      <p id="extract-inspector-copy-status" class="inspector-copy-status"></p>
      <pre id="out-extract"></pre>
      <pre id="out-extract-inspector"></pre>
      </section>

      <section class="card workspace-panel" data-pane="vector" data-help-key="vector">
      <h2>Vector Index and Search</h2>
      <div class="row">
        <input id="vector-resource-id" placeholder="Resource ID (optional)" />
        <input id="vector-resource-digest" placeholder="Resource digest (optional)" />
        <input id="vector-extraction-run-id" placeholder="Extraction run ID (optional)" />
      </div>
      <div class="row">
        <input id="vector-status-limit" value="25" placeholder="Status run limit" />
        <select id="vector-force">
          <option value="false">skip if already indexed</option>
          <option value="true">force re-index</option>
        </select>
        <button onclick="vectorIndex()">Index</button>
        <button class="secondary" onclick="vectorStatus()">Status</button>
      </div>
      <div class="row">
        <input id="vector-backfill-limit-resources" value="100000" placeholder="Backfill limit resources" />
        <input id="vector-backfill-max-process" placeholder="Backfill max process (optional)" />
        <button class="secondary" onclick="vectorBackfill()">Backfill</button>
      </div>
      <div class="row">
        <input id="vector-query" placeholder="Semantic query" />
        <input id="vector-query-limit" value="10" placeholder="Search limit" />
        <button class="secondary" onclick="vectorSearch()">Search</button>
      </div>
      <p id="vector-status-note" class="small">Load status to inspect vector backend health and run history.</p>
      <div id="vector-summary" class="metric-grid"></div>
      <div id="vector-runs" class="vector-card-list">
        <p class="small">No vector runs loaded yet.</p>
      </div>
      <div id="vector-search-results" class="vector-card-list">
        <p class="small">No vector search results yet.</p>
      </div>
      <details class="raw-json">
        <summary>Raw JSON</summary>
        <pre id="out-vector"></pre>
      </details>
      </section>

      <section class="card workspace-panel" data-pane="claims" data-help-key="claims">
      <h2>Claims</h2>
      <div class="row">
        <input id="claims-file" placeholder="Claims file path" />
        <select id="claims-format">
          <option value="csv">csv</option>
          <option value="json">json</option>
          <option value="md">md</option>
        </select>
        <input id="claim-set" placeholder="Claim set name" />
        <button onclick="importClaims()">Import Claims</button>
      </div>
      <div class="row">
        <input id="claims-list-set" placeholder="Claim set filter (optional)" />
        <button class="secondary" onclick="listClaims()">List Claims</button>
        <button class="secondary" onclick="callApi('GET','/api/claim-sets',null,'out-claims')">List Claim Sets</button>
      </div>
      <pre id="out-claims"></pre>
      </section>

      <section class="card workspace-panel" data-pane="binding" data-help-key="binding">
      <h2>Binding</h2>
      <div class="row">
        <input id="bind-claim-id" placeholder="Claim ID" />
        <input id="bind-resource-id" placeholder="Resource ID (optional)" />
        <input id="bind-digest" placeholder="Resource digest (optional)" />
      </div>
      <div class="row">
        <input id="bind-role" placeholder="Role (value-cell/quote/etc.)" />
      </div>
      <textarea id="bind-selectors">[{"type":"PageGeometrySelector","pageIndex":0,"boxes":[]},{"type":"TextQuoteSelector","exact":"example"}]</textarea>
      <div class="row">
        <button onclick="bindAdd()">Add Binding</button>
        <button class="secondary" onclick="bindValidate()">Validate Binding</button>
      </div>
      <pre id="out-bind"></pre>
      </section>

      <section class="card workspace-panel" data-pane="verification" data-help-key="verification">
      <h2>Verification and Reports</h2>
      <div class="row">
        <input id="verify-claim-id" placeholder="Claim ID" />
        <button onclick="verifyClaim()">Verify Claim</button>
      </div>
      <div class="row">
        <input id="verify-claim-set" placeholder="Claim set" />
        <button onclick="verifySet()">Verify Set</button>
      </div>
      <div class="row">
        <input id="report-run-id" placeholder="Verification run ID" />
        <input id="report-json-out" placeholder="json output path (optional)" />
        <input id="report-md-out" placeholder="md output path (optional)" />
        <button class="secondary" onclick="reportVerification()">Get Report</button>
      </div>
      <pre id="out-verify"></pre>
      </section>

      <section class="card workspace-panel" data-pane="trace" data-help-key="trace">
      <h2>Trace</h2>
      <div class="row">
        <input id="trace-claim-id" placeholder="Claim ID" />
        <button onclick="traceClaim()">Trace Claim</button>
      </div>
      <div class="row">
        <input id="trace-resource-id" placeholder="Resource ID (optional)" />
        <input id="trace-resource-digest" placeholder="Resource digest (optional)" />
        <button onclick="traceResource()">Trace Resource</button>
      </div>
      <div class="row">
        <input id="trace-cite-id" placeholder="Cite ID" />
        <button onclick="traceCitation()">Trace Citation</button>
      </div>
      <pre id="out-trace"></pre>
      </section>

      <section class="card workspace-panel" data-pane="ceapf" data-help-key="ceapf">
      <h2>CEAPF</h2>
      <textarea id="ceapf-prop">{"subject":"org:InstitutionZ","predicate":"ceapf:spent","object":{"amount":3.4,"unit":"GBP"}}</textarea>
      <div class="row">
        <button onclick="addProposition()">Add Proposition</button>
        <button class="secondary" onclick="listPropositions()">List Propositions</button>
      </div>
      <div class="row">
        <input id="ceapf-prop-id" placeholder="Proposition ID" />
        <input id="ceapf-agent" placeholder="Agent" value="person:AuthorX" />
        <input id="ceapf-modality" placeholder="Modality" value="asserts" />
        <button onclick="addAssertion()">Add Assertion</button>
      </div>
      <div class="row">
        <input id="ceapf-rel-type" placeholder="Relation type" value="supports" />
        <input id="ceapf-from-type" placeholder="From type" value="assertion_event" />
        <input id="ceapf-from-id" placeholder="From ID" />
        <input id="ceapf-to-type" placeholder="To type" value="proposition" />
        <input id="ceapf-to-id" placeholder="To ID" />
        <button onclick="addRelation()">Add Relation</button>
      </div>
      <pre id="out-ceapf"></pre>
      </section>

    </section>
  </main>

<div id="help-modal" class="help-modal" aria-hidden="true">
  <div class="help-panel">
    <div class="help-head">
      <h3 id="help-title">Help</h3>
      <button class="secondary" onclick="closeHelp()">Close</button>
    </div>
    <div id="help-content" class="help-content"></div>
  </div>
</div>

<script>
const HELP_CONTENT = {
  dashboard: {
    title: "Home",
    basic: `
      <p>Use this panel for a single-page summary of core system health and workload state.</p>
      <ul>
        <li><code>Refresh Summary</code>: lightweight snapshot (counts + recent runs + vector state).</li>
        <li><code>Refresh + Doctor</code>: includes full integrity checks.</li>
      </ul>
    `,
    full: `
      <p>The dashboard is intended for triage and routine checks before deeper workflows.</p>
      <h4>Recommended cadence</h4>
      <ul>
        <li>Use lightweight summary during active work.</li>
        <li>Use doctor refresh before major ingest/extract batches.</li>
      </ul>
      <pre><code>GET /api/dashboard/summary
GET /api/dashboard/summary?include_doctor=true</code></pre>
    `,
  },
  project: {
    title: "Project and Health",
    basic: `
      <p>Use this card to initialize project files and run diagnostic checks.</p>
      <h4>Core actions</h4>
      <ul>
        <li><code>Init Project</code>: creates/repairs <code>.stemma/</code> and database schema.</li>
        <li><code>Doctor</code>: runs integrity checks and DB runtime checks.</li>
      </ul>
      <h4>Example flow</h4>
      <pre><code>1) Click Init Project
2) Click Doctor
3) Confirm "ok": true and db_runtime.journal_mode = "wal"</code></pre>
    `,
    full: `
      <p>This card corresponds to <code>stemma init</code> and <code>stemma doctor</code>. Run these before batch work or after crashes.</p>
      <h4>When to use</h4>
      <ul>
        <li>Fresh project setup.</li>
        <li>Before/after long import runs.</li>
        <li>To verify DB concurrency settings and archive integrity.</li>
      </ul>
      <h4>Example</h4>
      <pre><code>POST /api/init
GET /api/doctor

Expected doctor signals:
- checks_run >= 4
- db_runtime.journal_mode = "wal"
- db_runtime.busy_timeout_ms > 0</code></pre>
    `,
  },
  database: {
    title: "Database Explorer",
    basic: `
      <p>Inspect real database state: table list, row counts, schema, and sample rows.</p>
      <h4>Quick start</h4>
      <ul>
        <li>Click <code>List Tables</code> to load all tables and counts.</li>
        <li>Select a table and click <code>View Rows</code>.</li>
        <li>Use <code>Spreadsheet View</code> for sortable/filterable grid output.</li>
        <li>Use <code>Table Schema</code> to view create SQL and columns.</li>
      </ul>
      <h4>Example</h4>
      <pre><code>Table: resources
Limit: 50
Offset: 0
Action: View Rows</code></pre>
    `,
    full: `
      <p>This card is for learning and diagnostics. It uses read-only style inspection endpoints.</p>
      <h4>Recommended checks</h4>
      <ul>
        <li>After ingest: verify rows in <code>resources</code> and <code>resource_digests</code>.</li>
        <li>After extraction: verify <code>extraction_runs</code> and <code>extracted_tables</code>.</li>
        <li>After binding/verification: inspect <code>evidence_*</code> and <code>verification_*</code> tables.</li>
        <li>Use global search + per-column filters to narrow large result sets quickly.</li>
      </ul>
      <h4>Example sequence</h4>
      <pre><code>1) List Tables
2) Table Schema on extraction_runs
3) View Rows on extraction_runs (limit 20)
4) View Rows on extracted_tables (limit 20)</code></pre>
    `,
  },
  viewer: {
    title: "Document Viewer",
    basic: `
      <p>Inspect a source document with metadata, extraction overlays, table structures, and annotation traces.</p>
      <ul>
        <li>Load a resource by dropdown, ID, or digest.</li>
        <li>Use page + zoom controls and optional drag-pan mode for PDF navigation.</li>
        <li>Toggle table/segment/annotation overlays.</li>
        <li>Inspect table cells by row/column and review annotation snippets.</li>
      </ul>
    `,
    full: `
      <p>This panel combines immutable source file viewing with extracted structural data for audit workflows.</p>
      <h4>Designed for audit trails</h4>
      <ul>
        <li>Metadata: digest, media type, source URI, archive path, and ingest timestamps.</li>
        <li>Geometry overlays: table/segment bboxes when available from parser output.</li>
        <li>Table inspector: inspect row/col values and approximate cell coordinates.</li>
        <li>Annotation inspector: review labels/spans with contextual text snippets.</li>
      </ul>
      <pre><code>1) Open a resource
2) Move to page N
3) Select table T
4) Focus row R / col C for value traceability</code></pre>
    `,
  },
  ingest: {
    title: "Import",
    basic: `
      <p>Add source files into immutable archive storage with deduplication.</p>
      <ul>
        <li>Use drag/drop for quick one-or-many file import with queue tracking.</li>
        <li>Use absolute path import for scripted workflows.</li>
        <li>Use mass import for recursive directory processing.</li>
        <li>Use <code>List Resources</code> to verify digest + metadata.</li>
      </ul>
      <pre><code>Path example:
/Users/you/downloads/report.pdf</code></pre>
    `,
    full: `
      <p>Equivalent to <code>stemma ingest ...</code>, <code>stemma resources</code>, and bulk import workflows. The archive is digest-addressed.</p>
      <h4>Tips</h4>
      <ul>
        <li>Duplicate file bytes return status <code>duplicate</code> without archive rewrite.</li>
        <li>Single-file import attempts extraction/vector indexing automatically for extractable media types.</li>
        <li>Mass import recursively scans a root path and resumes using state/log files under <code>.stemma/</code>.</li>
        <li>Use resources listing to obtain <code>resource.id</code> and digest for downstream steps.</li>
      </ul>
      <pre><code>Typical flow:
1) Import file or run mass import
2) List Resources (limit 20)
3) Confirm extraction/vector status in response</code></pre>
    `,
  },
  references: {
    title: "References",
    basic: `
      <p>Import bibliography records and connect citations to ingested resources.</p>
      <ul>
        <li><code>Import BibTeX</code> reads a .bib file.</li>
        <li><code>Link Ref-&gt;Resource</code> maps cite ID to resource digest.</li>
      </ul>
      <pre><code>Cite ID example: AB12
Digest example: 64-char sha256</code></pre>
    `,
    full: `
      <p>Use this when turning bibliographic metadata into auditable source links.</p>
      <h4>Recommended flow</h4>
      <ul>
        <li>Import BibTeX first.</li>
        <li>List citations to get generated cite IDs.</li>
        <li>Link each citation to a known ingested digest.</li>
      </ul>
      <pre><code>1) Import BibTeX
2) List Citations
3) Link Ref-&gt;Resource using cite_id + digest
4) List Refs to confirm links</code></pre>
    `,
  },
  extraction: {
    title: "Extraction",
    basic: `
      <p>Run extraction for one resource, then inspect tables, text, segments, and annotations.</p>
      <ul>
        <li>Provide either resource ID or digest.</li>
        <li><code>Run Extract</code> creates extraction runs.</li>
        <li><code>List Tables</code> returns extracted table records.</li>
        <li><code>Extraction Inspector</code> calls text/segment/annotation/dump APIs.</li>
      </ul>
      <pre><code>Use exactly one selector:
- Resource ID
- Resource digest</code></pre>
    `,
    full: `
      <p>This maps to <code>stemma extract run</code>, <code>stemma extract tables</code>, <code>stemma extract text</code>, <code>stemma extract segments</code>, <code>stemma extract annotations</code>, and <code>stemma extract dump</code>.</p>
      <h4>What to watch</h4>
      <ul>
        <li>Summary fields: parser, timing, tables found.</li>
        <li>Table IDs are deterministic for stable binding.</li>
        <li>Inspector supports optional <code>run_id</code> for historical run debugging.</li>
        <li>Segments and annotations include compact cards with <code>Copy Selector JSON</code> actions.</li>
      </ul>
      <pre><code>1) Run Extract for digest
2) List Tables for same digest
3) Use Inspect Text / Segments / Annotations
4) Copy table_id into binding selectors if needed</code></pre>
    `,
  },
  vector: {
    title: "Vector",
    basic: `
      <p>Manage vector indexing and semantic search.</p>
      <ul>
        <li><code>Index</code>: index latest or specified extraction run for one resource.</li>
        <li><code>Status</code>: show backend, model, chunk counts, and recent runs.</li>
        <li><code>Backfill</code>: index missing latest runs in bulk.</li>
        <li><code>Search</code>: semantic lookup over indexed chunks.</li>
      </ul>
    `,
    full: `
      <p>This panel wraps <code>/api/vector/index</code>, <code>/api/vector/status</code>, <code>/api/vector/backfill</code>, and <code>/api/vector/search</code>.</p>
      <h4>Good workflow</h4>
      <ul>
        <li>Run extraction first.</li>
        <li>Index resource or backfill recent candidates.</li>
        <li>Use status to check chunk/point consistency.</li>
        <li>Run semantic queries and inspect hit metadata.</li>
      </ul>
    `,
  },
  claims: {
    title: "Claims",
    basic: `
      <p>Import claims into a claim set and inspect claim records.</p>
      <ul>
        <li>Choose format (<code>csv</code>, <code>json</code>, <code>md</code>).</li>
        <li>Set claim set name for grouping.</li>
      </ul>
      <pre><code>Claim set example: annual-report-2025</code></pre>
    `,
    full: `
      <p>This card is the entry point for structured assertion data.</p>
      <h4>Good workflow</h4>
      <ul>
        <li>Import into a named claim set.</li>
        <li>Use list filters to inspect only one set.</li>
        <li>Then bind evidence and run verification.</li>
      </ul>
      <pre><code>1) Import Claims
2) List Claim Sets
3) List Claims (claim set filter)</code></pre>
    `,
  },
  binding: {
    title: "Binding",
    basic: `
      <p>Attach evidence selectors to a claim and validate required roles.</p>
      <ul>
        <li>Provide claim ID and one resource selector (ID or digest).</li>
        <li>Provide role and selector JSON array.</li>
      </ul>
      <pre><code>[{"type":"PageGeometrySelector","pageIndex":0,"boxes":[]},
 {"type":"TextQuoteSelector","exact":"example"}]</code></pre>
    `,
    full: `
      <p>Bindings are the core of machine-verifiable provenance.</p>
      <h4>Guidance</h4>
      <ul>
        <li>Use at least two distinct selector types for robustness.</li>
        <li>Run <code>Validate Binding</code> after each add.</li>
        <li>For quantitative claims, include value-cell and supporting roles.</li>
      </ul>
      <pre><code>1) Add Binding
2) Validate Binding
3) Fix missing roles or selector diversity issues</code></pre>
    `,
  },
  verification: {
    title: "Verification and Reports",
    basic: `
      <p>Run deterministic verification and export run reports.</p>
      <ul>
        <li><code>Verify Claim</code>: one claim.</li>
        <li><code>Verify Set</code>: all claims in set.</li>
        <li><code>Get Report</code>: summary + optional file exports.</li>
      </ul>
      <pre><code>Policy profile defaults to "strict"</code></pre>
    `,
    full: `
      <p>Use verification after import + binding are complete.</p>
      <h4>Typical process</h4>
      <ul>
        <li>Verify set for batch signal.</li>
        <li>Use report output to inspect failures.</li>
        <li>Optionally export JSON and Markdown reports.</li>
      </ul>
      <pre><code>1) Verify Set (claim set)
2) Copy run_id from response
3) Get Report with run_id</code></pre>
    `,
  },
  trace: {
    title: "Trace",
    basic: `
      <p>Navigate links between claims, evidence, resources, and citations.</p>
      <ul>
        <li>Trace from claim ID, resource selector, or cite ID.</li>
      </ul>
      <pre><code>Trace by one anchor at a time:
- claim_id
- resource_id/resource_digest
- cite_id</code></pre>
    `,
    full: `
      <p>Trace is best for audits and debugging missing evidence links.</p>
      <h4>Use cases</h4>
      <ul>
        <li>Confirm which evidence items back a claim.</li>
        <li>Find all claims tied to one resource.</li>
        <li>Review citation-resource consistency.</li>
      </ul>
      <pre><code>1) Trace claim
2) Trace resource from returned resource id
3) Trace citation from cite id</code></pre>
    `,
  },
  ceapf: {
    title: "CEAPF",
    basic: `
      <p>Create propositions/assertions and connect them with argument relations.</p>
      <ul>
        <li>Add proposition JSON.</li>
        <li>Add assertion event for proposition.</li>
        <li>Add support/rebuttal relation edges.</li>
      </ul>
      <pre><code>{"subject":"org:X","predicate":"ceapf:spent","object":{"amount":3.4,"unit":"GBP"}}</code></pre>
    `,
    full: `
      <p>CEAPF supports higher-level argument graph modeling on top of evidence.</p>
      <h4>Practical flow</h4>
      <ul>
        <li>Create proposition first.</li>
        <li>Create assertion(s) with modality and agent.</li>
        <li>Connect assertions and propositions with directed relation types.</li>
      </ul>
      <pre><code>Relation types:
- supports
- rebuts
- undercuts
- qualifies</code></pre>
    `,
  },
};

function installHelpButtons() {
  document.querySelectorAll('.card[data-help-key]').forEach((card) => {
    const key = card.dataset.helpKey;
    const icon = document.createElement('button');
    icon.className = 'help-icon';
    icon.textContent = '?';
    icon.title = 'Help';
    icon.setAttribute('aria-label', 'Help');
    icon.onclick = () => showHelp(key);
    card.appendChild(icon);
  });
}

function showHelp(key) {
  const entry = HELP_CONTENT[key];
  if (!entry) return;
  document.getElementById('help-title').textContent = `${entry.title} Help`;
  document.getElementById('help-content').innerHTML = `
    <h4>Basic</h4>
    ${entry.basic || ''}
    <h4>Comprehensive</h4>
    ${entry.full || ''}
  `;
  const modal = document.getElementById('help-modal');
  modal.classList.add('open');
  modal.setAttribute('aria-hidden', 'false');
}

function closeHelp() {
  const modal = document.getElementById('help-modal');
  modal.classList.remove('open');
  modal.setAttribute('aria-hidden', 'true');
}

function setActivePane(pane) {
  const panels = Array.from(document.querySelectorAll('.workspace-panel[data-pane]'));
  if (!panels.length) return;

  const known = new Set(panels.map((panel) => panel.dataset.pane));
  const chosen = known.has(pane) ? pane : panels[0].dataset.pane;

  panels.forEach((panel) => {
    panel.classList.toggle('active', panel.dataset.pane === chosen);
  });
  document.querySelectorAll('.nav-btn[data-pane]').forEach((btn) => {
    btn.classList.toggle('active', btn.dataset.pane === chosen);
  });

  const entry = HELP_CONTENT[chosen];
  const subtitle = document.getElementById('workspace-subtitle');
  if (subtitle) subtitle.textContent = entry ? entry.title : chosen;
  localStorage.setItem('stemmaActivePane', chosen);
}

function initWorkspaceNav() {
  const buttons = Array.from(document.querySelectorAll('.nav-btn[data-pane]'));
  buttons.forEach((btn) => {
    btn.onclick = () => setActivePane(btn.dataset.pane);
  });
  const saved = localStorage.getItem('stemmaActivePane');
  const fallback = buttons.length ? buttons[0].dataset.pane : 'project';
  setActivePane(saved || fallback);
}

function initResizableOutputs() {
  const minHeightPx = 320;
  document.querySelectorAll('pre[id^="out-"]').forEach((panel) => {
    const key = `stemmaOutHeight:${panel.id}`;
    const saved = Number(localStorage.getItem(key) || "0");
    if (Number.isFinite(saved) && saved >= minHeightPx) {
      panel.style.height = `${saved}px`;
    }
    const persist = () => {
      const next = Math.max(minHeightPx, panel.clientHeight || minHeightPx);
      localStorage.setItem(key, String(next));
    };
    panel.addEventListener('mouseup', persist);
    panel.addEventListener('touchend', persist, { passive: true });
  });
}

function setTheme(themeName) {
  const allowed = new Set([
    'harmonious-light',
    'restful-dark',
    'forest-mist',
    'sunset-paper',
    'midnight-contrast',
  ]);
  const selected = allowed.has(themeName) ? themeName : 'harmonious-light';
  document.body.setAttribute('data-theme', selected);
  localStorage.setItem('stemmaTheme', selected);
  const picker = document.getElementById('theme-select');
  if (picker && picker.value !== selected) picker.value = selected;
}

function initTheme() {
  const saved = localStorage.getItem('stemmaTheme');
  setTheme(saved || 'harmonious-light');
}

function candidateApiUrls(url) {
  const results = [];
  const seen = new Set();
  const add = (u) => {
    if (!u || seen.has(u)) return;
    seen.add(u);
    results.push(u);
  };

  // Absolute path as configured in the UI.
  add(url);

  // Relative fallback (works when app is mounted under a path prefix).
  if (url.startsWith('/')) add(url.slice(1));

  // Prefix fallback for mounts like /stemma -> /stemma/api/...
  if (url.startsWith('/')) {
    const path = window.location.pathname || '/';
    const trimmed = path.replace(/\/+$/, '');
    const lastSeg = trimmed.split('/').pop() || '';
    if (trimmed && trimmed !== '/' && !lastSeg.includes('.')) {
      const prefixed = `${trimmed}${url}`;
      add(prefixed.replace(/\/{2,}/g, '/'));
    }
  }

  return results;
}

async function callApi(method, url, body, outId, isFormData=false) {
  const opts = { method, headers: {} };
  if (body !== null && body !== undefined) {
    if (isFormData) {
      opts.body = body;
    } else {
      opts.headers['Content-Type'] = 'application/json';
      opts.body = JSON.stringify(body);
    }
  }
  const attempts = candidateApiUrls(url);
  let lastData = null;
  try {
    for (const attemptUrl of attempts) {
      const res = await fetch(attemptUrl, opts);
      let data;
      const contentType = (res.headers.get('content-type') || '').toLowerCase();
      if (contentType.includes('application/json')) {
        data = await res.json();
      } else {
        const text = await res.text();
        data = { detail: text || `HTTP ${res.status}` };
      }

      if (!(res.status === 404 && data && data.detail === 'Not Found')) {
        if (outId) document.getElementById(outId).textContent = JSON.stringify(data, null, 2);
        return data;
      }
      lastData = data;
    }

    const payload = {
      ...(lastData || { detail: 'Not Found' }),
      attempted_urls: attempts,
    };
    if (outId) document.getElementById(outId).textContent = JSON.stringify(payload, null, 2);
    return payload;
  } catch (e) {
    if (outId) {
      document.getElementById(outId).textContent = JSON.stringify(
        { error: String(e), attempted_urls: attempts },
        null,
        2
      );
    }
    throw e;
  }
}

const HEALTH_FIELD_HELP = {
  ok: 'Overall result of the full doctor check suite.',
  checks_run: 'Number of health checks executed in this doctor run.',
  journal_mode: 'SQLite journal mode. WAL is required for robust concurrent access.',
  busy_timeout_ms: 'Milliseconds SQLite waits for a lock before failing.',
  foreign_keys: 'Whether SQLite foreign key constraints are enforced.',
  synchronous: 'SQLite durability level. Higher values increase durability.',
  wal_autocheckpoint_pages: 'WAL pages written before automatic checkpoint.',
  issues: 'Warnings and errors discovered during doctor checks.',
};

function toSafeInt(value, fallback = 0) {
  const parsed = Number(value);
  return Number.isFinite(parsed) ? Math.floor(parsed) : fallback;
}

function statusClass(status) {
  const normalized = String(status || '').toLowerCase();
  if (normalized === 'ok' || normalized === 'healthy' || normalized === 'success' || normalized === 'pass') {
    return 'status-ok';
  }
  if (normalized === 'warning' || normalized === 'warn' || normalized === 'degraded') {
    return 'status-warn';
  }
  if (normalized === 'error' || normalized === 'failed' || normalized === 'fail') {
    return 'status-error';
  }
  return 'status-neutral';
}

function titleCase(value) {
  const text = String(value || '').trim();
  if (!text) return '';
  return text.charAt(0).toUpperCase() + text.slice(1).toLowerCase();
}

function infoIcon(tooltip) {
  return `<span class="info-icon" title="${dbEscapeHtml(tooltip || '')}" aria-label="${dbEscapeHtml(tooltip || '')}">?</span>`;
}

function metricCard(label, valueHtml, helpText='') {
  return `
    <article class="metric-card">
      <p class="metric-label">${dbEscapeHtml(label)}${helpText ? ' ' + infoIcon(helpText) : ''}</p>
      <p class="metric-value">${valueHtml}</p>
    </article>
  `;
}

function renderIssueList(containerId, issues) {
  const container = document.getElementById(containerId);
  if (!container) return;
  if (!Array.isArray(issues) || !issues.length) {
    container.innerHTML = '<p class="small">No issues detected.</p>';
    return;
  }
  container.innerHTML = issues
    .map((issue) => {
      const level = String(issue.level || 'info').toLowerCase();
      const klass = level === 'error' ? 'issue-error' : (level === 'warning' ? 'issue-warning' : 'issue-info');
      return `<article class="issue-item ${klass}"><strong>${dbEscapeHtml(level)}</strong>${dbEscapeHtml(issue.message || '')}</article>`;
    })
    .join('');
}

function renderProjectHealth(payload) {
  const statusLine = document.getElementById('project-health-status');
  const visual = document.getElementById('project-health-visual');
  if (!statusLine || !visual) return;

  if (!payload || payload.ok === undefined) {
    statusLine.textContent = 'No health payload loaded.';
    visual.innerHTML = '';
    renderIssueList('project-health-issues', []);
    return;
  }

  if (payload.db_runtime) {
    const issues = Array.isArray(payload.issues) ? payload.issues : [];
    const errorCount = issues.filter((i) => String(i.level || '').toLowerCase() === 'error').length;
    const warningCount = issues.filter((i) => String(i.level || '').toLowerCase() === 'warning').length;
    const overall = payload.ok ? (warningCount > 0 ? 'warning' : 'ok') : 'error';
    statusLine.textContent = `Doctor loaded: ${payload.checks_run || 0} checks, ${errorCount} errors, ${warningCount} warnings.`;

    const runtime = payload.db_runtime || {};
    const syncCode = Number(runtime.synchronous);
    const syncName = (
      syncCode === 0 ? 'OFF' :
      syncCode === 1 ? 'NORMAL' :
      syncCode === 2 ? 'FULL' :
      syncCode === 3 ? 'EXTRA' :
      `CODE ${dbEscapeHtml(String(syncCode))}`
    );

    visual.innerHTML = `
      ${metricCard('Overall', `<span class="status-pill ${statusClass(overall)}">${dbEscapeHtml(titleCase(overall))}</span>`, HEALTH_FIELD_HELP.ok)}
      ${metricCard('Checks Run', dbEscapeHtml(String(payload.checks_run ?? 0)), HEALTH_FIELD_HELP.checks_run)}
      ${metricCard('Journal Mode', `<span class="status-pill ${statusClass(runtime.journal_mode === 'wal' ? 'ok' : 'warning')}">${dbEscapeHtml(titleCase(String(runtime.journal_mode || 'unknown')))}</span>`, HEALTH_FIELD_HELP.journal_mode)}
      ${metricCard('Busy Timeout', `${dbEscapeHtml(String(runtime.busy_timeout_ms ?? 0))} ms`, HEALTH_FIELD_HELP.busy_timeout_ms)}
      ${metricCard('Foreign Keys', `<span class="status-pill ${statusClass(runtime.foreign_keys ? 'ok' : 'error')}">${runtime.foreign_keys ? 'ENABLED' : 'DISABLED'}</span>`, HEALTH_FIELD_HELP.foreign_keys)}
      ${metricCard('Synchronous', dbEscapeHtml(syncName), HEALTH_FIELD_HELP.synchronous)}
      ${metricCard('WAL Auto-checkpoint', `${dbEscapeHtml(String(runtime.wal_autocheckpoint_pages ?? 'n/a'))} pages`, HEALTH_FIELD_HELP.wal_autocheckpoint_pages)}
      ${metricCard('Issues', dbEscapeHtml(String(issues.length)), HEALTH_FIELD_HELP.issues)}
    `;
    renderIssueList('project-health-issues', issues);
    return;
  }

  const created = Array.isArray(payload.paths_created) ? payload.paths_created : [];
  statusLine.textContent = payload.ok
    ? `Project initialized. ${created.length} path(s) created or repaired.`
    : 'Project initialization failed.';
  visual.innerHTML = `
    ${metricCard('Init Status', `<span class="status-pill ${statusClass(payload.ok ? 'ok' : 'error')}">${payload.ok ? 'READY' : 'FAILED'}</span>`, 'Result of project initialization.')}
    ${metricCard('Database Path', dbEscapeHtml(String(payload.db_path || 'n/a')), 'SQLite database path used by this project.')}
    ${metricCard('Paths Created', dbEscapeHtml(String(created.length)), 'Filesystem paths created or repaired by init.')}
  `;
  renderIssueList('project-health-issues', []);
}

async function runInitProject() {
  const payload = await callApi('POST', '/api/init', {}, 'out-project');
  renderProjectHealth(payload);
}

async function runDoctor() {
  const payload = await callApi('GET', '/api/doctor', null, 'out-project');
  renderProjectHealth(payload);
}

function dashboardRunCards(data) {
  const container = document.getElementById('dashboard-runs');
  if (!container) return;
  const extraction = data?.latest?.extraction_run || null;
  const verification = data?.latest?.verification_run || null;
  const cards = [];
  if (extraction) {
    cards.push(
      `<article class="issue-item issue-info"><strong>Extraction</strong>run ${dbEscapeHtml(extraction.id)} (${dbEscapeHtml(extraction.status || 'unknown')}) at ${dbEscapeHtml(extraction.created_at || 'n/a')}</article>`
    );
  }
  if (verification) {
    const counts = verification.result_status_counts || {};
    const statusSummary = Object.keys(counts).sort().map((k) => `${k}=${counts[k]}`).join(', ') || 'no results';
    cards.push(
      `<article class="issue-item issue-info"><strong>Verification</strong>run ${dbEscapeHtml(verification.id)} (${dbEscapeHtml(verification.policy_profile || 'n/a')}) at ${dbEscapeHtml(verification.created_at || 'n/a')} | ${dbEscapeHtml(statusSummary)}</article>`
    );
  }
  if (!cards.length) {
    container.innerHTML = '<p class="small">No recent extraction or verification runs found.</p>';
    return;
  }
  container.innerHTML = cards.join('');
}

function dashboardStorageCards(data) {
  const container = document.getElementById('dashboard-storage');
  if (!container) return;
  const project = (data && typeof data === 'object' && data.project && typeof data.project === 'object')
    ? data.project
    : {};
  const storage = (project.storage && typeof project.storage === 'object') ? project.storage : {};
  const segments = [
    { key: 'db_main', label: 'SQLite DB', path: storage.db_main_path || project.db_path, bytes: Number(storage.db_main_bytes || 0), color: '#2563eb' },
    { key: 'db_wal', label: 'WAL', path: storage.db_wal_path || `${project.db_path || ''}-wal`, bytes: Number(storage.db_wal_bytes || 0), color: '#14b8a6' },
    { key: 'db_shm', label: 'SHM', path: storage.db_shm_path || `${project.db_path || ''}-shm`, bytes: Number(storage.db_shm_bytes || 0), color: '#f59e0b' },
    { key: 'archive', label: 'Archive Store', path: storage.archive_dir || project.archive_dir, bytes: Number(storage.archive_bytes || 0), color: '#a855f7' },
    { key: 'vector', label: 'Vector Store', path: storage.qdrant_dir || project.qdrant_dir, bytes: Number(storage.qdrant_bytes || 0), color: '#ef4444' },
  ];
  if (!segments.some((row) => String(row.path || '').trim())) {
    container.innerHTML = '<p class="small">Storage summary not available.</p>';
    return;
  }
  const totalBytes = segments.reduce((sum, seg) => sum + (Number.isFinite(seg.bytes) && seg.bytes > 0 ? seg.bytes : 0), 0);
  let arcCursor = 0;
  const gradientParts = [];
  segments.forEach((segment) => {
    const value = Number.isFinite(segment.bytes) && segment.bytes > 0 ? segment.bytes : 0;
    if (value <= 0 || totalBytes <= 0) return;
    const angle = (value / totalBytes) * 360;
    const start = arcCursor;
    const end = arcCursor + angle;
    gradientParts.push(`${segment.color} ${start.toFixed(3)}deg ${end.toFixed(3)}deg`);
    arcCursor = end;
  });
  if (arcCursor < 360) {
    gradientParts.push(`color-mix(in srgb, var(--border) 44%, transparent) ${arcCursor.toFixed(3)}deg 360deg`);
  }
  const donutBackground = gradientParts.length
    ? `conic-gradient(${gradientParts.join(', ')})`
    : 'conic-gradient(color-mix(in srgb, var(--border) 44%, transparent) 0deg 360deg)';

  const legendHtml = segments
    .map((segment) => `
      <li class="storage-legend-item">
        <span class="storage-legend-main">
          <span class="storage-swatch" style="background:${segment.color};"></span>
          <span class="storage-legend-name">${dbEscapeHtml(segment.label)}</span>
        </span>
        <span class="storage-legend-size">${dbEscapeHtml(importFileSizeText(segment.bytes || 0))}</span>
      </li>
    `)
    .join('');

  const deviceAnchor = String(storage.device_anchor_path || project.db_path || project.root || 'n/a');
  const deviceTotal = Number(storage.device_total_bytes || 0);
  const deviceUsed = Number(storage.device_used_bytes || 0);
  const deviceFree = Number(storage.device_free_bytes || 0);
  const safeTotal = Number.isFinite(deviceTotal) && deviceTotal > 0 ? deviceTotal : 0;
  const usedPctRaw = safeTotal > 0 ? (Math.max(0, deviceUsed) / safeTotal) * 100 : 0;
  const usedPct = Math.max(0, Math.min(100, usedPctRaw));
  const freePct = Math.max(0, 100 - usedPct);
  const deviceMetaHtml = safeTotal > 0
    ? `${dbEscapeHtml(importFileSizeText(deviceUsed))} used  ${dbEscapeHtml(importFileSizeText(deviceFree))} free  ${dbEscapeHtml(importFileSizeText(deviceTotal))} total`
    : 'Device capacity unavailable.';

  const pathListHtml = segments
    .map((segment) => `
      <li class="storage-path-item">
        <strong>${dbEscapeHtml(segment.label)}</strong>
        <code>${dbEscapeHtml(String(segment.path || 'n/a'))}</code>
      </li>
    `)
    .join('');

  container.innerHTML = `
    <div class="dashboard-storage-layout">
      <section class="storage-column">
        <p class="storage-kicker">Storage Composition</p>
        <div class="storage-donut-wrap">
          <div class="storage-donut" style="background:${donutBackground};">
            <div class="storage-donut-center">
              <span class="storage-donut-label">Total</span>
              <span class="storage-donut-value">${dbEscapeHtml(importFileSizeText(totalBytes))}</span>
            </div>
          </div>
          <ul class="storage-legend">${legendHtml}</ul>
        </div>
      </section>
      <section class="storage-column">
        <p class="storage-kicker">Device Capacity</p>
        <div class="storage-device-block">
          <p class="storage-device-meta">Device anchor: <code>${dbEscapeHtml(deviceAnchor)}</code></p>
          <div class="storage-device-bar" aria-label="Device used and free space">
            <div class="storage-device-used" style="width:${usedPct.toFixed(2)}%"></div>
            <div class="storage-device-free" style="width:${freePct.toFixed(2)}%"></div>
          </div>
          <p class="storage-device-meta">${dbEscapeHtml(deviceMetaHtml)}</p>
          <ul class="storage-path-list">${pathListHtml}</ul>
        </div>
      </section>
    </div>
  `;
}

function renderDashboard(data, includeDoctor) {
  const statusEl = document.getElementById('dashboard-status');
  const kpiEl = document.getElementById('dashboard-kpis');
  if (!statusEl || !kpiEl) return;

  if (!data || data.ok !== true) {
    statusEl.textContent = 'Failed to load dashboard summary.';
    kpiEl.innerHTML = '';
    dashboardStorageCards(null);
    dashboardRunCards(null);
    return;
  }

  const counts = data.counts || {};
  const vector = data.vector || {};
  const health = data.health || null;
  const healthLabel = health
    ? (health.ok ? (health.warning_count > 0 ? 'WARNING' : 'OK') : 'ERROR')
    : 'NOT RUN';
  const healthTone = health
    ? (health.ok ? (health.warning_count > 0 ? 'warning' : 'ok') : 'error')
    : 'neutral';

  kpiEl.innerHTML = `
    ${metricCard('System Health', `<span class="status-pill ${statusClass(healthTone)}">${dbEscapeHtml(healthLabel)}</span>`, 'Doctor status snapshot.')}
    ${metricCard('Resources', dbEscapeHtml(String(counts.resources ?? 0)), 'Ingested source documents.')}
    ${metricCard('Claims', dbEscapeHtml(String(counts.claims ?? 0)), 'Claims available for verification.')}
    ${metricCard('Evidence Bindings', dbEscapeHtml(String(counts.claim_evidence_bindings ?? 0)), 'Claim-to-evidence links.')}
    ${metricCard('Extraction Runs', dbEscapeHtml(String(counts.extraction_runs ?? 0)), 'Total extraction runs in project history.')}
    ${metricCard('Verification Runs', dbEscapeHtml(String(counts.verification_runs ?? 0)), 'Total verification runs in project history.')}
    ${metricCard('Vector Backend', dbEscapeHtml(String(vector.backend || 'n/a')), 'Current vector backend mode.')}
    ${metricCard('Vector Points', dbEscapeHtml(String(vector.qdrant_points ?? 0)), 'Point count in vector database collection.')}
  `;

  statusEl.textContent = `Summary refreshed at ${data.generated_at || 'n/a'}${includeDoctor ? ' (doctor included).' : '.'}`;
  dashboardStorageCards(data);
  dashboardRunCards(data);

  if (health) {
    renderProjectHealth(health);
  }
}

async function loadDashboard(includeDoctor = false) {
  const query = includeDoctor ? '?include_doctor=true' : '';
  const payload = await callApi('GET', `/api/dashboard/summary${query}`, null, 'out-dashboard');
  renderDashboard(payload, includeDoctor);
}

function vectorTargetPayload() {
  const resourceId = (document.getElementById('vector-resource-id').value || '').trim();
  const resourceDigest = (document.getElementById('vector-resource-digest').value || '').trim();
  const extractionRunId = (document.getElementById('vector-extraction-run-id').value || '').trim();
  return {
    resourceId,
    resourceDigest,
    extractionRunId,
  };
}

function vectorStatusQuery() {
  const target = vectorTargetPayload();
  const limitRaw = document.getElementById('vector-status-limit').value || '25';
  const limit = Math.max(1, toSafeInt(limitRaw, 25));
  const params = new URLSearchParams();
  params.set('limit_runs', String(limit));
  if (target.resourceId) {
    params.set('resource_id', target.resourceId);
  } else if (target.resourceDigest) {
    params.set('resource_digest', target.resourceDigest);
  }
  return params.toString();
}

function renderVectorStatus(payload) {
  const note = document.getElementById('vector-status-note');
  const summary = document.getElementById('vector-summary');
  const runs = document.getElementById('vector-runs');
  if (!note || !summary || !runs) return;

  if (!payload || payload.ok !== true) {
    note.textContent = 'Vector status request failed.';
    summary.innerHTML = '';
    runs.innerHTML = '<p class="small">No vector status available.</p>';
    return;
  }

  const runList = Array.isArray(payload.runs) ? payload.runs : [];
  const successCount = runList.filter((r) => r.status === 'success').length;
  const failedCount = runList.filter((r) => r.status === 'failed').length;
  const runningCount = runList.filter((r) => r.status === 'running').length;
  const skippedCount = runList.filter((r) => r.status === 'skipped').length;

  summary.innerHTML = `
    ${metricCard('Backend', dbEscapeHtml(String(payload.backend || 'n/a')), 'Vector backend currently in use.')}
    ${metricCard('Collection', dbEscapeHtml(String(payload.collection_name || 'n/a')), 'Qdrant collection name.')}
    ${metricCard('Embedding Model', dbEscapeHtml(String(payload.embedding_model || 'n/a')), 'Embedding model used for indexing and querying.')}
    ${metricCard('Chunk Rows', dbEscapeHtml(String(payload.vector_chunk_rows ?? 0)), 'Rows in SQLite vector_chunks table.')}
    ${metricCard('Distinct Chunks', dbEscapeHtml(String(payload.distinct_chunk_ids ?? 0)), 'Distinct chunk identifiers indexed in SQLite.')}
    ${metricCard('Vector Points', dbEscapeHtml(String(payload.qdrant_points ?? 0)), 'Point count in vector database.')}
    ${metricCard('Run Success', dbEscapeHtml(String(successCount)), 'Recent successful vector index runs.')}
    ${metricCard('Run Failures', dbEscapeHtml(String(failedCount)), 'Recent failed vector index runs.')}
    ${metricCard('Run Running', dbEscapeHtml(String(runningCount)), 'Recent in-progress vector index runs.')}
    ${metricCard('Run Skipped', dbEscapeHtml(String(skippedCount)), 'Recent skipped vector index runs.')}
  `;
  note.textContent = `Loaded ${runList.length} recent vector run(s).`;

  if (!runList.length) {
    runs.innerHTML = '<p class="small">No vector runs found.</p>';
    return;
  }
  runs.innerHTML = runList
    .map((run) => {
      const tone = run.status === 'success' ? 'ok' : (run.status === 'failed' ? 'error' : (run.status === 'running' ? 'warning' : 'neutral'));
      const err = run.error_message ? `\nerror: ${run.error_message}` : '';
      return `
        <article class="vector-card">
          <h4><span class="status-pill ${statusClass(tone)}">${dbEscapeHtml(titleCase(String(run.status || 'unknown')))}</span> ${dbEscapeHtml(run.id || '')}</h4>
          <p>resource: ${dbEscapeHtml(run.resource_id || 'n/a')}
extraction_run: ${dbEscapeHtml(run.extraction_run_id || 'n/a')}
chunks: ${dbEscapeHtml(String(run.chunks_indexed ?? 0))}/${dbEscapeHtml(String(run.chunks_total ?? 0))}
created: ${dbEscapeHtml(run.created_at || 'n/a')}
finished: ${dbEscapeHtml(run.finished_at || 'n/a')}${dbEscapeHtml(err)}</p>
        </article>
      `;
    })
    .join('');
}

function renderVectorSearch(payload) {
  const container = document.getElementById('vector-search-results');
  if (!container) return;
  if (!payload || payload.ok !== true) {
    container.innerHTML = '<p class="small">Vector search request failed.</p>';
    return;
  }
  const hits = Array.isArray(payload.hits) ? payload.hits : [];
  if (!hits.length) {
    container.innerHTML = '<p class="small">No semantic matches found.</p>';
    return;
  }
  container.innerHTML = hits
    .map((hit, idx) => `
      <article class="vector-card">
        <h4>#${idx + 1} score=${dbEscapeHtml(String(hit.score ?? 'n/a'))}</h4>
        <p>chunk_id: ${dbEscapeHtml(hit.chunk_id || 'n/a')}
resource_id: ${dbEscapeHtml(hit.resource_id || 'n/a')}
extraction_run_id: ${dbEscapeHtml(hit.extraction_run_id || 'n/a')}
source: ${dbEscapeHtml(hit.source_type || 'n/a')} ${dbEscapeHtml(hit.source_ref || '')}
page: ${dbEscapeHtml(String(hit.page_index ?? 'n/a'))}
offsets: ${dbEscapeHtml(String(hit.start_offset ?? 'n/a'))}-${dbEscapeHtml(String(hit.end_offset ?? 'n/a'))}</p>
        <p>${dbEscapeHtml(String(hit.text_content || ''))}</p>
      </article>
    `)
    .join('');
}

async function vectorStatus() {
  const payload = await callApi('GET', `/api/vector/status?${vectorStatusQuery()}`, null, 'out-vector');
  renderVectorStatus(payload);
}

async function vectorIndex() {
  const target = vectorTargetPayload();
  if (!target.resourceId && !target.resourceDigest) {
    document.getElementById('out-vector').textContent = JSON.stringify(
      { error: 'Provide resource ID or resource digest.' },
      null,
      2
    );
    return;
  }
  const payload = await callApi(
    'POST',
    '/api/vector/index',
    {
      resource_id: target.resourceId || null,
      resource_digest: target.resourceDigest || null,
      extraction_run_id: target.extractionRunId || null,
      force: document.getElementById('vector-force').value === 'true',
    },
    'out-vector'
  );
  document.getElementById('vector-status-note').textContent = payload.ok
    ? 'Vector index request completed. Refreshing status...'
    : 'Vector index request failed.';
  await vectorStatus();
}

async function vectorBackfill() {
  const limitResources = Math.max(1, toSafeInt(document.getElementById('vector-backfill-limit-resources').value, 100000));
  const maxProcessRaw = (document.getElementById('vector-backfill-max-process').value || '').trim();
  const maxProcess = maxProcessRaw ? Math.max(1, toSafeInt(maxProcessRaw, 1)) : null;
  const payload = await callApi(
    'POST',
    '/api/vector/backfill',
    {
      limit_resources: limitResources,
      max_process: maxProcess,
    },
    'out-vector'
  );
  document.getElementById('vector-status-note').textContent = payload.ok
    ? 'Backfill request completed. Refreshing status...'
    : 'Backfill request failed.';
  await vectorStatus();
}

async function vectorSearch() {
  const target = vectorTargetPayload();
  const query = (document.getElementById('vector-query').value || '').trim();
  const limit = Math.max(1, toSafeInt(document.getElementById('vector-query-limit').value, 10));
  if (!query) {
    document.getElementById('out-vector').textContent = JSON.stringify(
      { error: 'Provide a semantic query string.' },
      null,
      2
    );
    return;
  }
  const payload = await callApi(
    'POST',
    '/api/vector/search',
    {
      query,
      limit,
      resource_id: target.resourceId || null,
      resource_digest: target.resourceDigest || null,
      extraction_run_id: target.extractionRunId || null,
    },
    'out-vector'
  );
  renderVectorSearch(payload);
}

let dbTables = [];
let dbLastPayload = null;
let dbGridSource = null;
let dbGridState = {
  sortColumn: null,
  sortDirection: 'asc',
  globalSearch: '',
  columnFilters: {},
};

function currentDbTable() {
  return document.getElementById('db-table-select').value;
}

function dbOutputMode() {
  const select = document.getElementById('db-view-mode');
  return select ? select.value : 'spreadsheet';
}

function renderDbResult(payload) {
  dbLastPayload = payload;
  document.getElementById('out-db').textContent = JSON.stringify(payload, null, 2);
}

function dbEscapeHtml(value) {
  return String(value)
    .replaceAll('&', '&amp;')
    .replaceAll('<', '&lt;')
    .replaceAll('>', '&gt;')
    .replaceAll('"', '&quot;')
    .replaceAll("'", '&#39;');
}

function dbCellText(value) {
  if (value === null || value === undefined) return '';
  if (typeof value === 'object') return JSON.stringify(value);
  return String(value);
}

function dbMaybeNumber(value) {
  if (typeof value === 'number' && Number.isFinite(value)) return value;
  if (typeof value !== 'string') return null;
  const trimmed = value.trim();
  if (!trimmed) return null;
  if (!/^[+-]?\d+(\.\d+)?$/.test(trimmed)) return null;
  const num = Number(trimmed);
  return Number.isFinite(num) ? num : null;
}

function dbResetGridState() {
  dbGridState.sortColumn = null;
  dbGridState.sortDirection = 'asc';
  dbGridState.globalSearch = '';
  dbGridState.columnFilters = {};
  const search = document.getElementById('db-search');
  if (search) search.value = '';
}

function dbSetGridSource(source) {
  dbGridSource = source;
  dbResetGridState();
  if (dbOutputMode() === 'spreadsheet') dbRenderGrid();
}

function dbSetGridMessage(message) {
  const meta = document.getElementById('db-grid-meta');
  const table = document.getElementById('db-grid-table');
  if (meta) meta.textContent = message;
  if (table) table.innerHTML = '';
}

function dbFilteredSortedRows() {
  if (!dbGridSource) return [];
  const columns = dbGridSource.columns;
  const global = (dbGridState.globalSearch || '').trim().toLowerCase();
  let rows = dbGridSource.rows.filter((row) => {
    if (global) {
      const hasGlobal = columns.some((col) => dbCellText(row[col]).toLowerCase().includes(global));
      if (!hasGlobal) return false;
    }
    for (const col of columns) {
      const filter = (dbGridState.columnFilters[col] || '').trim().toLowerCase();
      if (!filter) continue;
      if (!dbCellText(row[col]).toLowerCase().includes(filter)) return false;
    }
    return true;
  });

  const sortCol = dbGridState.sortColumn;
  if (!sortCol) return rows;
  const direction = dbGridState.sortDirection === 'desc' ? -1 : 1;
  rows = [...rows].sort((a, b) => {
    const av = a[sortCol];
    const bv = b[sortCol];
    if (av === bv) return 0;
    if (av === null || av === undefined) return 1 * direction;
    if (bv === null || bv === undefined) return -1 * direction;

    const an = dbMaybeNumber(av);
    const bn = dbMaybeNumber(bv);
    if (an !== null && bn !== null) return (an - bn) * direction;

    const as = dbCellText(av);
    const bs = dbCellText(bv);
    return as.localeCompare(bs, undefined, { numeric: true, sensitivity: 'base' }) * direction;
  });
  return rows;
}

function dbRenderGrid() {
  if (!dbGridSource || !Array.isArray(dbGridSource.columns) || !dbGridSource.columns.length) {
    dbSetGridMessage('No tabular data loaded yet.');
    return;
  }
  const columns = dbGridSource.columns;
  const visibleRows = dbFilteredSortedRows();
  const meta = document.getElementById('db-grid-meta');
  if (meta) {
    const loaded = dbGridSource.rows.length;
    const total = dbGridSource.totalRows ?? loaded;
    const offset = dbGridSource.offset ?? 0;
    const limit = dbGridSource.limit ?? loaded;
    const scope = dbGridSource.title || 'Current view';
    meta.textContent = `${scope}: ${visibleRows.length} matching rows (loaded ${loaded}, table total ${total}, offset ${offset}, limit ${limit}).`;
  }

  const table = document.getElementById('db-grid-table');
  const header = columns
    .map((col, idx) => {
      const active = dbGridState.sortColumn === col;
      const arrow = active ? (dbGridState.sortDirection === 'asc' ? ' ' : ' ') : '';
      return `<th><button class="db-sort-btn" type="button" data-col-idx="${idx}">${dbEscapeHtml(col)}${arrow}</button></th>`;
    })
    .join('');
  const filters = columns
    .map((col, idx) => {
      const value = dbGridState.columnFilters[col] || '';
      return `<th><input class="db-filter-input" data-col-idx="${idx}" value="${dbEscapeHtml(value)}" placeholder="Filter" /></th>`;
    })
    .join('');
  const body = visibleRows.length
    ? visibleRows
        .map((row) => {
          const cells = columns.map((col) => `<td class="db-cell">${dbEscapeHtml(dbCellText(row[col]))}</td>`).join('');
          return `<tr>${cells}</tr>`;
        })
        .join('')
    : `<tr><td class="small" colspan="${columns.length}">No rows match current filters.</td></tr>`;

  table.innerHTML = `<thead><tr>${header}</tr><tr class="db-filter-row">${filters}</tr></thead><tbody>${body}</tbody>`;

  table.querySelectorAll('.db-sort-btn').forEach((button) => {
    button.addEventListener('click', () => {
      const idx = Number(button.getAttribute('data-col-idx'));
      const col = columns[idx];
      if (!col) return;
      if (dbGridState.sortColumn === col) {
        dbGridState.sortDirection = dbGridState.sortDirection === 'asc' ? 'desc' : 'asc';
      } else {
        dbGridState.sortColumn = col;
        dbGridState.sortDirection = 'asc';
      }
      dbRenderGrid();
    });
  });
  table.querySelectorAll('.db-filter-input').forEach((input) => {
    input.addEventListener('input', () => {
      const idx = Number(input.getAttribute('data-col-idx'));
      const col = columns[idx];
      if (!col) return;
      dbGridState.columnFilters[col] = input.value || '';
      dbRenderGrid();
    });
  });
}

function dbSetViewMode(mode) {
  const allowed = new Set(['json', 'spreadsheet']);
  const selected = allowed.has(mode) ? mode : 'spreadsheet';
  const modeSelect = document.getElementById('db-view-mode');
  if (modeSelect && modeSelect.value !== selected) modeSelect.value = selected;
  localStorage.setItem('stemmaDbViewMode', selected);

  const pre = document.getElementById('out-db');
  const grid = document.getElementById('db-grid-view');
  const search = document.getElementById('db-search');
  const clear = document.getElementById('db-clear-filters');
  if (selected === 'spreadsheet') {
    if (grid) grid.classList.add('open');
    if (pre) pre.style.display = 'none';
    if (search) search.disabled = false;
    if (clear) clear.disabled = false;
    dbRenderGrid();
  } else {
    if (grid) grid.classList.remove('open');
    if (pre) pre.style.display = '';
    if (search) search.disabled = true;
    if (clear) clear.disabled = true;
    if (dbLastPayload) renderDbResult(dbLastPayload);
  }
}

function initDbExplorer() {
  const search = document.getElementById('db-search');
  if (search) {
    search.addEventListener('input', () => {
      dbGridState.globalSearch = search.value || '';
      if (dbOutputMode() === 'spreadsheet') dbRenderGrid();
    });
  }

  const savedMode = localStorage.getItem('stemmaDbViewMode');
  const modeSelect = document.getElementById('db-view-mode');
  if (modeSelect && (savedMode === 'json' || savedMode === 'spreadsheet')) {
    modeSelect.value = savedMode;
  }
  dbSetViewMode(modeSelect ? modeSelect.value : 'spreadsheet');
}

function dbClearFilters() {
  dbResetGridState();
  if (dbOutputMode() === 'spreadsheet') dbRenderGrid();
}

function refreshDbSelect() {
  const select = document.getElementById('db-table-select');
  const current = select.value;
  select.innerHTML = '';
  const placeholder = document.createElement('option');
  placeholder.value = '';
  placeholder.textContent = 'Select table';
  select.appendChild(placeholder);
  dbTables.forEach((t) => {
    const opt = document.createElement('option');
    opt.value = t.name;
    opt.textContent = `${t.name} (${t.row_count} rows)`;
    select.appendChild(opt);
  });
  if (current && dbTables.some((t) => t.name === current)) {
    select.value = current;
  }
}

async function dbListTables() {
  const data = await callApi('GET', '/api/db/tables', null, null);
  if (data && data.detail === 'Not Found') {
    const payload = {
      ok: false,
      error: 'Database Explorer API endpoint was not found on this server instance.',
      hint: 'Restart the web server from the current workspace so /api/db/tables is registered.',
      attempted_urls: data.attempted_urls || [],
    };
    renderDbResult(payload);
    dbSetGridMessage(payload.error);
    return;
  }

  dbTables = Array.isArray(data.tables) ? data.tables : [];
  refreshDbSelect();

  renderDbResult(data);
  dbSetGridSource({
    title: 'Table list',
    table: null,
    columns: ['name', 'row_count', 'column_count'],
    rows: dbTables.map((t) => ({
      name: t.name,
      row_count: t.row_count,
      column_count: Array.isArray(t.columns) ? t.columns.length : 0,
    })),
    totalRows: dbTables.length,
    offset: 0,
    limit: dbTables.length,
  });
}

async function dbViewTable() {
  const name = currentDbTable();
  if (!name) {
    const payload = { error: 'Select a table first.' };
    renderDbResult(payload);
    dbSetGridMessage(payload.error);
    return;
  }
  const limit = Number(document.getElementById('db-limit').value || '50');
  const offset = Number(document.getElementById('db-offset').value || '0');
  const safeLimit = Number.isFinite(limit) && limit > 0 ? Math.floor(limit) : 50;
  const safeOffset = Number.isFinite(offset) && offset >= 0 ? Math.floor(offset) : 0;
  const data = await callApi(
    'GET',
    `/api/db/table?name=${encodeURIComponent(name)}&limit=${safeLimit}&offset=${safeOffset}`,
    null,
    null
  );
  renderDbResult(data);
  if (!data || data.ok !== true || !Array.isArray(data.rows)) {
    dbSetGridMessage(data?.detail || data?.error || 'Unable to load table rows.');
    return;
  }
  dbSetGridSource({
    title: `Table: ${name}`,
    table: name,
    columns: Array.isArray(data.columns) ? data.columns : [],
    rows: data.rows,
    totalRows: Number.isFinite(data.total_rows) ? data.total_rows : data.rows.length,
    offset: safeOffset,
    limit: safeLimit,
  });
}

function dbDescribeTable() {
  const name = currentDbTable();
  if (!name) {
    const payload = { error: 'Select a table first.' };
    renderDbResult(payload);
    dbSetGridMessage(payload.error);
    return;
  }
  const match = dbTables.find((t) => t.name === name);
  if (!match) {
    const payload = { error: 'Table metadata not loaded. Click "List Tables" first.' };
    renderDbResult(payload);
    dbSetGridMessage(payload.error);
    return;
  }
  const payload = {
    ok: true,
    table: name,
    row_count: match.row_count,
    columns: match.columns,
    create_sql: match.create_sql,
  };
  renderDbResult(payload);
  dbSetGridSource({
    title: `Schema: ${name}`,
    table: name,
    columns: ['name', 'type', 'notnull', 'pk'],
    rows: Array.isArray(match.columns)
      ? match.columns.map((c) => ({
          name: c.name,
          type: c.type,
          notnull: c.notnull,
          pk: c.pk,
        }))
      : [],
    totalRows: Array.isArray(match.columns) ? match.columns.length : 0,
    offset: 0,
    limit: Array.isArray(match.columns) ? match.columns.length : 0,
  });
}

const VIEWER_PDFJS_SRC = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js';
const VIEWER_PDFJS_WORKER_SRC = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

const viewerState = {
  resources: [],
  payload: null,
  resourceId: '',
  selectedTableId: '',
  selectedCellRow: null,
  selectedCellCol: null,
  contentKind: 'binary',
  page: 1,
  pageCount: 1,
  zoom: 1,
  minZoom: 0.5,
  maxZoom: 3.2,
  pdfDoc: null,
  pdfJsPromise: null,
  pdfLoadToken: 0,
  renderToken: 0,
  pageBaseWidth: 0,
  pageBaseHeight: 0,
  panEnabled: false,
  panDragging: false,
  panStartX: 0,
  panStartY: 0,
  panScrollLeft: 0,
  panScrollTop: 0,
};

function viewerSetStatus(message) {
  const el = document.getElementById('viewer-status');
  if (el) el.textContent = String(message || '');
}

function viewerUpdatePageZoomLabels() {
  const page = document.getElementById('viewer-page-label');
  if (page) page.textContent = `Page ${viewerState.page} / ${viewerState.pageCount}`;
  const zoom = document.getElementById('viewer-zoom-label');
  if (zoom) zoom.textContent = `${Math.round(viewerState.zoom * 100)}%`;
}

function viewerTryParseJson(value, fallback = null) {
  if (value === null || value === undefined) return fallback;
  if (typeof value === 'object') return value;
  if (typeof value !== 'string') return fallback;
  try {
    return JSON.parse(value);
  } catch {
    return fallback;
  }
}

function viewerListLabel(resource) {
  if (!resource || typeof resource !== 'object') return 'unknown';
  const file = String(resource.original_filename || 'document');
  const media = String(resource.media_type || 'unknown');
  const idShort = String(resource.id || '').slice(0, 8);
  return `${file} (${media})  ${idShort}`;
}

function viewerPopulateResourceSelect(selectedResourceId = '') {
  const select = document.getElementById('viewer-resource-select');
  if (!select) return;
  const current = selectedResourceId || select.value || viewerState.resourceId || '';
  select.innerHTML = '';
  const placeholder = document.createElement('option');
  placeholder.value = '';
  placeholder.textContent = 'Select resource';
  select.appendChild(placeholder);
  viewerState.resources.forEach((resource) => {
    const opt = document.createElement('option');
    opt.value = resource.id;
    opt.textContent = viewerListLabel(resource);
    select.appendChild(opt);
  });
  if (current && viewerState.resources.some((r) => r.id === current)) {
    select.value = current;
  }
}

async function viewerRefreshResources() {
  const payload = await callApi('GET', '/api/resources?limit=500', null, null);
  viewerState.resources = Array.isArray(payload?.resources) ? payload.resources : [];
  viewerPopulateResourceSelect();
}

function viewerSetActiveResource(resourceId) {
  viewerState.resourceId = resourceId || '';
  const select = document.getElementById('viewer-resource-select');
  if (select && viewerState.resourceId && viewerState.resources.some((r) => r.id === viewerState.resourceId)) {
    select.value = viewerState.resourceId;
  }
  const input = document.getElementById('viewer-resource-id');
  if (input) input.value = viewerState.resourceId || '';
}

function viewerCurrentTable() {
  if (!viewerState.payload || !Array.isArray(viewerState.payload.tables)) return null;
  return viewerState.payload.tables.find((t) => t.id === viewerState.selectedTableId) || null;
}

function viewerOverlayToggleValue(id, fallback = true) {
  const el = document.getElementById(id);
  if (!el) return fallback;
  return Boolean(el.checked);
}

function viewerToPageIndex(value) {
  if (value === null || value === undefined || value === '') return null;
  const n = Number(value);
  if (!Number.isFinite(n) || n < 0) return null;
  return Math.floor(n);
}

function viewerResetStage() {
  viewerState.pdfDoc = null;
  viewerState.page = 1;
  viewerState.pageCount = 1;
  viewerState.pageBaseWidth = 0;
  viewerState.pageBaseHeight = 0;
  viewerUpdatePageZoomLabels();
  const canvas = document.getElementById('viewer-pdf-canvas');
  const overlay = document.getElementById('viewer-overlay-canvas');
  if (canvas) {
    canvas.style.display = 'none';
    canvas.width = 0;
    canvas.height = 0;
  }
  if (overlay) {
    overlay.style.display = 'none';
    overlay.width = 0;
    overlay.height = 0;
  }
}

function viewerShowFallback(html) {
  const fallback = document.getElementById('viewer-fallback');
  if (fallback) fallback.innerHTML = html;
  const canvas = document.getElementById('viewer-pdf-canvas');
  const overlay = document.getElementById('viewer-overlay-canvas');
  if (canvas) canvas.style.display = 'none';
  if (overlay) overlay.style.display = 'none';
}

function viewerEscapeAttr(value) {
  return dbEscapeHtml(String(value || ''));
}

function viewerRenderMetadata() {
  const container = document.getElementById('viewer-metadata');
  if (!container) return;
  const payload = viewerState.payload;
  if (!payload || !payload.metadata) {
    container.innerHTML = '<p class="small">No resource loaded.</p>';
    return;
  }
  const meta = payload.metadata;
  const extraction = payload.extraction || {};
  const counts = extraction.counts || {};
  const pagesGeom = Array.isArray(extraction.pages_with_geometry) ? extraction.pages_with_geometry : [];
  const pagesTables = Array.isArray(extraction.pages_with_tables) ? extraction.pages_with_tables : [];
  const overlays = extraction.overlay_ready ? 'ready' : 'limited';
  container.innerHTML = `
    ${metricCard('Resource ID', viewerEscapeAttr(meta.resource_id))}
    ${metricCard('Media Type', viewerEscapeAttr(meta.media_type))}
    ${metricCard('Digest', viewerEscapeAttr(String(meta.digest_sha256 || '').slice(0, 16) + '...'))}
    ${metricCard('Source URI', viewerEscapeAttr(meta.source_uri || 'n/a'))}
    ${metricCard('Tables', viewerEscapeAttr(counts.tables ?? 0))}
    ${metricCard('Segments', viewerEscapeAttr(counts.segments ?? 0))}
    ${metricCard('Annotations', viewerEscapeAttr(counts.annotations ?? 0))}
    ${metricCard('Overlay Geometry', viewerEscapeAttr(overlays))}
    ${metricCard('Pages (Tables)', viewerEscapeAttr(pagesTables.length || 0))}
    ${metricCard('Pages (BBox)', viewerEscapeAttr(pagesGeom.length || 0))}
  `;
}

function viewerRenderAnnotations() {
  const container = document.getElementById('viewer-annotation-list');
  if (!container) return;
  const payload = viewerState.payload;
  const annotations = Array.isArray(payload?.annotations) ? payload.annotations : [];
  if (!annotations.length) {
    container.innerHTML = '<p class="small">No annotations available.</p>';
    return;
  }
  const shown = annotations.slice(0, 220);
  container.innerHTML = shown.map((annotation) => {
    const spans = Array.isArray(annotation.spans) ? annotation.spans : [];
    const spanText = spans.length
      ? spans.slice(0, 3).map((s) => `${s.start}-${s.end}`).join(', ')
      : 'no spans';
    return `
      <article class="viewer-annotation-item">
        <h4>${dbEscapeHtml(String(annotation.category || 'annotation'))} <span class="small">(${dbEscapeHtml(String(annotation.layer || 'layer'))})</span></h4>
        <p>${dbEscapeHtml(String(annotation.label || annotation.source || ''))}</p>
        <p>${dbEscapeHtml(String(annotation.snippet || ''))}</p>
        <p>spans: ${dbEscapeHtml(spanText)}</p>
      </article>
    `;
  }).join('');
}

function viewerTableShape(table) {
  const cells = Array.isArray(table?.cells) ? table.cells : [];
  let rows = Array.isArray(table?.row_headers) ? table.row_headers.length : 0;
  let cols = Array.isArray(table?.col_headers) ? table.col_headers.length : 0;
  cells.forEach((cell) => {
    const r = Number(cell?.row_index);
    const c = Number(cell?.col_index);
    if (Number.isFinite(r)) rows = Math.max(rows, Math.floor(r) + 1);
    if (Number.isFinite(c)) cols = Math.max(cols, Math.floor(c) + 1);
  });
  rows = Math.max(0, rows);
  cols = Math.max(0, cols);
  return { rows, cols };
}

function viewerEstimateCellBox(table, rowIndex, colIndex) {
  const bbox = viewerExtractBBox(table?.bbox);
  if (!bbox) return null;
  const shape = viewerTableShape(table);
  if (shape.rows <= 0 || shape.cols <= 0) return null;
  const row = Math.max(0, Math.min(shape.rows - 1, Number(rowIndex)));
  const col = Math.max(0, Math.min(shape.cols - 1, Number(colIndex)));
  const width = (bbox.x1 - bbox.x0) / shape.cols;
  const height = (bbox.y1 - bbox.y0) / shape.rows;
  return {
    x0: bbox.x0 + (col * width),
    y0: bbox.y0 + (row * height),
    x1: bbox.x0 + ((col + 1) * width),
    y1: bbox.y0 + ((row + 1) * height),
  };
}

function viewerRenderTableGrid() {
  const container = document.getElementById('viewer-table-grid');
  if (!container) return;
  const table = viewerCurrentTable();
  if (!table) {
    container.innerHTML = '<p class="small">No table selected.</p>';
    return;
  }

  const { rows, cols } = viewerTableShape(table);
  const cellMap = new Map();
  (Array.isArray(table.cells) ? table.cells : []).forEach((cell) => {
    const r = Number(cell?.row_index);
    const c = Number(cell?.col_index);
    if (!Number.isFinite(r) || !Number.isFinite(c)) return;
    cellMap.set(`${Math.floor(r)}:${Math.floor(c)}`, String(cell?.value || ''));
  });

  const activeRow = Number.isFinite(viewerState.selectedCellRow) ? viewerState.selectedCellRow : null;
  const activeCol = Number.isFinite(viewerState.selectedCellCol) ? viewerState.selectedCellCol : null;
  const rowHeaders = Array.isArray(table.row_headers) ? table.row_headers : [];
  const colHeaders = Array.isArray(table.col_headers) ? table.col_headers : [];

  let headerHtml = '<th>#</th>';
  for (let c = 0; c < cols; c += 1) {
    const label = colHeaders[c] || `C${c + 1}`;
    headerHtml += `<th>${dbEscapeHtml(label)}</th>`;
  }

  let bodyHtml = '';
  for (let r = 0; r < rows; r += 1) {
    let row = `<tr><th>${dbEscapeHtml(rowHeaders[r] || `R${r + 1}`)}</th>`;
    for (let c = 0; c < cols; c += 1) {
      const key = `${r}:${c}`;
      const value = cellMap.get(key) || '';
      const activeClass = activeRow === r && activeCol === c ? 'viewer-cell-active' : '';
      row += `<td class="${activeClass}">${dbEscapeHtml(value)}</td>`;
    }
    row += '</tr>';
    bodyHtml += row;
  }

  container.innerHTML = `
    <table class="viewer-table">
      <thead><tr>${headerHtml}</tr></thead>
      <tbody>${bodyHtml || '<tr><td colspan="99">No cells extracted.</td></tr>'}</tbody>
    </table>
  `;
}

function viewerFocusCell() {
  const table = viewerCurrentTable();
  if (!table) {
    const status = document.getElementById('viewer-cell-status');
    if (status) status.textContent = 'Select a table first.';
    return;
  }
  const rowInput = document.getElementById('viewer-cell-row');
  const colInput = document.getElementById('viewer-cell-col');
  const r = Number((rowInput?.value || '').trim());
  const c = Number((colInput?.value || '').trim());
  if (!Number.isFinite(r) || !Number.isFinite(c) || r < 1 || c < 1) {
    const status = document.getElementById('viewer-cell-status');
    if (status) status.textContent = 'Provide valid 1-based row and column numbers.';
    return;
  }
  viewerState.selectedCellRow = Math.floor(r) - 1;
  viewerState.selectedCellCol = Math.floor(c) - 1;
  viewerRenderTableGrid();
  const status = document.getElementById('viewer-cell-status');
  const { rows, cols } = viewerTableShape(table);
  const cell = (Array.isArray(table.cells) ? table.cells : []).find(
    (x) => Number(x?.row_index) === viewerState.selectedCellRow && Number(x?.col_index) === viewerState.selectedCellCol
  );
  const value = cell ? String(cell.value || '') : '(empty)';
  const approxBox = viewerEstimateCellBox(table, viewerState.selectedCellRow, viewerState.selectedCellCol);
  const coordText = approxBox
    ? `  bbox approx (${approxBox.x0.toFixed(2)}, ${approxBox.y0.toFixed(2)}, ${approxBox.x1.toFixed(2)}, ${approxBox.y1.toFixed(2)})`
    : '';
  const cellInfo = `Table ${table.table_id || table.id || ''}  page ${Number.isFinite(Number(table.page_number)) ? table.page_number : 'n/a'}  row ${viewerState.selectedCellRow + 1}/${rows || '?'}  col ${viewerState.selectedCellCol + 1}/${cols || '?'}  value: ${value}${coordText}`;
  if (status) status.textContent = cellInfo;
}

function viewerOpenOverlayTable(tableId) {
  viewerState.selectedTableId = tableId || '';
  const table = viewerCurrentTable();
  const pageIndex = viewerToPageIndex(table?.page_index);
  if (pageIndex !== null) {
    viewerState.page = Math.max(1, pageIndex + 1);
  }
  viewerRenderOverlayList();
  viewerRenderTableGrid();
  viewerRenderOverlay();
  viewerRenderCurrentPdfPage();
}

function viewerRenderOverlayList() {
  const container = document.getElementById('viewer-overlay-list');
  if (!container) return;
  const payload = viewerState.payload;
  const pageIndex = viewerState.page - 1;
  const tables = Array.isArray(payload?.tables) ? payload.tables : [];
  const segments = Array.isArray(payload?.segments) ? payload.segments : [];

  const tablesHere = tables.filter((table) => (
    table && (
      viewerToPageIndex(table.page_index) === null
      || viewerToPageIndex(table.page_index) === pageIndex
      || viewerState.contentKind !== 'pdf'
    )
  ));
  const segmentsHere = segments.filter((segment) => (
    segment && segment.bbox && (
      viewerToPageIndex(segment.page_index) === null
      || viewerToPageIndex(segment.page_index) === pageIndex
      || viewerState.contentKind !== 'pdf'
    )
  ));

  if (!tablesHere.length && !segmentsHere.length) {
    container.innerHTML = '<p class="small">No overlay objects for this page.</p>';
    return;
  }

  const tableHtml = tablesHere.slice(0, 200).map((table) => {
    const active = table.id === viewerState.selectedTableId ? 'active' : '';
    const bbox = table?.bbox ? 'bbox' : 'no bbox';
    const rows = Array.isArray(table.row_headers) ? table.row_headers.length : 0;
    const cols = Array.isArray(table.col_headers) ? table.col_headers.length : 0;
    return `
      <article class="viewer-overlay-item ${active}" data-viewer-table-id="${dbEscapeHtml(String(table.id || ''))}">
        <h4>Table ${dbEscapeHtml(String(table.page_number || 'n/a'))}  ${dbEscapeHtml(String(table.caption || table.table_id || 'table'))}</h4>
        <p>${dbEscapeHtml(rows)} rows  ${dbEscapeHtml(cols)} cols  ${dbEscapeHtml(bbox)}</p>
      </article>
    `;
  }).join('');

  const segmentHtml = segmentsHere.slice(0, 220).map((segment) => `
    <article class="viewer-overlay-item">
      <h4>${dbEscapeHtml(String(segment.segment_type || 'segment'))}</h4>
      <p>page ${dbEscapeHtml(String(segment.page_number || 'n/a'))}  ${dbEscapeHtml(String(segment.start_offset || 0))}-${dbEscapeHtml(String(segment.end_offset || 0))}</p>
    </article>
  `).join('');

  container.innerHTML = `${tableHtml}${segmentHtml}`;
  container.querySelectorAll('[data-viewer-table-id]').forEach((node) => {
    node.addEventListener('click', () => {
      viewerOpenOverlayTable(node.getAttribute('data-viewer-table-id') || '');
    });
  });
}

function viewerExtractBBox(bbox) {
  if (!bbox || typeof bbox !== 'object') return null;
  const obj = bbox;
  const pick = (...keys) => {
    for (const key of keys) {
      const value = obj[key];
      const n = Number(value);
      if (Number.isFinite(n)) return n;
    }
    return null;
  };
  let x0 = pick('x0', 'left', 'l', 'x_min', 'min_x', 'x');
  let y0 = pick('y0', 'top', 't', 'y_min', 'min_y', 'y');
  let x1 = pick('x1', 'right', 'r', 'x_max', 'max_x');
  let y1 = pick('y1', 'bottom', 'b', 'y_max', 'max_y');
  if ((x0 === null || y0 === null || x1 === null || y1 === null) && Array.isArray(obj.points) && obj.points.length >= 4) {
    const values = obj.points.map((v) => Number(v));
    if (values.every((v) => Number.isFinite(v))) {
      [x0, y0, x1, y1] = values;
    }
  }
  if (x0 === null || y0 === null || x1 === null || y1 === null) return null;
  if (x1 < x0) [x0, x1] = [x1, x0];
  if (y1 < y0) [y0, y1] = [y1, y0];
  return { x0, y0, x1, y1 };
}

function viewerRectForCanvas(bbox, canvasWidth, canvasHeight) {
  const b = viewerExtractBBox(bbox);
  if (!b) return null;
  const maxValue = Math.max(Math.abs(b.x0), Math.abs(b.y0), Math.abs(b.x1), Math.abs(b.y1));
  const isNormalized = maxValue <= 1.5;
  const baseW = viewerState.pageBaseWidth || canvasWidth || 1;
  const baseH = viewerState.pageBaseHeight || canvasHeight || 1;

  let x0 = b.x0;
  let y0 = b.y0;
  let x1 = b.x1;
  let y1 = b.y1;
  if (isNormalized) {
    x0 *= canvasWidth;
    x1 *= canvasWidth;
    y0 *= canvasHeight;
    y1 *= canvasHeight;
  } else {
    const scaleX = canvasWidth / baseW;
    const scaleY = canvasHeight / baseH;
    x0 *= scaleX;
    x1 *= scaleX;
    y0 *= scaleY;
    y1 *= scaleY;
  }
  const w = Math.max(1, x1 - x0);
  const h = Math.max(1, y1 - y0);
  return { x: x0, y: y0, w, h };
}

function viewerCollectAnnotationRects(pageIndex) {
  if (!viewerOverlayToggleValue('viewer-toggle-annotations', true)) return [];
  const payload = viewerState.payload;
  const annotations = Array.isArray(payload?.annotations) ? payload.annotations : [];
  const segments = Array.isArray(payload?.segments)
    ? payload.segments.filter((segment) => segment && segment.bbox && viewerToPageIndex(segment.page_index) === pageIndex)
    : [];
  if (!annotations.length || !segments.length) return [];
  const rects = [];
  const maxAnnotations = Math.min(350, annotations.length);
  for (let i = 0; i < maxAnnotations; i += 1) {
    const annotation = annotations[i];
    const spans = Array.isArray(annotation?.spans) ? annotation.spans : [];
    for (const span of spans) {
      const spanStart = Number(span?.start);
      const spanEnd = Number(span?.end);
      if (!Number.isFinite(spanStart) || !Number.isFinite(spanEnd)) continue;
      for (const segment of segments) {
        const segStart = Number(segment?.start_offset);
        const segEnd = Number(segment?.end_offset);
        if (!Number.isFinite(segStart) || !Number.isFinite(segEnd)) continue;
        if (segEnd <= spanStart || segStart >= spanEnd) continue;
        rects.push(segment.bbox);
      }
      if (rects.length > 800) return rects;
    }
  }
  return rects;
}

function viewerRenderOverlay() {
  const overlayCanvas = document.getElementById('viewer-overlay-canvas');
  const baseCanvas = document.getElementById('viewer-pdf-canvas');
  if (!overlayCanvas || !baseCanvas || viewerState.contentKind !== 'pdf' || !viewerState.pdfDoc) return;
  const ctx = overlayCanvas.getContext('2d');
  if (!ctx) return;
  ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

  const payload = viewerState.payload;
  const pageIndex = viewerState.page - 1;
  const showTables = viewerOverlayToggleValue('viewer-toggle-tables', true);
  const showSegments = viewerOverlayToggleValue('viewer-toggle-segments', true);

  if (showTables) {
    const tables = Array.isArray(payload?.tables) ? payload.tables : [];
    tables.forEach((table) => {
      if (!table || !table.bbox) return;
      if (viewerToPageIndex(table.page_index) !== null && viewerToPageIndex(table.page_index) !== pageIndex) return;
      const rect = viewerRectForCanvas(table.bbox, overlayCanvas.width, overlayCanvas.height);
      if (!rect) return;
      const selected = table.id === viewerState.selectedTableId;
      ctx.strokeStyle = selected ? '#0ea5e9' : '#22d3ee';
      ctx.lineWidth = selected ? 2.4 : 1.7;
      ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
      if (selected) {
        ctx.fillStyle = 'rgba(14,165,233,0.16)';
        ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
      }
    });
  }

  if (showSegments) {
    const segments = Array.isArray(payload?.segments) ? payload.segments : [];
    let drawn = 0;
    for (const segment of segments) {
      if (!segment || !segment.bbox) continue;
      if (viewerToPageIndex(segment.page_index) !== null && viewerToPageIndex(segment.page_index) !== pageIndex) continue;
      const rect = viewerRectForCanvas(segment.bbox, overlayCanvas.width, overlayCanvas.height);
      if (!rect) continue;
      ctx.strokeStyle = 'rgba(251,191,36,0.65)';
      ctx.lineWidth = 1.0;
      ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
      drawn += 1;
      if (drawn > 1000) break;
    }
  }

  const annotationRects = viewerCollectAnnotationRects(pageIndex);
  if (annotationRects.length) {
    ctx.strokeStyle = 'rgba(217,70,239,0.7)';
    ctx.lineWidth = 1.1;
    annotationRects.forEach((bbox) => {
      const rect = viewerRectForCanvas(bbox, overlayCanvas.width, overlayCanvas.height);
      if (!rect) return;
      ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
    });
  }
}

async function viewerEnsurePdfJs() {
  if (window.pdfjsLib) {
    window.pdfjsLib.GlobalWorkerOptions.workerSrc = VIEWER_PDFJS_WORKER_SRC;
    return window.pdfjsLib;
  }
  if (viewerState.pdfJsPromise) return viewerState.pdfJsPromise;
  viewerState.pdfJsPromise = new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = VIEWER_PDFJS_SRC;
    script.async = true;
    script.onload = () => {
      if (!window.pdfjsLib) {
        reject(new Error('PDF.js loaded but pdfjsLib is unavailable.'));
        return;
      }
      window.pdfjsLib.GlobalWorkerOptions.workerSrc = VIEWER_PDFJS_WORKER_SRC;
      resolve(window.pdfjsLib);
    };
    script.onerror = () => reject(new Error('Failed to load PDF.js runtime.'));
    document.head.appendChild(script);
  });
  return viewerState.pdfJsPromise;
}

function viewerFitCanvases(viewport, scrollEl) {
  const baseCanvas = document.getElementById('viewer-pdf-canvas');
  const overlayCanvas = document.getElementById('viewer-overlay-canvas');
  if (!baseCanvas || !overlayCanvas || !viewport || !scrollEl) return;

  const width = Math.max(1, Math.floor(viewport.width));
  const height = Math.max(1, Math.floor(viewport.height));
  baseCanvas.width = width;
  baseCanvas.height = height;
  baseCanvas.style.width = `${width}px`;
  baseCanvas.style.height = `${height}px`;
  baseCanvas.style.display = 'block';

  overlayCanvas.width = width;
  overlayCanvas.height = height;
  overlayCanvas.style.width = `${width}px`;
  overlayCanvas.style.height = `${height}px`;
  overlayCanvas.style.left = `${Math.max(0, Math.floor((scrollEl.clientWidth - width) / 2))}px`;
  overlayCanvas.style.top = '0px';
  overlayCanvas.style.display = 'block';
}

async function viewerRenderCurrentPdfPage() {
  if (!viewerState.pdfDoc) return;
  const fallback = document.getElementById('viewer-fallback');
  if (fallback) fallback.innerHTML = '';
  const scrollEl = document.getElementById('viewer-scroll');
  if (!scrollEl) return;

  const renderToken = ++viewerState.renderToken;
  const page = await viewerState.pdfDoc.getPage(viewerState.page);
  if (renderToken !== viewerState.renderToken) return;

  const baseViewport = page.getViewport({ scale: 1.0 });
  viewerState.pageBaseWidth = baseViewport.width;
  viewerState.pageBaseHeight = baseViewport.height;

  const viewport = page.getViewport({ scale: viewerState.zoom });
  viewerFitCanvases(viewport, scrollEl);

  const baseCanvas = document.getElementById('viewer-pdf-canvas');
  if (!baseCanvas) return;
  const context = baseCanvas.getContext('2d');
  if (!context) return;
  await page.render({ canvasContext: context, viewport }).promise;
  if (renderToken !== viewerState.renderToken) return;
  viewerUpdatePageZoomLabels();
  viewerRenderOverlay();
  viewerRenderOverlayList();
}

async function viewerLoadPdfSource(url) {
  viewerResetStage();
  const token = ++viewerState.pdfLoadToken;
  viewerState.contentKind = 'pdf';
  const fallback = document.getElementById('viewer-fallback');
  if (fallback) fallback.innerHTML = '<p class="small">Loading PDF source...</p>';
  try {
    const pdfjs = await viewerEnsurePdfJs();
    const loadingTask = pdfjs.getDocument(url);
    const doc = await loadingTask.promise;
    if (token !== viewerState.pdfLoadToken) return;
    viewerState.pdfDoc = doc;
    viewerState.pageCount = Math.max(1, Number(doc.numPages || 1));
    if (viewerState.page > viewerState.pageCount) viewerState.page = viewerState.pageCount;
    viewerSetStatus(`Loaded PDF (${viewerState.pageCount} pages). Overlay mode is active.`);
    await viewerRenderCurrentPdfPage();
  } catch (error) {
    viewerState.pdfDoc = null;
    viewerState.pageCount = 1;
    viewerUpdatePageZoomLabels();
    viewerShowFallback(`
      <div>
        <p class="small">Interactive PDF rendering unavailable (${dbEscapeHtml(String(error))}).</p>
        <iframe src="${dbEscapeHtml(url)}#page=${viewerState.page}&zoom=${Math.round(viewerState.zoom * 100)}"></iframe>
      </div>
    `);
    viewerSetStatus('Fallback PDF embed loaded; overlay canvas is unavailable in fallback mode.');
  }
}

function viewerRenderNonPdfSource(payload) {
  viewerResetStage();
  const kind = String(payload?.content?.kind || 'binary');
  const url = String(payload?.content?.url || '');
  viewerState.contentKind = kind;
  if (!url) {
    viewerShowFallback('<p class="small">No source URL available for this resource.</p>');
    viewerSetStatus('Source URL unavailable.');
    return;
  }

  if (kind === 'image') {
    viewerShowFallback(`<img src="${dbEscapeHtml(url)}" alt="resource source image" />`);
    viewerSetStatus('Image source loaded.');
    return;
  }
  if (kind === 'text' || kind === 'table') {
    viewerShowFallback(`<iframe src="${dbEscapeHtml(url)}"></iframe>`);
    viewerSetStatus('Source loaded in embedded document frame.');
    return;
  }
  viewerShowFallback(`
    <div>
      <p class="small">This media type is not directly renderable in-browser.</p>
      <p><a href="${dbEscapeHtml(url)}" target="_blank" rel="noopener">Open Original Source</a></p>
    </div>
  `);
  viewerSetStatus('Binary source: open original file in a new tab/window.');
}

function viewerDerivePageCount(payload) {
  const extraction = payload?.extraction || {};
  const pagesFromExtraction = []
    .concat(Array.isArray(extraction.pages_with_tables) ? extraction.pages_with_tables : [])
    .concat(Array.isArray(extraction.pages_with_geometry) ? extraction.pages_with_geometry : []);
  let count = 1;
  pagesFromExtraction.forEach((p) => {
    const n = Number(p);
    if (Number.isFinite(n)) count = Math.max(count, Math.floor(n));
  });
  return Math.max(1, count);
}

function viewerResolveContentUrl(url) {
  const target = String(url || '');
  if (!target) return '';
  const candidates = candidateApiUrls(target);
  return candidates.length ? candidates[candidates.length - 1] : target;
}

async function viewerOpenPayload(payload) {
  if (payload?.content?.url) {
    payload.content.url = viewerResolveContentUrl(payload.content.url);
  }
  viewerState.payload = payload;
  viewerState.zoom = 1;
  viewerState.page = 1;
  viewerState.selectedCellRow = null;
  viewerState.selectedCellCol = null;
  const firstTable = Array.isArray(payload?.tables) && payload.tables.length ? payload.tables[0] : null;
  viewerState.selectedTableId = firstTable?.id || '';
  viewerSetActiveResource(payload?.resource?.id || '');
  viewerRenderMetadata();
  viewerRenderAnnotations();
  viewerRenderOverlayList();
  viewerRenderTableGrid();
  viewerState.pageCount = viewerDerivePageCount(payload);
  viewerUpdatePageZoomLabels();
  if (String(payload?.content?.kind || '') === 'pdf') {
    await viewerLoadPdfSource(String(payload?.content?.url || ''));
  } else {
    viewerRenderNonPdfSource(payload);
  }
}

function viewerLoadQueryFromInput(rawValue) {
  const raw = String(rawValue || '').trim();
  if (!raw) return null;
  const isDigest = /^[a-f0-9]{64}$/i.test(raw);
  return isDigest
    ? `resource_digest=${encodeURIComponent(raw)}`
    : `resource_id=${encodeURIComponent(raw)}`;
}

async function viewerOpenWithQuery(query) {
  if (!query) return;
  viewerSetStatus('Loading document source and extraction overlays...');
  const payload = await callApi('GET', `/api/viewer/document?${query}`, null, 'out-viewer');
  if (!payload || payload.ok !== true) {
    viewerSetStatus(payload?.detail || payload?.error || 'Document viewer load failed.');
    return;
  }
  await viewerOpenPayload(payload);
}

async function viewerOpenSelected() {
  const select = document.getElementById('viewer-resource-select');
  const selectedId = String(select?.value || '').trim();
  if (!selectedId) {
    viewerSetStatus('Select a resource first.');
    return;
  }
  await viewerOpenWithQuery(`resource_id=${encodeURIComponent(selectedId)}`);
}

async function viewerOpenFromInput() {
  const input = document.getElementById('viewer-resource-id');
  const query = viewerLoadQueryFromInput(input?.value || '');
  if (!query) {
    viewerSetStatus('Provide a resource ID or 64-char digest.');
    return;
  }
  await viewerOpenWithQuery(query);
}

async function viewerOpenFromImport(resourceId) {
  if (!resourceId) return;
  setActivePane('viewer');
  await viewerRefreshResources();
  await viewerOpenWithQuery(`resource_id=${encodeURIComponent(String(resourceId))}`);
}

function viewerPrevPage() {
  if (viewerState.page <= 1) return;
  viewerState.page -= 1;
  viewerUpdatePageZoomLabels();
  viewerRenderCurrentPdfPage();
  viewerRenderOverlayList();
}

function viewerNextPage() {
  if (viewerState.page >= viewerState.pageCount) return;
  viewerState.page += 1;
  viewerUpdatePageZoomLabels();
  viewerRenderCurrentPdfPage();
  viewerRenderOverlayList();
}

function viewerZoomOut() {
  viewerState.zoom = Math.max(viewerState.minZoom, Number((viewerState.zoom - 0.1).toFixed(2)));
  viewerUpdatePageZoomLabels();
  viewerRenderCurrentPdfPage();
}

function viewerZoomIn() {
  viewerState.zoom = Math.min(viewerState.maxZoom, Number((viewerState.zoom + 0.1).toFixed(2)));
  viewerUpdatePageZoomLabels();
  viewerRenderCurrentPdfPage();
}

function viewerTogglePan(enabled) {
  viewerState.panEnabled = Boolean(enabled);
  const scroll = document.getElementById('viewer-scroll');
  if (!scroll) return;
  scroll.classList.toggle('pan-enabled', viewerState.panEnabled);
}

function viewerInitPanHandlers() {
  const scroll = document.getElementById('viewer-scroll');
  if (!scroll) return;
  const beginPan = (event) => {
    if (!viewerState.panEnabled || !viewerState.pdfDoc) return;
    viewerState.panDragging = true;
    viewerState.panStartX = event.clientX;
    viewerState.panStartY = event.clientY;
    viewerState.panScrollLeft = scroll.scrollLeft;
    viewerState.panScrollTop = scroll.scrollTop;
    scroll.classList.add('panning');
    event.preventDefault();
  };
  const movePan = (event) => {
    if (!viewerState.panDragging) return;
    const dx = event.clientX - viewerState.panStartX;
    const dy = event.clientY - viewerState.panStartY;
    scroll.scrollLeft = viewerState.panScrollLeft - dx;
    scroll.scrollTop = viewerState.panScrollTop - dy;
  };
  const endPan = () => {
    viewerState.panDragging = false;
    scroll.classList.remove('panning');
  };
  scroll.addEventListener('mousedown', beginPan);
  window.addEventListener('mousemove', movePan);
  window.addEventListener('mouseup', endPan);
  scroll.addEventListener('mouseleave', () => {
    if (!viewerState.panDragging) return;
    viewerState.panDragging = false;
    scroll.classList.remove('panning');
  });
}

function initDocumentViewer() {
  viewerInitPanHandlers();
  viewerRefreshResources();
}

const IMPORT_STEPS = [
  { id: 'archive', label: 'Archive & Dedupe' },
  { id: 'extract', label: 'Text Extraction' },
  { id: 'tables', label: 'Tables & Annotations' },
  { id: 'vector', label: 'Vector Index Update' },
];

let importProgressTimer = null;
let importCounterTimer = null;
let importProgressValue = 0;
let importPreviewUrl = null;
let importPreviewObjectKey = '';
let importPreviewMetaKey = '';
let importPreviewKind = 'generic';
let importPreviewPageCurrent = 1;
let importPreviewPageTotal = null;
let importPreviewProcessing = false;
let importPreviewTicker = null;
let importPreviewPdfDoc = null;
let importPreviewPdfSourceUrl = '';
let importPreviewPdfLoadToken = 0;
let importPreviewPdfRenderToken = 0;
let importPreviewPdfRenderTask = null;
let importPreviewLastRenderedPage = null;
let importHistoryItems = [];
let importDropQueue = [];
let importDropQueueRunning = false;
let importDropQueueSeq = 0;
let importDropQueueActiveId = null;
let importActiveEta = null;
let importActiveStepMap = null;
let importDurationSamples = [];
let importActiveStreamAbortController = null;
let importDeferRequestedItemId = null;
let importQueuePollTimer = null;
let importQueuePollInFlight = false;

const IMPORT_STREAM_STAGE_WEIGHTS = { archive: 0.2, extract: 0.35, tables: 0.2, vector: 0.25 };
const IMPORT_ETA_HISTORY_MAX = 400;
const IMPORT_ETA_SAMPLE_MAX = 180;
const IMPORT_ETA_STALL_WARN_MS = 45000;
const IMPORT_ETA_STALL_CRITICAL_MS = 180000;

function importClamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}

function importMedian(values) {
  if (!Array.isArray(values) || !values.length) return null;
  const ordered = values
    .map((v) => Number(v))
    .filter((v) => Number.isFinite(v))
    .sort((a, b) => a - b);
  if (!ordered.length) return null;
  const mid = Math.floor(ordered.length / 2);
  if (ordered.length % 2) return ordered[mid];
  return (ordered[mid - 1] + ordered[mid]) / 2;
}

function importTrimmedMean(values, trimFraction = 0.15) {
  if (!Array.isArray(values) || !values.length) return null;
  const ordered = values
    .map((v) => Number(v))
    .filter((v) => Number.isFinite(v))
    .sort((a, b) => a - b);
  if (!ordered.length) return null;
  const trimCount = Math.floor(ordered.length * importClamp(trimFraction, 0, 0.45));
  const slice = ordered.slice(trimCount, Math.max(trimCount + 1, ordered.length - trimCount));
  if (!slice.length) return null;
  return slice.reduce((sum, v) => sum + v, 0) / slice.length;
}

function importFileExtension(name) {
  const value = String(name || '').toLowerCase();
  const match = /\.([a-z0-9]+)$/.exec(value);
  return match ? match[1] : '';
}

function importEtaFeatures(meta) {
  const file = meta?.file || null;
  const name = String(meta?.name || file?.name || '');
  const sizeBytesRaw = meta?.sizeBytes ?? file?.size ?? 0;
  const sizeBytes = Number.isFinite(Number(sizeBytesRaw)) ? Math.max(0, Number(sizeBytesRaw)) : 0;
  return {
    name,
    ext: importFileExtension(name),
    sizeBytes,
  };
}

function importGuessDurationMs(meta) {
  const { ext, sizeBytes } = importEtaFeatures(meta);
  const sizeMb = sizeBytes / (1024 * 1024);
  let guess = 12000 + (sizeMb * 2500);
  if (ext === 'pdf') guess += 14000;
  if (ext === 'docx' || ext === 'doc') guess += 18000;
  if (ext === 'pptx' || ext === 'ppt') guess += 22000;
  return importClamp(Math.round(guess), 12000, 3 * 60 * 60 * 1000);
}

function importPredictDurationMs(meta) {
  const { ext, sizeBytes } = importEtaFeatures(meta);
  if (!importDurationSamples.length) return importGuessDurationMs(meta);

  const allDurations = importDurationSamples.map((s) => Number(s.durationMs)).filter((v) => Number.isFinite(v) && v > 0);
  const globalMedian = importMedian(allDurations);
  const extPool = importDurationSamples.filter((s) => s.ext === ext && Number.isFinite(Number(s.durationMs)) && Number(s.durationMs) > 0);
  const extMedian = extPool.length >= 3 ? importMedian(extPool.map((s) => Number(s.durationMs))) : null;

  const neighborPool = (extPool.length >= 3 ? extPool : importDurationSamples)
    .filter((s) => Number.isFinite(Number(s.sizeBytes)) && Number.isFinite(Number(s.durationMs)) && Number(s.durationMs) > 0);
  let neighborEstimate = null;
  if (neighborPool.length) {
    const ranked = neighborPool
      .map((s) => {
        const a = Math.log1p(Math.max(0, Number(s.sizeBytes)));
        const b = Math.log1p(Math.max(0, sizeBytes));
        const score = Math.abs(a - b);
        return { durationMs: Number(s.durationMs), score };
      })
      .sort((a, b) => a.score - b.score)
      .slice(0, 7)
      .map((s) => s.durationMs);
    neighborEstimate = importTrimmedMean(ranked, 0.2);
  }

  const parts = [];
  if (globalMedian) parts.push({ w: 0.22, v: globalMedian });
  if (extMedian) parts.push({ w: 0.43, v: extMedian });
  if (neighborEstimate) parts.push({ w: 0.35, v: neighborEstimate });
  if (!parts.length) return importGuessDurationMs(meta);

  const weightSum = parts.reduce((sum, p) => sum + p.w, 0);
  const blended = parts.reduce((sum, p) => sum + (p.v * p.w), 0) / weightSum;
  return importClamp(Math.round(blended), 8000, 3 * 60 * 60 * 1000);
}

function importRecordDurationSample(meta, durationMs, ok = true) {
  const duration = Number(durationMs);
  if (!Number.isFinite(duration) || duration <= 0) return;
  const features = importEtaFeatures(meta);
  importDurationSamples.push({
    ext: features.ext,
    sizeBytes: features.sizeBytes,
    durationMs: duration,
    ok: Boolean(ok),
    ts: Date.now(),
  });
  if (importDurationSamples.length > IMPORT_ETA_HISTORY_MAX) {
    importDurationSamples = importDurationSamples.slice(importDurationSamples.length - IMPORT_ETA_HISTORY_MAX);
  }
}

function importFormatEtaDuration(ms) {
  if (!Number.isFinite(ms) || ms < 0) return 'calculating...';
  if (ms < 1000) return '<1s';
  const totalSec = Math.ceil(ms / 1000);
  const sec = totalSec % 60;
  const min = Math.floor(totalSec / 60) % 60;
  const hr = Math.floor(totalSec / 3600);
  if (hr > 0) return `${hr}h ${String(min).padStart(2, '0')}m`;
  if (min > 0) return `${min}m ${String(sec).padStart(2, '0')}s`;
  return `${sec}s`;
}

function importEtaStart(meta) {
  const now = Date.now();
  return {
    meta,
    startedAtMs: now,
    lastHeartbeatMs: now,
    predictedTotalMs: importPredictDurationMs(meta),
    samples: [{ t: now, p: 0 }],
    lastProgress: 0,
  };
}

function importEtaTrackProgress(eta, progress01, nowMs) {
  if (!eta) return;
  const progress = importClamp(Number(progress01) || 0, 0, 1);
  const now = Number(nowMs) || Date.now();
  const prev = eta.samples.length ? eta.samples[eta.samples.length - 1] : null;
  const shouldPush = !prev
    || (progress - prev.p) >= 0.004
    || (now - prev.t) >= 5000;
  if (!shouldPush) return;
  eta.samples.push({ t: now, p: progress });
  if (eta.samples.length > IMPORT_ETA_SAMPLE_MAX) {
    eta.samples = eta.samples.slice(eta.samples.length - IMPORT_ETA_SAMPLE_MAX);
  }
  eta.lastProgress = Math.max(eta.lastProgress || 0, progress);
}

function importEtaRobustRate(eta) {
  if (!eta || !Array.isArray(eta.samples) || eta.samples.length < 3) return null;
  const recent = eta.samples.filter((s) => (eta.samples[eta.samples.length - 1].t - s.t) <= 180000);
  if (recent.length < 3) return null;
  const slopes = [];
  for (let i = 1; i < recent.length; i += 1) {
    const upper = recent[i];
    const start = Math.max(0, i - 7);
    for (let j = start; j < i; j += 1) {
      const lower = recent[j];
      const dt = (upper.t - lower.t) / 1000;
      if (dt < 1.0) continue;
      const dp = upper.p - lower.p;
      if (dp <= 0) continue;
      slopes.push(dp / dt);
    }
  }
  if (!slopes.length) return null;
  return importTrimmedMean(slopes, 0.15);
}

function importEtaEstimate(stepMap) {
  if (!importActiveEta) return null;
  const now = Date.now();
  const elapsedMs = Math.max(0, now - importActiveEta.startedAtMs);
  const progress01 = importClamp(importStreamOverallProgress(stepMap) / 100, 0, 1);
  importEtaTrackProgress(importActiveEta, progress01, now);

  const rate = importEtaRobustRate(importActiveEta);
  const priorRemainingMs = Math.max(0, importActiveEta.predictedTotalMs - elapsedMs);
  const etaFromRateMs = (rate && rate > 0.00001)
    ? Math.max(0, ((1 - progress01) / rate) * 1000)
    : null;

  let etaMs = null;
  if (etaFromRateMs === null) {
    etaMs = priorRemainingMs;
  } else {
    const wRate = importClamp(0.22 + (progress01 * 0.66) + (importActiveEta.samples.length >= 8 ? 0.08 : 0), 0.2, 0.92);
    etaMs = (wRate * etaFromRateMs) + ((1 - wRate) * priorRemainingMs);
  }

  const stallMs = Math.max(0, now - (importActiveEta.lastHeartbeatMs || importActiveEta.startedAtMs));
  if (stallMs >= IMPORT_ETA_STALL_WARN_MS) {
    const multiplier = stallMs >= IMPORT_ETA_STALL_CRITICAL_MS ? 1.6 : 1.25;
    etaMs = Math.max(etaMs, priorRemainingMs * multiplier);
  }

  return {
    elapsedMs,
    progress01,
    etaMs: Number.isFinite(etaMs) ? Math.max(0, etaMs) : null,
    stallMs,
  };
}

function importCounterLineWithEta(baseCountersLine, eta) {
  const raw = String(baseCountersLine || '').trim();
  const segments = raw ? raw.split('  ').filter((part) => part && !/^ETA\b/i.test(part)) : [];
  const elapsedToken = `Elapsed ${(eta?.elapsedMs ? (eta.elapsedMs / 1000).toFixed(1) : '0.0')}s`;
  if (!segments.some((part) => /^Elapsed\b/i.test(part))) {
    segments.unshift(elapsedToken);
  }
  const etaToken = `ETA ${importFormatEtaDuration(eta?.etaMs)}`;
  segments.push(etaToken);
  if (eta?.stallMs >= IMPORT_ETA_STALL_WARN_MS) {
    const stallLabel = eta.stallMs >= IMPORT_ETA_STALL_CRITICAL_MS ? 'stalled' : 'heartbeat delayed';
    segments.push(`${stallLabel} ${importFormatEtaDuration(eta.stallMs)}`);
  }
  return segments.join('  ');
}

function importStatusLineWithHeartbeat(baseStatusLine, eta) {
  const raw = String(baseStatusLine || '').replace(/\s*\s*waiting for stage heartbeat.*$/i, '').trim();
  if (!eta || eta.stallMs < IMPORT_ETA_STALL_WARN_MS) return raw;
  return `${raw}  waiting for stage heartbeat ${importFormatEtaDuration(eta.stallMs)}`;
}

function importQueueRemainingEtaMs() {
  if (!importDropQueue.length) return 0;
  const now = Date.now();
  return importDropQueue.reduce((sum, item) => {
    if (item.status === 'done' || item.status === 'failed') return sum;
    if (item.status === 'processing') {
      let processingRemaining = null;
      if (importDropQueueActiveId === item.id && importActiveEta && importActiveStepMap) {
        const eta = importEtaEstimate(importActiveStepMap);
        if (eta && Number.isFinite(eta.etaMs)) processingRemaining = eta.etaMs;
      }
      if (processingRemaining === null) {
        const predictedTotal = importPredictDurationMs(item);
        const elapsed = item.startedAtMs ? Math.max(0, now - item.startedAtMs) : 0;
        processingRemaining = Math.max(0, predictedTotal - elapsed);
      }
      return sum + processingRemaining;
    }
    return sum + importPredictDurationMs(item);
  }, 0);
}

function importCanDeferCurrentQueueItem() {
  if (!importActiveStreamAbortController) return false;
  if (!importDropQueueRunning || !importDropQueueActiveId) return false;
  return importDropQueue.some((item) => item.id !== importDropQueueActiveId && item.status === 'pending');
}

function importDeferCurrentQueueItem() {
  if (!importCanDeferCurrentQueueItem()) return;
  importDeferRequestedItemId = importDropQueueActiveId;
  if (importActiveStreamAbortController) {
    try {
      importActiveStreamAbortController.abort();
    } catch {
    }
  }
}

function importLiveQueueActionsHtml() {
  if (!importActiveStreamAbortController) return '';
  if (!importDropQueueRunning || !importDropQueueActiveId) return '';
  const canDefer = importCanDeferCurrentQueueItem();
  const hint = canDefer
    ? 'Move this document to the back of the queue and continue with the next pending file.'
    : 'No other pending files are available right now.';
  return `
    <div class="row">
      <button type="button" class="secondary" onclick="importDeferCurrentQueueItem()" ${canDefer ? '' : 'disabled'}>
        Put Document To Back Of Queue
      </button>
      <span class="small">${dbEscapeHtml(hint)}</span>
    </div>
  `;
}

function importFileSizeText(bytes) {
  const n = Number(bytes);
  if (!Number.isFinite(n) || n < 0) return 'unknown size';
  if (n < 1024) return `${Math.floor(n)} B`;
  if (n < 1024 * 1024) return `${(n / 1024).toFixed(1)} KB`;
  if (n < 1024 * 1024 * 1024) return `${(n / (1024 * 1024)).toFixed(1)} MB`;
  if (n < 1024 * 1024 * 1024 * 1024) return `${(n / (1024 * 1024 * 1024)).toFixed(2)} GB`;
  return `${(n / (1024 * 1024 * 1024 * 1024)).toFixed(2)} TB`;
}

function importPathBasename(path) {
  if (!path) return 'document';
  const clean = String(path).replace(/\\/g, '/');
  const parts = clean.split('/');
  return parts[parts.length - 1] || clean;
}

function importClearPreviewUrl() {
  importCancelPdfRenderTask();
  if (importPreviewUrl) {
    URL.revokeObjectURL(importPreviewUrl);
    importPreviewUrl = null;
  }
  importPreviewObjectKey = '';
  importPreviewPdfSourceUrl = '';
  importPreviewLastRenderedPage = null;
  importPreviewPdfLoadToken += 1;
  if (importPreviewPdfDoc && typeof importPreviewPdfDoc.destroy === 'function') {
    try {
      importPreviewPdfDoc.destroy();
    } catch {
    }
  }
  importPreviewPdfDoc = null;
}

function importCancelPdfRenderTask() {
  if (importPreviewPdfRenderTask && typeof importPreviewPdfRenderTask.cancel === 'function') {
    try {
      importPreviewPdfRenderTask.cancel();
    } catch {
    }
  }
  importPreviewPdfRenderTask = null;
}

function importStopPreviewTicker() {
  if (importPreviewTicker) {
    clearInterval(importPreviewTicker);
    importPreviewTicker = null;
  }
}

function importPreviewSyncDom() {
  if (importPreviewPageTotal) {
    const safeTotal = Math.max(1, Math.floor(importPreviewPageTotal));
    importPreviewPageTotal = safeTotal;
    if (importPreviewPageCurrent > safeTotal) {
      importPreviewPageCurrent = safeTotal;
    }
  }
  const current = document.getElementById('import-preview-page-current');
  if (current) current.textContent = String(Math.max(1, importPreviewPageCurrent));
  const total = document.getElementById('import-preview-page-total');
  if (total) total.textContent = importPreviewPageTotal ? String(importPreviewPageTotal) : '...';
}

function importEnsurePreviewObjectUrl(meta) {
  if (!meta || !meta.file) return null;
  const key = importPreviewKey(meta);
  if (!importPreviewUrl || importPreviewObjectKey !== key) {
    importClearPreviewUrl();
    importPreviewUrl = URL.createObjectURL(meta.file);
    importPreviewObjectKey = key;
  }
  return importPreviewUrl;
}

function importResolvePreviewSourceUrl(meta) {
  const objectUrl = importEnsurePreviewObjectUrl(meta);
  if (objectUrl) return objectUrl;
  if (meta && typeof meta.previewUrl === 'string' && meta.previewUrl.trim()) {
    return meta.previewUrl.trim();
  }
  return null;
}

function importPreviewKey(meta) {
  if (!meta || typeof meta !== 'object') return 'none';
  const file = meta.file;
  if (file) {
    return `file:${file.name || ''}:${file.size || 0}:${file.lastModified || 0}:${file.type || ''}`;
  }
  return `meta:${meta.name || ''}:${meta.path || ''}:${meta.sourceLabel || ''}:${meta.queueJobId || ''}:${meta.previewUrl || ''}`;
}

function importPreviewLooksPdf(meta) {
  const name = (meta && meta.name) ? String(meta.name) : '';
  return Boolean(
    (meta && meta.file && meta.file.type === 'application/pdf')
    || name.toLowerCase().endsWith('.pdf')
  );
}

function importPreviewPageHintFromText(text) {
  if (!text) return null;
  const raw = String(text);
  const candidates = [
    /\bpages?\s*(?:~|=|:)?\s*(\d+)\b/i,
    /\b(\d+)\s*page(?:\(s\)|s)?\b/i,
  ];
  for (const pattern of candidates) {
    const match = pattern.exec(raw);
    if (!match) continue;
    const value = Number(match[1]);
    if (Number.isFinite(value) && value > 0) return Math.floor(value);
  }
  return null;
}

function importPreviewCurrentPageHintFromText(text) {
  if (!text) return null;
  const raw = String(text);
  const patterns = [
    /\bpage\s+(\d+)\s*\/\s*(\d+)\b/i,
    /\bp(?:age)?\s*(\d+)\s+of\s+(\d+)\b/i,
  ];
  for (const pattern of patterns) {
    const match = pattern.exec(raw);
    if (!match) continue;
    const current = Number(match[1]);
    if (Number.isFinite(current) && current > 0) return Math.floor(current);
  }
  return null;
}

function importResolvePageHint(opts = {}) {
  if (Array.isArray(opts.steps)) {
    let explicitBest = 0;
    opts.steps.forEach((step) => {
      const raw = Number(step?.page_count);
      if (!Number.isFinite(raw) || raw <= 0) return;
      explicitBest = Math.max(explicitBest, Math.floor(raw));
    });
    if (explicitBest > 0) return explicitBest;
  }
  const texts = [];
  if (opts.statusLine) texts.push(String(opts.statusLine));
  if (opts.countersLine) texts.push(String(opts.countersLine));
  if (Array.isArray(opts.steps)) {
    const extractStep = opts.steps.find((step) => String(step.id || '').toLowerCase() === 'extract')
      || opts.steps.find((step) => String(step.label || '').toLowerCase().includes('text'));
    if (extractStep) {
      if (extractStep.detail) texts.push(String(extractStep.detail));
      if (extractStep.stats) texts.push(String(extractStep.stats));
    }
  }
  let best = 0;
  texts.forEach((text) => {
    const hint = importPreviewPageHintFromText(text);
    if (hint && hint > best) best = hint;
  });
  return best > 0 ? best : null;
}

function importResolveCurrentPageHint(opts = {}) {
  if (Array.isArray(opts.steps)) {
    let explicitBest = 0;
    opts.steps.forEach((step) => {
      const raw = Number(step?.page_current ?? step?.current_page);
      if (!Number.isFinite(raw) || raw <= 0) return;
      explicitBest = Math.max(explicitBest, Math.floor(raw));
    });
    if (explicitBest > 0) return explicitBest;
  }
  const texts = [];
  if (opts.statusLine) texts.push(String(opts.statusLine));
  if (opts.countersLine) texts.push(String(opts.countersLine));
  if (Array.isArray(opts.steps)) {
    const extractStep = opts.steps.find((step) => String(step.id || '').toLowerCase() === 'extract')
      || opts.steps.find((step) => String(step.label || '').toLowerCase().includes('text'));
    if (extractStep) {
      if (extractStep.detail) texts.push(String(extractStep.detail));
      if (extractStep.stats) texts.push(String(extractStep.stats));
    }
  }
  let best = 0;
  texts.forEach((text) => {
    const hint = importPreviewCurrentPageHintFromText(text);
    if (hint && hint > best) best = hint;
  });
  return best > 0 ? best : null;
}

function importResolveProgressEstimatedPage(opts = {}) {
  if (!importPreviewPageTotal || !Array.isArray(opts.steps)) return null;
  const extractStep = opts.steps.find((step) => String(step.id || '').toLowerCase() === 'extract')
    || opts.steps.find((step) => String(step.label || '').toLowerCase().includes('text'));
  if (!extractStep) return null;
  const raw = Number(extractStep.progress);
  if (!Number.isFinite(raw)) return null;
  // Parse heartbeat emits extract progress in ~[4..55] while parsing pages;
  // map that band to [0..1] so preview page does not plateau at ~94%.
  const normalized = Math.max(0, Math.min(1, (raw - 4) / 51));
  const projected = Math.floor(importPreviewPageTotal * normalized);
  return Math.max(1, Math.min(importPreviewPageTotal, projected || 1));
}

async function importPreviewRenderCurrentPage(force = false) {
  if (importPreviewKind !== 'pdf') return;
  if (!importPreviewPdfDoc) return;
  const canvas = document.getElementById('import-preview-pdf-canvas');
  const placeholder = document.getElementById('import-preview-pdf-placeholder');
  if (!canvas) return;
  const totalPages = Math.max(1, Number(importPreviewPdfDoc.numPages || importPreviewPageTotal || 1));
  const targetPage = Math.max(1, Math.min(totalPages, Math.floor(importPreviewPageCurrent || 1)));
  if (!force && importPreviewLastRenderedPage === targetPage) return;
  const renderToken = ++importPreviewPdfRenderToken;
  importCancelPdfRenderTask();
  try {
    const page = await importPreviewPdfDoc.getPage(targetPage);
    if (renderToken !== importPreviewPdfRenderToken) return;
    const baseViewport = page.getViewport({ scale: 1.0 });
    const maxWidth = 170;
    const maxHeight = 220;
    const scale = Math.max(0.12, Math.min(2.2, Math.min(maxWidth / baseViewport.width, maxHeight / baseViewport.height)));
    const viewport = page.getViewport({ scale });
    const scratch = document.createElement('canvas');
    scratch.width = Math.max(1, Math.floor(viewport.width));
    scratch.height = Math.max(1, Math.floor(viewport.height));
    const scratchCtx = scratch.getContext('2d', { alpha: false });
    if (!scratchCtx) return;
    const renderTask = page.render({ canvasContext: scratchCtx, viewport });
    importPreviewPdfRenderTask = renderTask;
    await renderTask.promise;
    if (importPreviewPdfRenderTask === renderTask) {
      importPreviewPdfRenderTask = null;
    }
    if (renderToken !== importPreviewPdfRenderToken) return;
    const ctx = canvas.getContext('2d', { alpha: false });
    if (!ctx) return;
    if (canvas.width !== scratch.width || canvas.height !== scratch.height) {
      canvas.width = scratch.width;
      canvas.height = scratch.height;
      canvas.style.width = `${scratch.width}px`;
      canvas.style.height = `${scratch.height}px`;
    }
    ctx.drawImage(scratch, 0, 0);
    importPreviewLastRenderedPage = targetPage;
    if (placeholder) placeholder.style.display = 'none';
  } catch (error) {
    const message = String(error || '');
    const cancelled = (
      String(error?.name || '').toLowerCase() === 'renderingcancelledexception'
      || /cancel/i.test(message)
      || /same canvas/i.test(message)
    );
    if (cancelled) return;
    if (placeholder) {
      placeholder.style.display = 'block';
      placeholder.textContent = `Preview unavailable (${message})`;
    }
  } finally {
    if (importPreviewPdfRenderTask && renderToken !== importPreviewPdfRenderToken) {
      importCancelPdfRenderTask();
    }
  }
}

async function importEnsurePdfPreviewDocument(meta) {
  if (importPreviewKind !== 'pdf') return null;
  const sourceUrl = importResolvePreviewSourceUrl(meta);
  if (!sourceUrl) return null;
  if (importPreviewPdfDoc && importPreviewPdfSourceUrl === sourceUrl) {
    if (importPreviewPageTotal) importPreviewSyncDom();
    return importPreviewPdfDoc;
  }
  importPreviewPdfSourceUrl = sourceUrl;
  importPreviewLastRenderedPage = null;
  importCancelPdfRenderTask();
  const loadToken = ++importPreviewPdfLoadToken;
  const placeholder = document.getElementById('import-preview-pdf-placeholder');
  if (placeholder) {
    placeholder.style.display = 'block';
    placeholder.textContent = 'Loading PDF preview...';
  }
  try {
    const pdfjs = await viewerEnsurePdfJs();
    const loadingTask = pdfjs.getDocument(sourceUrl);
    const doc = await loadingTask.promise;
    if (loadToken !== importPreviewPdfLoadToken) {
      if (typeof doc.destroy === 'function') {
        try {
          doc.destroy();
        } catch {
        }
      }
      return null;
    }
    if (importPreviewPdfDoc && typeof importPreviewPdfDoc.destroy === 'function') {
      try {
        importPreviewPdfDoc.destroy();
      } catch {
      }
    }
    importPreviewPdfDoc = doc;
    const totalPages = Math.max(1, Number(doc.numPages || 1));
    importPreviewPageTotal = Math.max(importPreviewPageTotal || 0, totalPages);
    if (importPreviewPageCurrent > importPreviewPageTotal) {
      importPreviewPageCurrent = importPreviewPageTotal;
    }
    importPreviewSyncDom();
    await importPreviewRenderCurrentPage(true);
    return doc;
  } catch (error) {
    importPreviewPdfDoc = null;
    if (placeholder) {
      placeholder.style.display = 'block';
      placeholder.textContent = `Preview unavailable (${String(error)})`;
    }
    return null;
  }
}

function importEnsurePreviewTicker() {
  if (importPreviewTicker) return;
  importPreviewTicker = setInterval(() => {
    if (!importPreviewProcessing || importPreviewKind !== 'pdf') return;
    const cap = importPreviewPageTotal || 999;
    if (importPreviewPageCurrent < cap) {
      importPreviewPageCurrent += 1;
      importPreviewSyncDom();
      importPreviewRenderCurrentPage();
    }
  }, 760);
}

function importPreparePreview(meta, opts = {}) {
  const key = importPreviewKey(meta);
  const imageKind = Boolean(meta && meta.file && meta.file.type && meta.file.type.startsWith('image/'));
  const nextKind = importPreviewLooksPdf(meta) ? 'pdf' : (imageKind ? 'image' : 'generic');

  if (key !== importPreviewMetaKey) {
    importPreviewMetaKey = key;
    importPreviewPageCurrent = 1;
    importPreviewPageTotal = null;
    importPreviewKind = nextKind;
    importPreviewProcessing = false;
    importStopPreviewTicker();
    if (nextKind !== 'image' && nextKind !== 'pdf') importClearPreviewUrl();
    if (nextKind === 'image' || nextKind === 'pdf') {
      importEnsurePreviewObjectUrl(meta);
    }
  } else {
    importPreviewKind = nextKind;
  }

  const pageHint = importResolvePageHint(opts);
  if (pageHint) {
    importPreviewPageTotal = Math.max(importPreviewPageTotal || 0, pageHint);
  }
  const currentHint = importResolveCurrentPageHint(opts);
  if (currentHint) {
    const cap = importPreviewPageTotal || currentHint;
    importPreviewPageCurrent = Math.max(1, Math.min(cap, currentHint));
  }

  importPreviewProcessing = Boolean(opts.progressActive);
  if (importPreviewKind === 'pdf') {
    const hasPreviewSource = Boolean(importResolvePreviewSourceUrl(meta));
    const projected = importResolveProgressEstimatedPage(opts);
    if (projected) {
      importPreviewPageCurrent = Math.max(importPreviewPageCurrent, projected);
    }
    if (importPreviewProcessing) {
      if (projected || !hasPreviewSource || !importPreviewPageTotal) {
        importStopPreviewTicker();
      } else {
        importEnsurePreviewTicker();
      }
    } else {
      importStopPreviewTicker();
      if (importPreviewPageTotal) importPreviewPageCurrent = importPreviewPageTotal;
    }
    importPreviewSyncDom();
    importEnsurePdfPreviewDocument(meta).then(() => {
      importPreviewRenderCurrentPage();
    });
  } else {
    importStopPreviewTicker();
    if (importPreviewKind === 'image') {
      importEnsurePreviewObjectUrl(meta);
    }
  }
}

function importPreviewMarkup(meta, opts = {}) {
  if (meta && meta.file && meta.file.type && meta.file.type.startsWith('image/')) {
    importEnsurePreviewObjectUrl(meta);
    return `<img src="${importPreviewUrl}" alt="${dbEscapeHtml(meta.file.name || 'import file')}" />`;
  }

  const name = (meta && meta.name) ? String(meta.name) : '';
  const looksPdf = importPreviewLooksPdf(meta);
  if (looksPdf) {
    const title = dbEscapeHtml(name || 'Document');
    const hasPdfSource = Boolean(importResolvePreviewSourceUrl(meta));
    if (!hasPdfSource) {
      return `
        <div class="import-preview-pdf">
          <div class="import-preview-pdf-canvas-wrap">
            <div class="import-preview-pdf-placeholder" style="position: static; background: transparent;">Live page preview source is unavailable for this item.</div>
          </div>
          <p class="import-preview-pdf-title">${title}</p>
          <p class="import-preview-caption">Page <span id="import-preview-page-current">${Math.max(1, importPreviewPageCurrent)}</span> / <span id="import-preview-page-total">${importPreviewPageTotal ? String(importPreviewPageTotal) : '...'}</span></p>
        </div>
      `;
    }
    const state = importPreviewProcessing ? 'processing' : 'idle';
    return `
      <div class="import-preview-pdf ${state}">
        <div class="import-preview-pdf-canvas-wrap">
          <canvas id="import-preview-pdf-canvas" class="import-preview-pdf-canvas" role="img" aria-label="Current PDF page preview"></canvas>
          <div id="import-preview-pdf-placeholder" class="import-preview-pdf-placeholder">Loading PDF preview...</div>
        </div>
        <p class="import-preview-pdf-title">${title}</p>
        <p class="import-preview-caption">Page <span id="import-preview-page-current">${Math.max(1, importPreviewPageCurrent)}</span> / <span id="import-preview-page-total">${importPreviewPageTotal ? String(importPreviewPageTotal) : '...'}</span></p>
      </div>
    `;
  }

  const title = dbEscapeHtml(name || 'Document');
  return `<div><strong>${title}</strong><br /><span class="small">Preview available for dropped PDF/image files.</span></div>`;
}

function importStepHtml(stepState) {
  const state = stepState.state || 'pending';
  const detail = stepState.detail ? dbEscapeHtml(stepState.detail) : '';
  const stats = stepState.stats ? `  ${dbEscapeHtml(stepState.stats)}` : '';
  const progressRaw = Number(stepState.progress);
  const progress = Number.isFinite(progressRaw)
    ? Math.max(0, Math.min(100, progressRaw))
    : (state === 'pending' ? 0 : 100);
  return `
    <div class="import-step ${state}">
      <div class="import-step-head">
        <strong>${dbEscapeHtml(stepState.label)}</strong>
        <span class="step-badge">${dbEscapeHtml(state)}</span>
      </div>
      <div class="step-progress-track">
        <div class="step-progress-bar ${state === 'active' ? 'active' : ''}" style="width:${progress}%"></div>
      </div>
      <p class="import-step-detail">${detail}${stats}</p>
    </div>
  `;
}

function importQueueStatusLabel(status) {
  const normalized = String(status || '').toLowerCase();
  if (normalized === 'processing') return 'processing';
  if (normalized === 'done') return 'done';
  if (normalized === 'failed') return 'failed';
  return 'pending';
}

function importQueueStatusTone(status) {
  const normalized = String(status || '').toLowerCase();
  if (normalized === 'processing') return 'warning';
  if (normalized === 'done') return 'ok';
  if (normalized === 'failed') return 'error';
  return 'neutral';
}

function importRenderDropQueue() {
  const el = document.getElementById('import-drop-queue');
  if (!el) return;
  if (!importDropQueue.length) {
    el.innerHTML = '<p class="small">No files queued.</p>';
    return;
  }

  const pendingCount = importDropQueue.filter((item) => item.status === 'pending').length;
  const processingCount = importDropQueue.filter((item) => item.status === 'processing').length;
  const doneCount = importDropQueue.filter((item) => item.status === 'done').length;
  const failedCount = importDropQueue.filter((item) => item.status === 'failed').length;
  const queueEtaMs = importQueueRemainingEtaMs();
  const queueEtaText = (pendingCount + processingCount) > 0
    ? `  ETA ${importFormatEtaDuration(queueEtaMs)} remaining`
    : '';

  const itemsHtml = importDropQueue
    .map((item, idx) => {
      const status = importQueueStatusLabel(item.status);
      const tone = importQueueStatusTone(status);
      const position = idx + 1;
      const currentBadge = status === 'processing' ? '  current' : '';
      return `
        <article class="import-queue-item ${status}">
          <h4 class="import-queue-item-head">
            <span>${position}. ${dbEscapeHtml(item.name || 'document')}</span>
            <span class="status-pill ${statusClass(tone)}">${dbEscapeHtml(titleCase(status))}${dbEscapeHtml(currentBadge)}</span>
          </h4>
          <p class="import-queue-item-meta">${dbEscapeHtml(importFileSizeText(item.sizeBytes ?? 0))}</p>
          <p class="import-queue-item-detail">${dbEscapeHtml(item.detail || '')}</p>
        </article>
      `;
    })
    .join('');

  el.innerHTML = `
    <p class="import-queue-head">Queue: ${importDropQueue.length} total  ${pendingCount} pending  ${processingCount} processing  ${doneCount} done  ${failedCount} failed${queueEtaText}</p>
    ${itemsHtml}
  `;
}

function importRenderHistory() {
  const el = document.getElementById('import-history');
  if (!el) return;
  if (!importHistoryItems.length) {
    el.innerHTML = '<p class="small">No imports yet.</p>';
    return;
  }
  el.innerHTML = importHistoryItems
    .map((item) => `
      <article class="import-history-item">
        <h4><span class="status-pill ${statusClass(item.statusTone || 'neutral')}">${dbEscapeHtml(item.statusLabel || 'unknown')}</span>${dbEscapeHtml(item.name || 'document')}</h4>
        <p>${dbEscapeHtml(item.summary || '')}</p>
      </article>
    `)
    .join('');
}

function importAddHistory(item) {
  importHistoryItems.unshift(item);
  if (importHistoryItems.length > 12) importHistoryItems.length = 12;
  importRenderHistory();
}

function importStopTimers() {
  if (importProgressTimer) {
    clearInterval(importProgressTimer);
    importProgressTimer = null;
  }
  if (importCounterTimer) {
    clearInterval(importCounterTimer);
    importCounterTimer = null;
  }
  importPreviewProcessing = false;
  importStopPreviewTicker();
}

function importSetProgress(value, active = false) {
  const bar = document.getElementById('import-progress-bar');
  if (!bar) return;
  bar.style.width = `${Math.max(0, Math.min(100, value))}%`;
  bar.classList.toggle('active', active);
}

function importRenderLive(meta, opts = {}) {
  const live = document.getElementById('import-live');
  if (!live) return;
  live.classList.remove('empty');
  importPreparePreview(meta, opts);
  const previewKey = importPreviewKey(meta);
  const previewKind = importPreviewKind;
  const canReusePreview = (
    live.getAttribute('data-preview-key') === previewKey
    && live.getAttribute('data-preview-kind') === previewKind
    && Boolean(live.querySelector('[data-import-preview-host]'))
  );

  const stepHtml = Array.isArray(opts.steps) ? opts.steps.map(importStepHtml).join('') : '';
  const metricHtml = Array.isArray(opts.metrics)
    ? opts.metrics
        .map((m) => `
          <div class="import-metric">
            <p class="k">${dbEscapeHtml(m.k || '')}</p>
            <p class="v">${dbEscapeHtml(String(m.v ?? ''))}</p>
          </div>
        `)
        .join('')
    : '';
  const actionsHtml = opts.actionsHtml || '';

  const bodyHtml = `
    <h4 class="import-title">${dbEscapeHtml(opts.title || meta.name || 'Import Job')}</h4>
    <p class="import-meta">${dbEscapeHtml(opts.meta || '')}</p>
    <div class="import-progress-track">
      <div id="import-progress-bar" class="import-progress-bar"></div>
    </div>
    <p id="import-status-line" class="import-status-line">${dbEscapeHtml(opts.statusLine || '')}</p>
    <p id="import-counters" class="import-counters">${dbEscapeHtml(opts.countersLine || '')}</p>
    <div class="import-steps">${stepHtml}</div>
    <div class="import-metrics">${metricHtml}</div>
    ${actionsHtml}
  `;

  if (!canReusePreview) {
    live.innerHTML = `
      <div class="import-preview" data-import-preview-host>${importPreviewMarkup(meta, opts)}</div>
      <div data-import-live-body>${bodyHtml}</div>
    `;
  } else {
    const body = live.querySelector('[data-import-live-body]');
    if (body) body.innerHTML = bodyHtml;
  }
  live.setAttribute('data-preview-key', previewKey);
  live.setAttribute('data-preview-kind', previewKind);
  importSetProgress(opts.progress ?? 0, Boolean(opts.progressActive));
  importPreviewSyncDom();
  if (importPreviewKind === 'pdf') {
    importPreviewRenderCurrentPage();
  }
}

function importStartAnimatedJob(meta) {
  importStopTimers();
  importProgressValue = 5;
  const est = {
    pages: 0,
    words: 0,
    sentences: 0,
    paragraphs: 0,
    tables: 0,
    rows: 0,
    chunks: 0,
  };
  const stepProgress = {
    archive: 6,
    extract: 2,
    tables: 1,
    vector: 1,
  };
  const startMs = Date.now();
  const startedAt = new Date().toLocaleTimeString();
  importRenderLive(meta, {
    title: meta.name || 'Import Job',
    meta: `${meta.sourceLabel || 'Import'}  started ${startedAt}`,
    statusLine: 'Uploading and deduplicating document...',
    countersLine: 'Initializing parser and extraction pipeline...',
    steps: IMPORT_STEPS.map((s, idx) => ({ ...s, state: idx === 0 ? 'active' : 'pending', progress: idx === 0 ? 8 : 0 })),
    progress: importProgressValue,
    progressActive: true,
  });

  importProgressTimer = setInterval(() => {
    stepProgress.archive = Math.min(98, stepProgress.archive + (Math.random() * 5.8 + 2.4));
    stepProgress.extract = Math.min(96, stepProgress.extract + (Math.random() * 4.9 + 1.6));
    stepProgress.tables = Math.min(95, stepProgress.tables + (Math.random() * 3.8 + 1.2));
    if (stepProgress.extract > 18 || stepProgress.tables > 14) {
      stepProgress.vector = Math.min(94, stepProgress.vector + (Math.random() * 3.9 + 1.1));
    } else {
      stepProgress.vector = Math.min(20, stepProgress.vector + (Math.random() * 1.1));
    }

    importProgressValue = Math.min(
      92,
      (stepProgress.archive * 0.18)
      + (stepProgress.extract * 0.34)
      + (stepProgress.tables * 0.22)
      + (stepProgress.vector * 0.26)
    );

    const stageLabel = `Archive ${Math.floor(stepProgress.archive)}%  Text ${Math.floor(stepProgress.extract)}%  Tables ${Math.floor(stepProgress.tables)}%  Vectors ${Math.floor(stepProgress.vector)}%`;
    const stepStates = IMPORT_STEPS.map((s, idx) => ({
      ...s,
      state: (idx === 0 ? stepProgress.archive : (idx === 1 ? stepProgress.extract : (idx === 2 ? stepProgress.tables : stepProgress.vector))) >= 94
        ? 'done'
        : 'active',
      progress: idx === 0
        ? stepProgress.archive
        : (idx === 1 ? stepProgress.extract : (idx === 2 ? stepProgress.tables : stepProgress.vector)),
      detail: idx === 0
        ? 'Hashing, dedupe check, immutable archive write.'
        : (idx === 1
          ? 'Reading pages and parsing canonical text.'
          : (idx === 2
            ? 'Building table structures and annotations.'
            : 'Embedding chunks and updating vector store.')),
      stats: idx === 1
        ? `~${est.pages} pages  ~${est.words} words  ~${est.sentences} sentences  ~${est.paragraphs} paragraphs`
        : (idx === 2
          ? `~${est.tables} tables  ~${est.rows} rows`
          : (idx === 3 ? `~${est.chunks} chunks` : '')),
    }));
    const status = document.getElementById('import-status-line');
    if (status) status.textContent = `Running extraction, Docling structure parsing, and vector indexing by default. ${stageLabel}`;
    const counters = document.getElementById('import-counters');
    if (counters) {
      const elapsed = ((Date.now() - startMs) / 1000).toFixed(1);
      counters.textContent = `Elapsed ${elapsed}s  Pages ~${est.pages}  Words ~${est.words}  Sentences ~${est.sentences}  Paragraphs ~${est.paragraphs}  Tables ~${est.tables}  Rows ~${est.rows}  Vector chunks ~${est.chunks}`;
    }
    const steps = document.querySelector('#import-live .import-steps');
    if (steps) steps.innerHTML = stepStates.map(importStepHtml).join('');
    importSetProgress(importProgressValue, true);
  }, 220);

  importCounterTimer = setInterval(() => {
    est.pages += Math.max(1, Math.floor(Math.random() * 2));
    est.words += Math.max(90, Math.floor(Math.random() * 240));
    est.sentences += Math.max(4, Math.floor(Math.random() * 11));
    est.paragraphs += Math.max(1, Math.floor(Math.random() * 4));
    est.tables += Math.max(0, Math.floor(Math.random() * 2));
    est.rows += Math.max(1, Math.floor(Math.random() * 12));
    est.chunks += Math.max(4, Math.floor(Math.random() * 18));
  }, 700);
}

function importStepsFromPayload(payload, vectorPayload) {
  const extraction = payload?.extraction || {};
  const summary = extraction.summary || {};
  const latestVectorRun = Array.isArray(vectorPayload?.runs) && vectorPayload.runs.length
    ? vectorPayload.runs[0]
    : null;

  const steps = [];
  if (payload && payload.ok) {
    const archiveDetail = payload.status === 'duplicate'
      ? 'Duplicate detected; existing archive reused.'
      : 'Document archived and resource record created.';
    steps.push({
      ...IMPORT_STEPS[0],
      state: 'done',
      progress: 100,
      detail: archiveDetail,
      stats: payload?.resource?.digest_sha256 ? `digest ${String(payload.resource.digest_sha256).slice(0, 10)}...` : '',
    });
  } else {
    steps.push({
      ...IMPORT_STEPS[0],
      state: 'error',
      progress: 100,
      detail: payload?.detail || payload?.error || 'Import failed.',
    });
  }

  if (extraction.status === 'extracted') {
    const pageCount = summary.page_count;
    const textWords = summary.text_words ?? 0;
    const textSentences = summary.text_sentences ?? 0;
    const textParagraphs = summary.text_paragraphs ?? 0;
    const tableRows = summary.table_rows_total ?? 0;
    const tableCols = summary.table_cols_total ?? 0;
    const tableCells = summary.table_cells_total ?? 0;
    steps.push({
      ...IMPORT_STEPS[1],
      state: 'done',
      progress: 100,
      detail: pageCount ? `${pageCount} page(s) scanned.` : 'Text extraction completed.',
      stats: `${textWords} words, ${textSentences} sentences, ${textParagraphs} paragraphs`,
    });
    steps.push({
      ...IMPORT_STEPS[2],
      state: 'done',
      progress: 100,
      detail: `${summary.tables_found ?? 0} tables, ${summary.annotations_persisted ?? 0} annotations.`,
      stats: `${tableRows} rows, ${tableCols} cols, ${tableCells} cells`,
    });
    const vectorState = String(
      summary.vector_status
      || extraction?.vector?.status
      || latestVectorRun?.status
      || 'skipped'
    ).toLowerCase();
    const vectorChunksIndexed = summary.vector_chunks_indexed
      ?? extraction?.vector?.chunks_indexed
      ?? latestVectorRun?.chunks_indexed
      ?? 0;
    const vectorChunksTotal = summary.vector_chunks_total
      ?? extraction?.vector?.chunks_total
      ?? latestVectorRun?.chunks_total
      ?? 0;
    const vectorError = summary.vector_error || extraction?.vector?.error || latestVectorRun?.error_message || null;
    if (vectorState === 'failed') {
      steps.push({
        ...IMPORT_STEPS[3],
        state: 'error',
        progress: 100,
        detail: vectorError || 'Vector indexing failed.',
      });
    } else if (vectorState === 'success' || vectorState === 'running') {
      steps.push({
        ...IMPORT_STEPS[3],
        state: 'done',
        progress: 100,
        detail: `${vectorChunksIndexed}/${vectorChunksTotal} chunks indexed.`,
        stats: `${vectorPayload?.qdrant_points ?? 0} total vector points`,
      });
    } else {
      steps.push({
        ...IMPORT_STEPS[3],
        state: 'skipped',
        progress: 100,
        detail: 'Vector indexing not executed.',
      });
    }
    return steps;
  }

  if (extraction.status === 'failed') {
    steps.push({
      ...IMPORT_STEPS[1],
      state: 'error',
      progress: 100,
      detail: extraction.error || 'Extraction failed.',
    });
    steps.push({
      ...IMPORT_STEPS[2],
      state: 'skipped',
      progress: 100,
      detail: 'Skipped due to extraction failure.',
    });
    steps.push({
      ...IMPORT_STEPS[3],
      state: 'skipped',
      progress: 100,
      detail: 'Skipped due to extraction failure.',
    });
    return steps;
  }

  if (extraction.reason === 'already_extracted') {
    const vectorSummary = extraction.vector || null;
    const vectorStatus = String(vectorSummary?.status || '').toLowerCase();
    const vectorRuns = Array.isArray(vectorPayload?.runs) ? vectorPayload.runs : [];
    const words = summary.text_words ?? 0;
    const sentences = summary.text_sentences ?? 0;
    const paragraphs = summary.text_paragraphs ?? 0;
    steps.push({
      ...IMPORT_STEPS[1],
      state: 'done',
      progress: 100,
      detail: 'Existing extraction reused.',
      stats: `run ${extraction.extraction_run_id || 'latest'}  ${words} words  ${sentences} sentences  ${paragraphs} paragraphs`,
    });
    steps.push({
      ...IMPORT_STEPS[2],
      state: 'done',
      progress: 100,
      detail: 'Structured data already available.',
      stats: `${summary.tables_found ?? 0} tables  ${summary.table_rows_total ?? 0} rows  ${summary.table_cols_total ?? 0} cols  ${summary.table_cells_total ?? 0} cells`,
    });
    const hasVectorRuns = vectorRuns.length > 0;
    const vectorStepState = vectorStatus === 'failed'
      ? 'error'
      : ((vectorStatus === 'success' || vectorStatus === 'skipped' || hasVectorRuns) ? 'done' : 'skipped');
    const vectorDetail = vectorStatus === 'failed'
      ? (vectorSummary?.error || 'Vector indexing failed while reusing extraction.')
      : (vectorStatus === 'success'
        ? `${vectorSummary?.chunks_indexed ?? 0}/${vectorSummary?.chunks_total ?? 0} chunks indexed.`
        : (vectorStatus === 'skipped'
          ? 'Existing vector index reused for current extraction.'
          : (hasVectorRuns ? 'Existing vector runs detected.' : 'No vector runs found for this resource yet.')));
    steps.push({
      ...IMPORT_STEPS[3],
      state: vectorStepState,
      progress: 100,
      detail: vectorDetail,
      stats: (vectorSummary && Number.isFinite(Number(vectorSummary?.chunks_total)))
        ? `${vectorSummary?.chunks_indexed ?? 0}/${vectorSummary?.chunks_total ?? 0} chunks`
        : (hasVectorRuns ? `${vectorRuns.length} run(s)` : ''),
    });
    return steps;
  }

  if (extraction.reason === 'media_type_not_extractable') {
    steps.push({ ...IMPORT_STEPS[1], state: 'skipped', progress: 100, detail: 'Media type is not extractable.' });
    steps.push({ ...IMPORT_STEPS[2], state: 'skipped', progress: 100, detail: 'No extraction means no table parsing.' });
    steps.push({ ...IMPORT_STEPS[3], state: 'skipped', progress: 100, detail: 'No extraction means no vector indexing.' });
    return steps;
  }

  steps.push({ ...IMPORT_STEPS[1], state: 'skipped', progress: 100, detail: 'Extraction not attempted.' });
  steps.push({ ...IMPORT_STEPS[2], state: 'skipped', progress: 100, detail: 'Not available.' });
  steps.push({ ...IMPORT_STEPS[3], state: 'skipped', progress: 100, detail: 'Not available.' });
  return steps;
}

function importFinalMetrics(payload, vectorPayload) {
  const extraction = payload?.extraction || {};
  const summary = extraction.summary || {};
  const resource = payload?.resource || {};
  const latestVectorRun = Array.isArray(vectorPayload?.runs) && vectorPayload.runs.length
    ? vectorPayload.runs[0]
    : null;
  const vectorStatus = summary.vector_status || extraction?.vector?.status || latestVectorRun?.status || 'n/a';
  const vectorChunksIndexed = summary.vector_chunks_indexed
    ?? extraction?.vector?.chunks_indexed
    ?? latestVectorRun?.chunks_indexed
    ?? 0;
  const vectorChunksTotal = summary.vector_chunks_total
    ?? extraction?.vector?.chunks_total
    ?? latestVectorRun?.chunks_total
    ?? 0;
  const metrics = [
    { k: 'Import Status', v: payload?.status || 'unknown' },
    { k: 'Media Type', v: resource.media_type || 'n/a' },
    { k: 'Pages', v: summary.page_count ?? 0 },
    { k: 'Words', v: summary.text_words ?? 0 },
    { k: 'Sentences', v: summary.text_sentences ?? 0 },
    { k: 'Paragraphs', v: summary.text_paragraphs ?? 0 },
    { k: 'Tables', v: summary.tables_found ?? 0 },
    { k: 'Table Rows', v: summary.table_rows_total ?? 0 },
    { k: 'Table Cols', v: summary.table_cols_total ?? 0 },
    { k: 'Table Cells', v: summary.table_cells_total ?? 0 },
    { k: 'Segments', v: summary.segments_persisted ?? 0 },
    { k: 'Annotations', v: summary.annotations_persisted ?? 0 },
    { k: 'Vector Status', v: vectorStatus },
    { k: 'Vector Chunks', v: `${vectorChunksIndexed}/${vectorChunksTotal}` },
  ];
  if (resource.download_url) {
    metrics.push({ k: 'Download URL', v: resource.download_url });
  }
  if (resource.source_uri) {
    metrics.push({ k: 'Source URI', v: resource.source_uri });
  }
  if (vectorPayload && vectorPayload.ok) {
    metrics.push({ k: 'Vector Runs', v: Array.isArray(vectorPayload.runs) ? vectorPayload.runs.length : 0 });
    metrics.push({ k: 'Qdrant Points', v: vectorPayload.qdrant_points ?? 0 });
  }
  return metrics;
}

async function importOpenInDatabase(resourceId) {
  if (!resourceId) return;
  setActivePane('database');
  await dbListTables();
  const select = document.getElementById('db-table-select');
  if (select) select.value = 'resources';

  const pageSize = 100;
  let targetOffset = 0;
  try {
    const locate = await callApi(
      'GET',
      `/api/db/table/locate?name=resources&column=id&value=${encodeURIComponent(resourceId)}&page_size=${pageSize}`,
      null,
      null
    );
    if (locate?.ok && locate?.found && Number.isFinite(Number(locate.offset))) {
      targetOffset = Math.max(0, Number(locate.offset));
    }
  } catch (e) {
  }

  const limit = document.getElementById('db-limit');
  if (limit) limit.value = String(pageSize);
  const offset = document.getElementById('db-offset');
  if (offset) offset.value = String(targetOffset);
  await dbViewTable();
  const search = document.getElementById('db-search');
  if (search) {
    search.value = resourceId;
    dbGridState.globalSearch = resourceId;
    if (dbOutputMode() === 'spreadsheet') dbRenderGrid();
  }
}

async function importFinalizeJob(payload, meta) {
  importStopTimers();
  importSetProgress(100, false);
  const basePayload = (payload && typeof payload === 'object') ? payload : {};
  const resourceId = basePayload?.resource?.id || null;
  const extractionPayload = (basePayload.extraction && typeof basePayload.extraction === 'object')
    ? basePayload.extraction
    : null;
  const extractionStatus = extractionPayload ? String(extractionPayload.status || '') : '';
  const needsFallbackExtraction = Boolean(
    basePayload?.ok
      && resourceId
      && (
        !extractionPayload
        || !extractionStatus
        || (extractionStatus === 'skipped' && !extractionPayload.reason)
      )
  );

  let finalizedPayload = basePayload;
  if (needsFallbackExtraction) {
    const status = document.getElementById('import-status-line');
    if (status) status.textContent = 'Running extraction pipeline (fallback)...';
    try {
      const extractPayload = await callApi(
        'POST',
        '/api/extract/run',
        { resource_id: resourceId, profile: 'default' },
        null
      );
      const extractionSummary = extractPayload?.summary || null;
      finalizedPayload = {
        ...basePayload,
        extraction: extractionSummary
          ? { attempted: true, status: 'extracted', summary: extractionSummary, source: 'client_fallback' }
          : { attempted: true, status: 'failed', error: extractPayload?.detail || 'Extraction failed.' },
      };
      const runId = extractionSummary?.run_id;
      if (runId) {
        const vectorIndex = await callApi(
          'POST',
          '/api/vector/index',
          { resource_id: resourceId, extraction_run_id: runId, force: false },
          null
        );
        if (vectorIndex && vectorIndex.ok && vectorIndex.summary) {
          const summary = finalizedPayload.extraction?.summary || {};
          finalizedPayload.extraction.summary = {
            ...summary,
            vector_status: vectorIndex.summary.status,
            vector_chunks_total: vectorIndex.summary.chunks_total,
            vector_chunks_indexed: vectorIndex.summary.chunks_indexed,
            vector_error: vectorIndex.summary.error,
          };
        }
      }
    } catch (e) {
      finalizedPayload = {
        ...basePayload,
        extraction: { attempted: true, status: 'failed', error: String(e), source: 'client_fallback' },
      };
    }
  }

  function hasValue(v) {
    return v !== undefined && v !== null;
  }

  function computeTextStats(text) {
    const content = String(text || '');
    const words = (content.match(/\b\w+\b/g) || []).length;
    const sentences = (content.match(/[^.!?\n]+(?:[.!?]+|$)/g) || [])
      .map((s) => s.trim())
      .filter((s) => s.length > 0)
      .length;
    const paragraphs = content
      .split(/\n\s*\n+/)
      .map((p) => p.trim())
      .filter((p) => p.length > 0)
      .length;
    return { words, sentences, paragraphs };
  }

  function jsonArrayLength(value) {
    if (Array.isArray(value)) return value.length;
    if (typeof value !== 'string') return 0;
    try {
      const parsed = JSON.parse(value);
      return Array.isArray(parsed) ? parsed.length : 0;
    } catch {
      return 0;
    }
  }

  async function enrichExtractionSummary(resourceIdValue, extractionValue) {
    const mayHaveExtractionSummary = extractionValue?.status === 'extracted' || extractionValue?.reason === 'already_extracted';
    if (!resourceIdValue || !mayHaveExtractionSummary) return extractionValue;
    const summaryIn = (extractionValue.summary && typeof extractionValue.summary === 'object')
      ? extractionValue.summary
      : {};
    const summary = { ...summaryIn };
    const runId = summary.run_id || extractionValue?.extraction_run_id || null;

    const missingTextStats = !hasValue(summary.text_words) || !hasValue(summary.text_sentences) || !hasValue(summary.text_paragraphs);
    if (missingTextStats || !hasValue(summary.text_chars)) {
      try {
        let url = `/api/extract/text?resource_id=${encodeURIComponent(resourceIdValue)}`;
        if (runId) url += `&extraction_run_id=${encodeURIComponent(runId)}`;
        const textPayload = await callApi('GET', url, null, null);
        const doc = textPayload?.document_text || null;
        if (doc) {
          const textContent = String(doc.text_content || '');
          const computed = computeTextStats(textContent);
          if (!hasValue(summary.text_chars)) summary.text_chars = hasValue(doc.char_count) ? doc.char_count : textContent.length;
          if (!hasValue(summary.text_words)) summary.text_words = computed.words;
          if (!hasValue(summary.text_sentences)) summary.text_sentences = computed.sentences;
          if (!hasValue(summary.text_paragraphs)) summary.text_paragraphs = computed.paragraphs;
        }
      } catch (e) {
      }
    }

    const missingTableStats = !hasValue(summary.table_rows_total) || !hasValue(summary.table_cols_total) || !hasValue(summary.table_cells_total);
    if (missingTableStats || !hasValue(summary.tables_found)) {
      try {
        const tablesPayload = await callApi(
          'GET',
          `/api/extract/tables?resource_id=${encodeURIComponent(resourceIdValue)}&limit=100000`,
          null,
          null
        );
        const tables = Array.isArray(tablesPayload?.tables) ? tablesPayload.tables : [];
        if (!hasValue(summary.tables_found)) summary.tables_found = tables.length;
        if (missingTableStats) {
          let rows = 0;
          let cols = 0;
          let cells = 0;
          for (const table of tables) {
            rows += jsonArrayLength(table?.row_headers_json ?? table?.row_headers);
            cols += jsonArrayLength(table?.col_headers_json ?? table?.col_headers);
            cells += jsonArrayLength(table?.cells_json ?? table?.cells);
          }
          if (!hasValue(summary.table_rows_total)) summary.table_rows_total = rows;
          if (!hasValue(summary.table_cols_total)) summary.table_cols_total = cols;
          if (!hasValue(summary.table_cells_total)) summary.table_cells_total = cells;
        }
      } catch (e) {
      }
    }

    return { ...extractionValue, summary };
  }

  if (resourceId && finalizedPayload?.extraction) {
    finalizedPayload = {
      ...finalizedPayload,
      extraction: await enrichExtractionSummary(resourceId, finalizedPayload.extraction),
    };
  }

  document.getElementById('out-ingest').textContent = JSON.stringify(finalizedPayload, null, 2);

  let vectorPayload = null;
  if (resourceId) {
    try {
      vectorPayload = await callApi('GET', `/api/vector/status?resource_id=${encodeURIComponent(resourceId)}&limit_runs=10`, null, null);
    } catch (e) {
      vectorPayload = null;
    }
  }

  const steps = importStepsFromPayload(finalizedPayload, vectorPayload);
  const metrics = importFinalMetrics(finalizedPayload, vectorPayload);
  const ok = Boolean(finalizedPayload?.ok);
  const extraction = finalizedPayload?.extraction || {};
  const summary = extraction.summary || {};
  const actions = resourceId
    ? `<div class="row"><button type="button" class="secondary" onclick="importOpenInDatabase('${dbEscapeHtml(resourceId)}')">Open In Database Explorer</button><button type="button" class="secondary" onclick="viewerOpenFromImport('${dbEscapeHtml(resourceId)}')">Open In Document Viewer</button></div>`
    : '';

  const statusLine = ok
    ? `Import complete for ${meta.name || 'document'}.`
    : 'Import failed.';
  const countersParts = [];
  if (summary.page_count !== undefined && summary.page_count !== null) countersParts.push(`Pages ${summary.page_count}`);
  if (summary.text_words !== undefined && summary.text_words !== null) countersParts.push(`Words ${summary.text_words}`);
  if (summary.text_sentences !== undefined && summary.text_sentences !== null) countersParts.push(`Sentences ${summary.text_sentences}`);
  if (summary.text_paragraphs !== undefined && summary.text_paragraphs !== null) countersParts.push(`Paragraphs ${summary.text_paragraphs}`);
  if (summary.tables_found !== undefined && summary.tables_found !== null) countersParts.push(`Tables ${summary.tables_found}`);
  if (summary.table_rows_total !== undefined && summary.table_rows_total !== null) countersParts.push(`Rows ${summary.table_rows_total}`);
  if (summary.table_cols_total !== undefined && summary.table_cols_total !== null) countersParts.push(`Cols ${summary.table_cols_total}`);
  if (summary.table_cells_total !== undefined && summary.table_cells_total !== null) countersParts.push(`Cells ${summary.table_cells_total}`);
  if (summary.vector_chunks_total !== undefined && summary.vector_chunks_total !== null) {
    countersParts.push(`Vector chunks ${summary.vector_chunks_indexed ?? 0}/${summary.vector_chunks_total}`);
  }
  if (!countersParts.length && extraction.reason === 'already_extracted' && extraction?.vector) {
    countersParts.push(`Existing extraction reused`);
    if (extraction.vector.chunks_total !== undefined && extraction.vector.chunks_total !== null) {
      countersParts.push(`Vector chunks ${extraction.vector.chunks_indexed ?? 0}/${extraction.vector.chunks_total}`);
    }
    if (extraction.vector.status) {
      countersParts.push(`Vector status ${extraction.vector.status}`);
    }
  }
  const counters = countersParts.length
    ? countersParts.join('  ')
    : (extraction.reason === 'media_type_not_extractable'
      ? 'No extraction/vectorization for this media type.'
      : 'No extraction summary available.');

  importRenderLive(meta, {
    title: meta.name || 'Import Job',
    meta: `${meta.sourceLabel || 'Import'}  ${finalizedPayload?.resource?.id || 'no resource id'}`,
    statusLine,
    countersLine: counters,
    steps,
    metrics,
    actionsHtml: actions,
    progress: 100,
    progressActive: false,
  });

  const doneTone = ok ? (steps.some((s) => s.state === 'error') ? 'error' : 'ok') : 'error';
  importAddHistory({
    statusTone: doneTone,
    statusLabel: ok ? 'completed' : 'failed',
    name: meta.name || finalizedPayload?.uploaded_filename || finalizedPayload?.resource?.original_filename || 'document',
    summary: resourceId
      ? `resource=${resourceId}  vector=${summary.vector_status || extraction.status || 'n/a'}`
      : (finalizedPayload?.detail || finalizedPayload?.error || 'No resource id'),
  });
  return finalizedPayload;
}

function importStreamInitStepState() {
  const map = {};
  IMPORT_STEPS.forEach((step) => {
    map[step.id] = { state: 'pending', progress: 0, detail: '', stats: '', page_count: null, page_current: null };
  });
  return map;
}

function importStreamStepArray(stepMap) {
  return IMPORT_STEPS.map((step) => ({
    ...step,
    ...(stepMap[step.id] || { state: 'pending', progress: 0, detail: '', stats: '' }),
  }));
}

function importStreamOverallProgress(stepMap) {
  let total = 0;
  let used = 0;
  Object.entries(IMPORT_STREAM_STAGE_WEIGHTS).forEach(([stage, weight]) => {
    const step = stepMap[stage];
    if (!step) return;
    const raw = Number(step.progress);
    const value = Number.isFinite(raw) ? Math.max(0, Math.min(100, raw)) : 0;
    total += value * weight;
    used += weight;
  });
  if (!used) return 0;
  return Math.max(0, Math.min(100, Math.round(total / used)));
}

function importRenderStreamLive(meta, stepMap, statusLine, countersLine='', actionsHtml='') {
  importRenderLive(meta, {
    title: meta.name || 'Import Job',
    meta: `${meta.sourceLabel || 'Import'}  streaming backend progress`,
    statusLine: statusLine || 'Import running...',
    countersLine: countersLine || '',
    steps: importStreamStepArray(stepMap),
    metrics: [],
    actionsHtml,
    progress: importStreamOverallProgress(stepMap),
    progressActive: true,
  });
}

function importApplyStreamStage(stepMap, stagePayload) {
  const stage = stagePayload?.stage;
  if (!stage || !stepMap[stage]) return;
  const stagePageCount = Number(stagePayload?.page_count);
  const stagePageCurrent = Number(stagePayload?.page_current ?? stagePayload?.current_page);
  stepMap[stage] = {
    ...stepMap[stage],
    state: stagePayload?.state || stepMap[stage].state || 'pending',
    progress: Number.isFinite(Number(stagePayload?.progress))
      ? Number(stagePayload.progress)
      : stepMap[stage].progress,
    detail: stagePayload?.detail || stepMap[stage].detail || '',
    stats: stagePayload?.stats || stepMap[stage].stats || '',
    page_count: Number.isFinite(stagePageCount) && stagePageCount > 0
      ? Math.floor(stagePageCount)
      : (stepMap[stage].page_count || null),
    page_current: Number.isFinite(stagePageCurrent) && stagePageCurrent > 0
      ? Math.floor(stagePageCurrent)
      : (stepMap[stage].page_current || null),
  };
  const totalPages = stagePageCount;
  if (Number.isFinite(totalPages) && totalPages > 0) {
    importPreviewPageTotal = Math.max(importPreviewPageTotal || 0, Math.floor(totalPages));
  }
  const currentPage = stagePageCurrent;
  if (Number.isFinite(currentPage) && currentPage > 0) {
    const cap = importPreviewPageTotal || Math.floor(currentPage);
    importPreviewPageCurrent = Math.max(1, Math.min(cap, Math.floor(currentPage)));
  }
}

function importParseSseFrame(frame) {
  if (!frame || !frame.trim()) return null;
  let event = 'message';
  const dataLines = [];
  frame.split(/\r?\n/).forEach((line) => {
    if (line.startsWith('event:')) {
      event = line.slice(6).trim();
      return;
    }
    if (line.startsWith('data:')) {
      dataLines.push(line.slice(5).trimStart());
    }
  });
  const dataRaw = dataLines.join('\n');
  let data;
  try {
    data = dataRaw ? JSON.parse(dataRaw) : {};
  } catch {
    data = { detail: dataRaw };
  }
  return { event, data };
}

async function importOpenStream(url, opts) {
  const attempts = candidateApiUrls(url);
  let lastPayload = null;
  for (const attemptUrl of attempts) {
    const res = await fetch(attemptUrl, opts);
    if (res.status === 404) {
      const contentType = (res.headers.get('content-type') || '').toLowerCase();
      lastPayload = contentType.includes('application/json') ? await res.json() : { detail: await res.text() };
      continue;
    }
    if (!res.ok) {
      const contentType = (res.headers.get('content-type') || '').toLowerCase();
      const payload = contentType.includes('application/json') ? await res.json() : { detail: await res.text() };
      throw new Error(payload?.detail || `HTTP ${res.status}`);
    }
    return res;
  }
  throw new Error(lastPayload?.detail || `Stream endpoint not found for ${url}`);
}

async function importRunWithStreamVisuals(meta, streamUrl, body, isFormData=false, fallbackRequestFn=null) {
  const stepMap = importStreamInitStepState();
  const abortController = new AbortController();
  importActiveStepMap = stepMap;
  importActiveEta = importEtaStart(meta);
  importActiveStreamAbortController = abortController;
  importStopTimers();

  const opts = {
    method: 'POST',
    headers: { Accept: 'text/event-stream' },
    signal: abortController.signal,
  };
  if (body !== null && body !== undefined) {
    if (isFormData) {
      opts.body = body;
    } else {
      opts.headers['Content-Type'] = 'application/json';
      opts.body = JSON.stringify(body);
    }
  }

  let finalPayload = null;
  let statusLine = 'Starting import...';
  let countersLine = '';
  let watchdogTimer = null;
  let lastRenderSignature = '';

  const renderStreamFrame = (force = false) => {
    const eta = importEtaEstimate(stepMap);
    const statusText = importStatusLineWithHeartbeat(statusLine, eta);
    const countersText = importCounterLineWithEta(countersLine, eta);
    const actionsHtml = importLiveQueueActionsHtml();
    const signature = `${Math.round(importStreamOverallProgress(stepMap))}|${statusText}|${countersText}`;
    if (!force && signature === lastRenderSignature) return;
    lastRenderSignature = signature;
    importRenderStreamLive(meta, stepMap, statusText, countersText, actionsHtml);
    if (importDropQueueRunning) importRenderDropQueue();
  };
  renderStreamFrame(true);

  try {
    watchdogTimer = setInterval(() => {
      renderStreamFrame(false);
    }, 1000);

    const response = await importOpenStream(streamUrl, opts);
    if (!response.body) throw new Error('Streaming response body is unavailable.');
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';
    let done = false;
    while (!done) {
      const read = await reader.read();
      done = Boolean(read.done);
      buffer += decoder.decode(read.value || new Uint8Array(), { stream: !done });

      let split = buffer.indexOf('\n\n');
      while (split >= 0) {
        const frame = buffer.slice(0, split);
        buffer = buffer.slice(split + 2);
        split = buffer.indexOf('\n\n');

        const parsed = importParseSseFrame(frame);
        if (!parsed) continue;
        const { event, data } = parsed;
        if (event === 'stage') {
          importApplyStreamStage(stepMap, data || {});
          if (importActiveEta) importActiveEta.lastHeartbeatMs = Date.now();
          const stageLabel = (data?.stage || '').replace(/^\w/, (c) => c.toUpperCase());
          statusLine = data?.detail || (stageLabel ? `${stageLabel} in progress...` : statusLine);
          countersLine = data?.stats || countersLine;
          renderStreamFrame(true);
          continue;
        }
        if (event === 'payload') {
          finalPayload = data || null;
          continue;
        }
        if (event === 'error') {
          throw new Error(data?.error || data?.detail || 'Import stream failed.');
        }
      }
    }
  } catch (e) {
    const isAbortError = Boolean(e) && (
      String(e?.name || '') === 'AbortError'
      || String(e?.code || '') === 'ABORT_ERR'
      || String(e).toLowerCase().includes('abort')
    );
    if (isAbortError && importDropQueueActiveId && importDeferRequestedItemId === importDropQueueActiveId) {
      return {
        ok: false,
        aborted: true,
        deferred: true,
        error: 'Deferred by user.',
      };
    }
    if (fallbackRequestFn) {
      return importRunWithVisuals(meta, fallbackRequestFn);
    }
    throw e;
  } finally {
    if (watchdogTimer) clearInterval(watchdogTimer);
    watchdogTimer = null;
    if (importActiveStreamAbortController === abortController) {
      importActiveStreamAbortController = null;
    }
    importActiveStepMap = null;
    importActiveEta = null;
  }

  if (!finalPayload) {
    if (fallbackRequestFn) {
      return importRunWithVisuals(meta, fallbackRequestFn);
    }
    throw new Error('Import stream finished without a payload.');
  }
  const finalizedPayload = await importFinalizeJob(finalPayload, meta);
  return {
    ok: Boolean(finalizedPayload?.ok),
    payload: finalizedPayload,
  };
}

async function importRunWithVisuals(meta, requestFn) {
  importStartAnimatedJob(meta);
  try {
    const payload = await requestFn();
    const finalizedPayload = await importFinalizeJob(payload, meta);
    return {
      ok: Boolean(finalizedPayload?.ok),
      payload: finalizedPayload,
    };
  } catch (e) {
    importStopTimers();
    const message = String(e);
    importRenderLive(meta, {
      title: meta.name || 'Import Job',
      meta: `${meta.sourceLabel || 'Import'}  failed`,
      statusLine: 'Import failed before completion.',
      countersLine: '',
      steps: [
        { ...IMPORT_STEPS[0], state: 'error', detail: message },
        { ...IMPORT_STEPS[1], state: 'skipped', detail: 'Skipped' },
        { ...IMPORT_STEPS[2], state: 'skipped', detail: 'Skipped' },
        { ...IMPORT_STEPS[3], state: 'skipped', detail: 'Skipped' },
      ],
      metrics: [],
      progress: 100,
      progressActive: false,
    });
    document.getElementById('out-ingest').textContent = JSON.stringify({ error: message }, null, 2);
    importAddHistory({
      statusTone: 'error',
      statusLabel: 'failed',
      name: meta.name || 'document',
      summary: message,
    });
    return { ok: false, error: message };
  }
}

async function ingestPath() {
  const path = (document.getElementById('ingest-path').value || '').trim();
  if (!path) {
    document.getElementById('out-ingest').textContent = JSON.stringify({ error: 'Provide an absolute file path.' }, null, 2);
    return;
  }
  await importRunWithStreamVisuals(
    { name: importPathBasename(path), sourceLabel: 'Path Import', path },
    '/api/ingest/path/stream',
    { path },
    false,
    () => callApi('POST', '/api/ingest/path', { path }, null)
  );
}

async function listResources() {
  const limit = encodeURIComponent(document.getElementById('resources-limit').value || '20');
  const payload = await callApi('GET', `/api/resources?limit=${limit}`, null, 'out-ingest');
  if (!payload || payload.ok !== true || !Array.isArray(payload.resources)) return;
  importHistoryItems = payload.resources.slice(0, 12).map((r) => ({
    statusTone: 'neutral',
    statusLabel: 'resource',
    name: r.original_filename || r.id,
    summary: `id=${r.id}  digest=${String(r.digest_sha256 || '').slice(0, 12)}...`,
  }));
  importRenderHistory();
}

async function importBib() {
  await callApi('POST', '/api/refs/import-bib', {
    bib_path: document.getElementById('bib-path').value
  }, 'out-refs');
}

async function linkReference() {
  await callApi('POST', '/api/refs/link-resource', {
    cite_id: document.getElementById('link-cite-id').value,
    resource_digest: document.getElementById('link-digest').value
  }, 'out-refs');
}

async function extractRun() {
  await callApi('POST', '/api/extract/run', {
    resource_id: document.getElementById('extract-resource-id').value || null,
    resource_digest: document.getElementById('extract-digest').value || null,
    profile: 'default'
  }, 'out-extract');
}

async function extractTables() {
  const id = encodeURIComponent(document.getElementById('extract-tables-id').value || '');
  const digest = encodeURIComponent(document.getElementById('extract-tables-digest').value || '');
  const qs = id ? `resource_id=${id}` : `resource_digest=${digest}`;
  await callApi('GET', `/api/extract/tables?${qs}`, null, 'out-extract');
}

function extractionInspectorError(message) {
  document.getElementById('out-extract-inspector').textContent = JSON.stringify({ error: message }, null, 2);
  extractionInspectorSetCardsHtml('<p class="small err">' + dbEscapeHtml(message) + '</p>');
}

let extractionInspectorCopyPayloads = [];

function extractionInspectorSetCardsHtml(html) {
  const container = document.getElementById('extract-inspector-list');
  if (!container) return;
  container.innerHTML = html;
  container.querySelectorAll('[data-copy-idx]').forEach((button) => {
    button.addEventListener('click', async () => {
      const idx = Number(button.getAttribute('data-copy-idx'));
      await extractionInspectorCopyPayloadByIndex(idx);
    });
  });
}

function extractionInspectorSetCopyStatus(message, isError=false) {
  const el = document.getElementById('extract-inspector-copy-status');
  if (!el) return;
  el.textContent = message || '';
  if (isError) {
    el.classList.add('err');
  } else {
    el.classList.remove('err');
  }
}

async function extractionInspectorCopyText(text) {
  if (navigator.clipboard && navigator.clipboard.writeText) {
    await navigator.clipboard.writeText(text);
    return;
  }
  const area = document.createElement('textarea');
  area.value = text;
  area.setAttribute('readonly', 'readonly');
  area.style.position = 'absolute';
  area.style.left = '-9999px';
  document.body.appendChild(area);
  area.select();
  document.execCommand('copy');
  document.body.removeChild(area);
}

async function extractionInspectorCopyPayloadByIndex(index) {
  if (!Number.isInteger(index) || index < 0 || index >= extractionInspectorCopyPayloads.length) {
    extractionInspectorSetCopyStatus('Unable to copy selector JSON: payload missing.', true);
    return;
  }
  const payload = extractionInspectorCopyPayloads[index];
  try {
    await extractionInspectorCopyText(JSON.stringify(payload, null, 2));
    extractionInspectorSetCopyStatus('Copied selector JSON to clipboard.');
  } catch (e) {
    extractionInspectorSetCopyStatus('Failed to copy selector JSON: ' + String(e), true);
  }
}

function extractionInspectorResetCards(message='No inspector items loaded yet.') {
  extractionInspectorCopyPayloads = [];
  extractionInspectorSetCardsHtml('<p class="small">' + dbEscapeHtml(message) + '</p>');
  extractionInspectorSetCopyStatus('');
}

function extractionInspectorSegmentSelector(segment) {
  return {
    type: 'TextPositionSelector',
    start: Number(segment.start_offset),
    end: Number(segment.end_offset),
    segment_type: segment.segment_type || null,
    extraction_run_id: segment.extraction_run_id || null,
  };
}

function extractionInspectorAnnotationSelector(annotation) {
  const spans = Array.isArray(annotation.spans)
    ? annotation.spans.map((s) => ({
        start: Number(s.start),
        end: Number(s.end),
      }))
    : [];
  const selector = {
    type: 'TextAnnotationSelector',
    annotation_id: annotation.id,
    layer: annotation.layer || null,
    category: annotation.category || null,
    label: annotation.label || null,
    spans,
  };
  if (spans.length === 1) {
    selector.start = spans[0].start;
    selector.end = spans[0].end;
  }
  return selector;
}

function extractionInspectorRenderSegments(data) {
  const segments = Array.isArray(data?.segments) ? data.segments : [];
  if (!segments.length) {
    extractionInspectorResetCards('No segments matched the current inspector query.');
    return;
  }
  extractionInspectorCopyPayloads = segments.map((segment) => extractionInspectorSegmentSelector(segment));
  const html = segments
    .map((segment, idx) => {
      const start = Number(segment.start_offset);
      const end = Number(segment.end_offset);
      const length = Number.isFinite(start) && Number.isFinite(end) ? Math.max(0, end - start) : '';
      return `
        <article class="inspector-card">
          <h4>${dbEscapeHtml(segment.segment_type || 'segment')} (#${idx + 1})</h4>
          <p class="inspector-meta">start=${dbEscapeHtml(String(segment.start_offset))}, end=${dbEscapeHtml(String(segment.end_offset))}, len=${dbEscapeHtml(String(length))}, page=${dbEscapeHtml(String(segment.page_index ?? 'n/a'))}</p>
          <div class="inspector-copy-row">
            <button class="secondary" type="button" data-copy-idx="${idx}">Copy Selector JSON</button>
          </div>
        </article>
      `;
    })
    .join('');
  extractionInspectorSetCardsHtml(html);
  extractionInspectorSetCopyStatus('Ready: click "Copy Selector JSON" on any segment.');
}

function extractionInspectorRenderAnnotations(data) {
  const annotations = Array.isArray(data?.annotations) ? data.annotations : [];
  if (!annotations.length) {
    extractionInspectorResetCards('No annotations matched the current inspector query.');
    return;
  }
  extractionInspectorCopyPayloads = annotations.map((annotation) =>
    extractionInspectorAnnotationSelector(annotation)
  );
  const html = annotations
    .map((annotation, idx) => {
      const spans = Array.isArray(annotation.spans) ? annotation.spans.length : 0;
      return `
        <article class="inspector-card">
          <h4>${dbEscapeHtml(annotation.layer || 'annotation')} / ${dbEscapeHtml(annotation.category || 'uncategorized')} (#${idx + 1})</h4>
          <p class="inspector-meta">label=${dbEscapeHtml(String(annotation.label || ''))}, spans=${dbEscapeHtml(String(spans))}, source=${dbEscapeHtml(String(annotation.source || 'n/a'))}</p>
          <div class="inspector-copy-row">
            <button class="secondary" type="button" data-copy-idx="${idx}">Copy Selector JSON</button>
          </div>
        </article>
      `;
    })
    .join('');
  extractionInspectorSetCardsHtml(html);
  extractionInspectorSetCopyStatus('Ready: click "Copy Selector JSON" on any annotation.');
}

function extractionInspectorTargetQuery() {
  const id = (document.getElementById('inspect-resource-id').value || '').trim();
  const digest = (document.getElementById('inspect-resource-digest').value || '').trim();
  const runId = (document.getElementById('inspect-run-id').value || '').trim();

  if (!id && !digest) {
    extractionInspectorError('Provide inspector resource ID or digest.');
    return null;
  }

  let qs = id
    ? `resource_id=${encodeURIComponent(id)}`
    : `resource_digest=${encodeURIComponent(digest)}`;
  if (runId) qs += `&extraction_run_id=${encodeURIComponent(runId)}`;
  return qs;
}

function extractionInspectorLimit(defaultValue='200') {
  const raw = (document.getElementById('inspect-limit').value || defaultValue).trim();
  const parsed = Number(raw);
  if (!Number.isFinite(parsed) || parsed <= 0) return defaultValue;
  return String(Math.floor(parsed));
}

async function extractInspectorText() {
  const qs = extractionInspectorTargetQuery();
  if (!qs) return;
  const data = await callApi('GET', `/api/extract/text?${qs}`, null, 'out-extract-inspector');
  if (!data || data.ok !== true || !data.document_text) {
    extractionInspectorResetCards('No extracted text found for this resource/run.');
    return;
  }
  const meta = data.document_text;
  extractionInspectorResetCards(
    `Loaded text: ${meta.char_count || 0} chars (digest ${meta.text_digest_sha256 || 'n/a'}).`
  );
}

async function extractInspectorSegments() {
  const qs = extractionInspectorTargetQuery();
  if (!qs) return;
  const segmentType = (document.getElementById('inspect-segment-type').value || '').trim();
  const limit = extractionInspectorLimit('200');
  let url = `/api/extract/segments?${qs}&limit=${encodeURIComponent(limit)}`;
  if (segmentType) url += `&segment_type=${encodeURIComponent(segmentType)}`;
  const data = await callApi('GET', url, null, 'out-extract-inspector');
  if (!data || data.ok !== true) {
    extractionInspectorError(data?.detail || 'Failed to load segments.');
    return;
  }
  extractionInspectorRenderSegments(data);
}

async function extractInspectorAnnotations() {
  const qs = extractionInspectorTargetQuery();
  if (!qs) return;
  const layer = (document.getElementById('inspect-layer').value || '').trim();
  const category = (document.getElementById('inspect-category').value || '').trim();
  const limit = extractionInspectorLimit('200');
  let url = `/api/extract/annotations?${qs}&limit=${encodeURIComponent(limit)}`;
  if (layer) url += `&layer=${encodeURIComponent(layer)}`;
  if (category) url += `&category=${encodeURIComponent(category)}`;
  const data = await callApi('GET', url, null, 'out-extract-inspector');
  if (!data || data.ok !== true) {
    extractionInspectorError(data?.detail || 'Failed to load annotations.');
    return;
  }
  extractionInspectorRenderAnnotations(data);
}

function extractionInspectorDumpLimit(id, fallback) {
  const raw = (document.getElementById(id).value || String(fallback)).trim();
  const parsed = Number(raw);
  if (!Number.isFinite(parsed) || parsed <= 0) return String(fallback);
  return String(Math.floor(parsed));
}

async function extractInspectorDump() {
  const qs = extractionInspectorTargetQuery();
  if (!qs) return;
  const segmentLimit = extractionInspectorDumpLimit('inspect-segment-limit', 2000);
  const annotationLimit = extractionInspectorDumpLimit('inspect-annotation-limit', 2000);
  const tableLimit = extractionInspectorDumpLimit('inspect-table-limit', 500);
  const url = `/api/extract/dump?${qs}&segment_limit=${encodeURIComponent(segmentLimit)}&annotation_limit=${encodeURIComponent(annotationLimit)}&table_limit=${encodeURIComponent(tableLimit)}`;
  const data = await callApi('GET', url, null, 'out-extract-inspector');
  if (!data || data.ok !== true || !data.dump) {
    extractionInspectorError(data?.detail || 'Failed to load extraction dump.');
    return;
  }
  const dump = data.dump;
  extractionInspectorResetCards(
    `Dump loaded: tables=${(dump.tables || []).length}, segments=${(dump.segments || []).length}, annotations=${(dump.annotations || []).length}.`
  );
}

async function importClaims() {
  await callApi('POST', '/api/claims/import', {
    file_path: document.getElementById('claims-file').value,
    fmt: document.getElementById('claims-format').value,
    claim_set: document.getElementById('claim-set').value
  }, 'out-claims');
}

async function listClaims() {
  const set = encodeURIComponent(document.getElementById('claims-list-set').value || '');
  const url = set ? `/api/claims?claim_set=${set}` : '/api/claims';
  await callApi('GET', url, null, 'out-claims');
}

async function bindAdd() {
  let selectors;
  try {
    selectors = JSON.parse(document.getElementById('bind-selectors').value);
  } catch (e) {
    document.getElementById('out-bind').textContent = JSON.stringify({error: 'Invalid selectors JSON'}, null, 2);
    return;
  }
  await callApi('POST', '/api/bind/add', {
    claim_id: document.getElementById('bind-claim-id').value,
    resource_id: document.getElementById('bind-resource-id').value || null,
    resource_digest: document.getElementById('bind-digest').value || null,
    role: document.getElementById('bind-role').value,
    selectors
  }, 'out-bind');
}

async function bindValidate() {
  await callApi('POST', '/api/bind/validate', {
    claim_id: document.getElementById('bind-claim-id').value
  }, 'out-bind');
}

async function verifyClaim() {
  await callApi('POST', '/api/verify/claim', {
    claim_id: document.getElementById('verify-claim-id').value,
    policy: 'strict'
  }, 'out-verify');
}

async function verifySet() {
  await callApi('POST', '/api/verify/set', {
    claim_set: document.getElementById('verify-claim-set').value,
    policy: 'strict'
  }, 'out-verify');
}

async function reportVerification() {
  const run = encodeURIComponent(document.getElementById('report-run-id').value);
  const jsonOut = encodeURIComponent(document.getElementById('report-json-out').value || '');
  const mdOut = encodeURIComponent(document.getElementById('report-md-out').value || '');
  let qs = `run_id=${run}`;
  if (jsonOut) qs += `&json_out=${jsonOut}`;
  if (mdOut) qs += `&md_out=${mdOut}`;
  await callApi('GET', `/api/report/verification?${qs}`, null, 'out-verify');
}

async function traceClaim() {
  const claim = encodeURIComponent(document.getElementById('trace-claim-id').value);
  await callApi('GET', `/api/trace/claim?claim_id=${claim}`, null, 'out-trace');
}

async function traceResource() {
  const rid = document.getElementById('trace-resource-id').value;
  const digest = document.getElementById('trace-resource-digest').value;
  const qs = rid ? `resource_id=${encodeURIComponent(rid)}` : `resource_digest=${encodeURIComponent(digest)}`;
  await callApi('GET', `/api/trace/resource?${qs}`, null, 'out-trace');
}

async function traceCitation() {
  const cite = encodeURIComponent(document.getElementById('trace-cite-id').value);
  await callApi('GET', `/api/trace/citation?cite_id=${cite}`, null, 'out-trace');
}

async function addProposition() {
  let proposition;
  try {
    proposition = JSON.parse(document.getElementById('ceapf-prop').value);
  } catch (e) {
    document.getElementById('out-ceapf').textContent = JSON.stringify({error: 'Invalid proposition JSON'}, null, 2);
    return;
  }
  const data = await callApi('POST', '/api/ceapf/proposition', { proposition }, 'out-ceapf');
  if (data.proposition_id) document.getElementById('ceapf-prop-id').value = data.proposition_id;
}

async function addAssertion() {
  const data = await callApi('POST', '/api/ceapf/assertion', {
    proposition_id: document.getElementById('ceapf-prop-id').value,
    asserting_agent: document.getElementById('ceapf-agent').value,
    modality: document.getElementById('ceapf-modality').value,
    evidence_id: null
  }, 'out-ceapf');
  if (data.assertion_id) document.getElementById('ceapf-from-id').value = data.assertion_id;
}

async function addRelation() {
  await callApi('POST', '/api/ceapf/relation', {
    relation_type: document.getElementById('ceapf-rel-type').value,
    from_node_type: document.getElementById('ceapf-from-type').value,
    from_node_id: document.getElementById('ceapf-from-id').value,
    to_node_type: document.getElementById('ceapf-to-type').value,
    to_node_id: document.getElementById('ceapf-to-id').value || document.getElementById('ceapf-prop-id').value
  }, 'out-ceapf');
}

async function listPropositions() {
  await callApi('GET', '/api/ceapf/propositions', null, 'out-ceapf');
}

async function runMassImport() {
  const maxRaw = document.getElementById('pipe-max').value.trim();
  const root = (document.getElementById('pipe-root').value || '').trim();
  if (!root) {
    document.getElementById('out-ingest').textContent = JSON.stringify({ error: 'Provide a root path for mass import.' }, null, 2);
    return;
  }
  importStartAnimatedJob({
    name: importPathBasename(root),
    sourceLabel: 'Mass Import',
  });
  let payload;
  try {
    payload = await callApi('POST', '/api/import/mass', {
      root,
      max_files: maxRaw ? Number(maxRaw) : null,
      skip_extraction: document.getElementById('pipe-skip').value === 'true',
      extract_timeout_seconds: Number(document.getElementById('pipe-timeout').value || '300')
    }, 'out-ingest');
  } catch (e) {
    importStopTimers();
    const message = String(e);
    importRenderLive(
      { name: importPathBasename(root), sourceLabel: 'Mass Import' },
      {
        title: `Mass Import: ${importPathBasename(root)}`,
        meta: 'Recursive import run failed.',
        statusLine: 'Mass import failed before completion.',
        countersLine: '',
        steps: [
          { ...IMPORT_STEPS[0], state: 'error', detail: message },
          { ...IMPORT_STEPS[1], state: 'skipped', detail: 'Skipped' },
          { ...IMPORT_STEPS[2], state: 'skipped', detail: 'Skipped' },
          { ...IMPORT_STEPS[3], state: 'skipped', detail: 'Skipped' },
        ],
        metrics: [],
        progress: 100,
        progressActive: false,
      }
    );
    importAddHistory({
      statusTone: 'error',
      statusLabel: 'failed',
      name: importPathBasename(root),
      summary: message,
    });
    return;
  }
  importStopTimers();

  const stats = payload?.stats || {};
  importRenderLive(
    { name: importPathBasename(root), sourceLabel: 'Mass Import' },
    {
      title: `Mass Import: ${importPathBasename(root)}`,
      meta: 'Recursive import run complete.',
      statusLine: payload?.ok ? 'Mass import completed.' : 'Mass import failed.',
      countersLine: `Processed ${stats.processed ?? 0} file(s), extracted ${stats.extracted ?? 0}, failures ${stats.failed ?? 0}.`,
      steps: [
        { ...IMPORT_STEPS[0], state: 'done', detail: `${stats.ingested ?? 0} ingested, ${stats.duplicates ?? 0} duplicates.` },
        { ...IMPORT_STEPS[1], state: (stats.extracted ?? 0) > 0 ? 'done' : 'skipped', detail: `${stats.extracted ?? 0} extracted.` },
        { ...IMPORT_STEPS[2], state: 'done', detail: 'Batch summaries written to log/state files.' },
        { ...IMPORT_STEPS[3], state: 'done', detail: 'Vector indexing occurs for extracted resources.' },
      ],
      metrics: [
        { k: 'Candidates', v: stats.candidates ?? 0 },
        { k: 'Processed', v: stats.processed ?? 0 },
        { k: 'Extracted', v: stats.extracted ?? 0 },
        { k: 'Failed', v: stats.failed ?? 0 },
      ],
      progress: 100,
      progressActive: false,
    }
  );
  importAddHistory({
    statusTone: payload?.ok ? ((stats.failed ?? 0) > 0 ? 'warn' : 'ok') : 'error',
    statusLabel: payload?.ok ? 'mass run' : 'failed',
    name: importPathBasename(root),
    summary: `processed=${stats.processed ?? 0} extracted=${stats.extracted ?? 0} failed=${stats.failed ?? 0}`,
  });
}

function importDateMs(value) {
  if (!value) return null;
  const ts = Date.parse(String(value));
  return Number.isFinite(ts) ? ts : null;
}

function importStatusFromServer(status) {
  const normalized = String(status || '').toLowerCase();
  if (normalized === 'queued') return 'pending';
  if (normalized === 'processing') return 'processing';
  if (normalized === 'done') return 'done';
  if (normalized === 'failed') return 'failed';
  return 'pending';
}

function importStepMapFromServer(progressObj) {
  const safeProgress = (progressObj && typeof progressObj === 'object') ? progressObj : {};
  const rawMap = (safeProgress.step_map && typeof safeProgress.step_map === 'object') ? safeProgress.step_map : {};
  const stepMap = importStreamInitStepState();
  IMPORT_STEPS.forEach((step) => {
    const raw = (rawMap[step.id] && typeof rawMap[step.id] === 'object') ? rawMap[step.id] : {};
    stepMap[step.id] = {
      state: String(raw.state || stepMap[step.id].state || 'pending'),
      progress: Number.isFinite(Number(raw.progress))
        ? Number(raw.progress)
        : stepMap[step.id].progress,
      detail: String(raw.detail || stepMap[step.id].detail || ''),
      stats: String(raw.stats || stepMap[step.id].stats || ''),
      page_count: Number.isFinite(Number(raw.page_count)) && Number(raw.page_count) > 0
        ? Math.floor(Number(raw.page_count))
        : null,
      page_current: Number.isFinite(Number(raw.page_current ?? raw.current_page)) && Number(raw.page_current ?? raw.current_page) > 0
        ? Math.floor(Number(raw.page_current ?? raw.current_page))
        : null,
    };
  });
  return stepMap;
}

function importApplyServerQueueState(payload) {
  const jobs = Array.isArray(payload?.jobs) ? payload.jobs : [];
  importDropQueue = jobs.map((job, idx) => {
    const status = importStatusFromServer(job?.status);
    const startedAtMs = importDateMs(job?.started_at);
    const finishedAtMs = importDateMs(job?.finished_at);
    const elapsedMs = (startedAtMs && finishedAtMs) ? Math.max(0, finishedAtMs - startedAtMs) : null;
    return {
      id: String(job?.id || `job-${idx}`),
      name: String(job?.original_filename || `Queued File ${idx + 1}`),
      sizeBytes: Number(job?.size_bytes || 0),
      status,
      detail: String(job?.detail || ''),
      queuedAtMs: importDateMs(job?.created_at),
      startedAtMs,
      finishedAtMs,
      elapsedMs,
      resourceId: job?.resource_id || null,
      progress: job?.progress && typeof job.progress === 'object' ? job.progress : null,
      previewUrl: `/api/import/queue/jobs/${encodeURIComponent(String(job?.id || `job-${idx}`))}/content`,
    };
  });

  const queueSummary = payload?.queue && typeof payload.queue === 'object' ? payload.queue : {};
  importDropQueueRunning = Number(queueSummary.processing || 0) > 0 || Number(queueSummary.queued || 0) > 0;
  const processingItem = importDropQueue.find((item) => item.status === 'processing') || null;
  importDropQueueActiveId = processingItem ? processingItem.id : null;
  importDeferRequestedItemId = null;

  importRenderDropQueue();
  importRenderLiveFromServerQueue(payload);
}

function importRenderLiveFromServerQueue(payload) {
  if (importActiveStreamAbortController) return;
  const jobs = Array.isArray(payload?.jobs) ? payload.jobs : [];
  if (!jobs.length) return;
  const processing = jobs.find((job) => String(job?.status || '').toLowerCase() === 'processing') || null;
  const target = processing || jobs[jobs.length - 1];
  if (!target) return;

  const stepMap = importStepMapFromServer(target?.progress);
  const statusLine = String(target?.progress?.status_line || target?.detail || '');
  const countersLine = String(target?.progress?.counters_line || '');
  const queueJobId = String(target?.id || '');
  const meta = {
    name: String(target?.original_filename || 'Background Import'),
    sourceLabel: 'Background Queue',
    queueJobId,
    previewUrl: queueJobId ? `/api/import/queue/jobs/${encodeURIComponent(queueJobId)}/content` : '',
  };
  importRenderLive(meta, {
    title: meta.name || 'Background Import',
    meta: `Background queue  job ${String(target?.id || '').slice(0, 8)}`,
    statusLine: statusLine || (processing ? 'Import running in background...' : 'Import finished in background.'),
    countersLine,
    steps: importStreamStepArray(stepMap),
    metrics: [],
    progress: importStreamOverallProgress(stepMap),
    progressActive: Boolean(processing),
  });
}

async function importRefreshServerQueue(force = false) {
  if (importQueuePollInFlight && !force) return;
  importQueuePollInFlight = true;
  try {
    const payload = await callApi('GET', '/api/import/queue/status?limit=500', null, null);
    if (payload?.ok) importApplyServerQueueState(payload);
  } catch (err) {
    if (force) {
      console.warn('Unable to refresh background import queue state.', err);
    }
  } finally {
    importQueuePollInFlight = false;
  }
}

function importStartServerQueuePolling() {
  if (importQueuePollTimer) return;
  importRefreshServerQueue(true);
  importQueuePollTimer = setInterval(() => {
    importRefreshServerQueue(false);
  }, 2500);
}

async function importQueueEnqueueFiles(fileList) {
  const files = Array.from(fileList || []).filter((file) => file && typeof file.name === 'string');
  if (!files.length) return;
  for (const file of files) {
    let message = '';
    try {
      const fd = new FormData();
      fd.append('file', file);
      const payload = await callApi('POST', '/api/import/queue/enqueue-upload', fd, null, true);
      if (!payload?.ok) {
        message = String(payload?.detail || payload?.error || 'Failed to enqueue file.');
      }
    } catch (err) {
      message = String(err || 'Failed to enqueue file.');
    }
    if (message) {
      importAddHistory({
        statusTone: 'error',
        statusLabel: 'failed',
        name: file.name || 'document',
        summary: message,
      });
    }
  }
  await importRefreshServerQueue(true);
}

async function importProcessDropQueue() {
  await importRefreshServerQueue(true);
}

const dz = document.getElementById('dropzone');
function prevent(e) { e.preventDefault(); e.stopPropagation(); }
['dragenter','dragover','dragleave','drop'].forEach(evt => dz.addEventListener(evt, prevent));
['dragenter','dragover'].forEach(evt => dz.addEventListener(evt, () => dz.classList.add('drag')));
['dragleave','drop'].forEach(evt => dz.addEventListener(evt, () => dz.classList.remove('drag')));
dz.addEventListener('drop', async (e) => {
  const files = e.dataTransfer.files;
  if (!files || !files.length) return;
  try {
    await importQueueEnqueueFiles(files);
  } catch (err) {
    importAddHistory({
      statusTone: 'error',
      statusLabel: 'failed',
      name: 'drag-and-drop batch',
      summary: String(err || 'Failed to enqueue dropped files.'),
    });
  }
});

document.getElementById('help-modal').addEventListener('click', (e) => {
  if (e.target.id === 'help-modal') closeHelp();
});
initTheme();
initWorkspaceNav();
installHelpButtons();
initDbExplorer();
initDocumentViewer();
initResizableOutputs();
dbListTables();
loadDashboard();
vectorStatus();
importStartServerQueuePolling();
</script>
</body>
</html>
