<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Stemma Codicum</title>
  <meta name="theme-color" content="#1d4ed8" />
  <meta name="msapplication-TileColor" content="#1d4ed8" />
  <meta name="msapplication-TileImage" content="/static/icons/mstile-150x150.png" />
  <meta name="msapplication-config" content="/browserconfig.xml" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Stemma Codicum" />
  <!-- Standard favicon support -->
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
  <!-- PNG favicon for modern browsers -->
  <link rel="icon" type="image/png" sizes="16x16" href="/static/icons/favicon-16x16.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="/static/icons/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="48x48" href="/static/icons/favicon-48x48.png" />
  <!-- Apple touch icon for Safari bookmarks and home screen -->
  <link rel="apple-touch-icon" href="/static/icons/apple-touch-icon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/static/icons/apple-touch-icon.png" />
  <!-- Web manifest for PWA support -->
  <link rel="manifest" href="/site.webmanifest" />
  <style>
    :root {
      --font-display: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Arial, sans-serif;
      --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Arial, sans-serif;
      --font-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      --bg: #f4f6f9;
      --card: #ffffff;
      --text: #111827;
      --muted: #5f6b7a;
      --accent: #2563eb;
      --accent-2: #1d4ed8;
      --border: #dbe3ee;
      --error: #b42318;
      --button-secondary-bg: #e5ebf5;
      --button-secondary-text: #1f2a38;
      --pre-bg: #0f172a;
      --pre-fg: #dbeafe;
      --drop-bg: #f8fafd;
      --drop-drag-bg: #eef2f8;
      --help-overlay: rgba(8, 12, 18, 0.54);
      --help-panel-bg: #ffffff;
      --help-code-bg: #eef2f8;
      --help-code-fg: #111827;
      --help-icon-bg: #edf1f7;
      --help-icon-fg: #334155;
      --hero-grad-start: #f9fbfe;
      --hero-grad-end: #f9fbfe;
      --surface-tint: rgba(255, 255, 255, 0.9);
      --surface-shadow: 0 8px 20px rgba(15, 23, 42, 0.06);
      --surface-shadow-soft: 0 2px 8px rgba(15, 23, 42, 0.05);
      --focus-ring: 0 0 0 3px rgba(37, 99, 235, 0.22);
    }
    body[data-theme="harmonious-light"] {
      --bg: #f4f6f9;
      --card: #ffffff;
      --text: #111827;
      --muted: #5f6b7a;
      --accent: #2563eb;
      --accent-2: #1d4ed8;
      --border: #dbe3ee;
      --button-secondary-bg: #e5ebf5;
      --button-secondary-text: #1f2a38;
      --pre-bg: #0f172a;
      --pre-fg: #dbeafe;
      --drop-bg: #f8fafd;
      --drop-drag-bg: #eef2f8;
      --help-overlay: rgba(8, 12, 18, 0.54);
      --help-panel-bg: #ffffff;
      --help-code-bg: #eef2f8;
      --help-code-fg: #111827;
      --help-icon-bg: #edf1f7;
      --help-icon-fg: #334155;
      --hero-grad-start: #f9fbfe;
      --hero-grad-end: #f9fbfe;
      --surface-tint: rgba(255, 255, 255, 0.9);
      --surface-shadow: 0 8px 20px rgba(15, 23, 42, 0.06);
      --surface-shadow-soft: 0 2px 8px rgba(15, 23, 42, 0.05);
      --focus-ring: 0 0 0 3px rgba(37, 99, 235, 0.22);
    }
    body[data-theme="restful-dark"] {
      --bg: #0d1117;
      --card: #151b23;
      --text: #e6edf5;
      --muted: #99a8bb;
      --accent: #5b8cff;
      --accent-2: #7c89ff;
      --border: #273142;
      --button-secondary-bg: #202a39;
      --button-secondary-text: #dce6f5;
      --pre-bg: #0a0f16;
      --pre-fg: #d8e5f8;
      --drop-bg: #111a25;
      --drop-drag-bg: #172230;
      --help-overlay: rgba(2, 5, 9, 0.76);
      --help-panel-bg: #151b23;
      --help-code-bg: #1f2937;
      --help-code-fg: #e6edf5;
      --help-icon-bg: #273244;
      --help-icon-fg: #f4f8ff;
      --hero-grad-start: #151b23;
      --hero-grad-end: #151b23;
      --surface-tint: rgba(255, 255, 255, 0.02);
      --surface-shadow: 0 10px 24px rgba(0, 0, 0, 0.3);
      --surface-shadow-soft: 0 4px 12px rgba(0, 0, 0, 0.22);
      --focus-ring: 0 0 0 3px rgba(91, 140, 255, 0.34);
    }
    body[data-theme="sunset-paper"] {
      --bg: #f8f4ee;
      --card: #fffdfa;
      --text: #30262c;
      --muted: #6f6168;
      --accent: #c35c2c;
      --accent-2: #9f4a24;
      --border: #eadfd5;
      --button-secondary-bg: #eee4dd;
      --button-secondary-text: #3f343a;
      --pre-bg: #2e242e;
      --pre-fg: #f4e8f2;
      --drop-bg: #fcf4eb;
      --drop-drag-bg: #f8ebde;
      --help-overlay: rgba(30, 17, 20, 0.62);
      --help-panel-bg: #fffdfa;
      --help-code-bg: #f6ece6;
      --help-code-fg: #30262c;
      --help-icon-bg: #f2e4d8;
      --help-icon-fg: #594146;
      --hero-grad-start: #fffdfa;
      --hero-grad-end: #fffdfa;
      --surface-tint: rgba(255, 253, 250, 0.92);
      --surface-shadow: 0 8px 20px rgba(66, 42, 49, 0.1);
      --surface-shadow-soft: 0 3px 10px rgba(66, 42, 49, 0.07);
      --focus-ring: 0 0 0 3px rgba(195, 92, 44, 0.24);
    }
    body[data-theme="forest-mist"] {
      --bg: #f1f6f3;
      --card: #fbfffd;
      --text: #1f302a;
      --muted: #526860;
      --accent: #1f8f63;
      --accent-2: #197552;
      --border: #d2e2d9;
      --button-secondary-bg: #e2efe8;
      --button-secondary-text: #264138;
      --pre-bg: #132b26;
      --pre-fg: #c8f2e7;
      --drop-bg: #effaf5;
      --drop-drag-bg: #dcf2e7;
      --help-overlay: rgba(12, 28, 24, 0.58);
      --help-panel-bg: #fbfffd;
      --help-code-bg: #e5f3ed;
      --help-code-fg: #1f302a;
      --help-icon-bg: #d9ebe4;
      --help-icon-fg: #193e36;
      --hero-grad-start: #fbfffd;
      --hero-grad-end: #fbfffd;
      --surface-tint: rgba(251, 255, 253, 0.9);
      --surface-shadow: 0 8px 20px rgba(19, 52, 44, 0.09);
      --surface-shadow-soft: 0 3px 10px rgba(19, 52, 44, 0.07);
      --focus-ring: 0 0 0 3px rgba(31, 143, 99, 0.27);
    }
    body[data-theme="midnight-contrast"] {
      --bg: #0b1018;
      --card: #141c28;
      --text: #f0f4fb;
      --muted: #a9b6ca;
      --accent: #7a88ff;
      --accent-2: #5970ff;
      --border: #293648;
      --button-secondary-bg: #212c3e;
      --button-secondary-text: #edf3ff;
      --pre-bg: #080c14;
      --pre-fg: #e9f1ff;
      --drop-bg: #111a28;
      --drop-drag-bg: #172235;
      --help-overlay: rgba(0, 0, 0, 0.78);
      --help-panel-bg: #141c28;
      --help-code-bg: #243246;
      --help-code-fg: #f0f4fb;
      --help-icon-bg: #2b3b50;
      --help-icon-fg: #ffffff;
      --hero-grad-start: #141c28;
      --hero-grad-end: #141c28;
      --surface-tint: rgba(255, 255, 255, 0.02);
      --surface-shadow: 0 10px 24px rgba(0, 0, 0, 0.36);
      --surface-shadow-soft: 0 4px 12px rgba(0, 0, 0, 0.26);
      --focus-ring: 0 0 0 3px rgba(122, 136, 255, 0.3);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: var(--font-sans);
      color: var(--text);
      min-height: 100vh;
      background: var(--bg);
      position: relative;
      overflow-x: hidden;
    }
    body::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      opacity: 0.11;
      background: radial-gradient(1200px 560px at 14% -8%, color-mix(in srgb, var(--accent) 16%, transparent), transparent 64%);
      z-index: -2;
    }
    body::after {
      content: none;
    }
    header {
      padding: 10px 16px 8px;
      background: color-mix(in srgb, var(--card) 98%, var(--bg));
      color: var(--text);
      position: relative;
      overflow: hidden;
      border-bottom: 1px solid var(--border);
    }
    header::after {
      content: none;
    }
    .header-top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      margin-bottom: 2px;
      position: relative;
      z-index: 1;
    }
    .brand-block {
      max-width: 760px;
    }
    .brand-identity {
      display: inline-flex;
      align-items: center;
      gap: 10px;
    }
    .app-icon {
      width: 40px;
      height: 40px;
      object-fit: contain;
      display: block;
      filter: drop-shadow(0 1px 3px rgba(0, 0, 0, 0.22));
      opacity: 0.98;
    }
    header h1 {
      margin: 0;
      font-family: var(--font-display);
      font-size: clamp(18px, 2.4vw, 24px);
      line-height: 1.05;
      letter-spacing: 0;
      font-weight: 650;
    }
    .hero-subtitle {
      margin: 2px 0 0;
      font-size: 12px;
      line-height: 1.2;
      max-width: 640px;
      color: var(--muted);
    }
    .theme-picker {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      color: var(--muted);
      font-weight: 500;
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 8px;
      background: color-mix(in srgb, var(--card) 96%, var(--surface-tint));
      border: 1px solid var(--border);
      box-shadow: var(--surface-shadow-soft);
    }
    .theme-picker select {
      min-width: 152px;
      border-color: var(--border);
      background: color-mix(in srgb, var(--card) 96%, var(--surface-tint));
      color: var(--text);
      padding: 4px 8px;
    }
    .theme-picker select option {
      color: var(--text);
      background: var(--card);
    }
    @media (max-width: 720px) {
      header {
        padding: 10px 12px 8px;
      }
      .header-top {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
      }
      .theme-picker {
        width: 100%;
      }
      .theme-picker select {
        min-width: 0;
        width: 100%;
      }
      .brand-identity {
        gap: 8px;
      }
      .app-icon {
        width: 30px;
        height: 30px;
      }
    }
    .app-shell {
      max-width: none;
      margin: 0;
      padding: 10px 14px 16px 274px;
      display: grid;
      grid-template-columns: minmax(0, 1fr);
      gap: 10px;
      align-items: start;
      position: relative;
    }
    .nav-column {
      background: color-mix(in srgb, var(--card) 98%, var(--surface-tint));
      border: 1px solid var(--border);
      border-radius: 10px;
      box-shadow: var(--surface-shadow-soft);
      padding: 10px;
      position: fixed;
      top: 74px;
      left: 10px;
      bottom: 10px;
      width: 248px;
      max-height: none;
      overflow: auto;
      z-index: 10;
    }
    .nav-title {
      margin: 0 0 4px;
      font-size: 11px;
      font-weight: 500;
      color: var(--text);
      opacity: 0.84;
    }
    .nav-copy {
      margin: 0 0 8px;
      font-size: 11px;
      line-height: 1.25;
    }
    .nav-list {
      display: grid;
      gap: 6px;
    }
    .nav-btn {
      display: flex;
      align-items: center;
      justify-content: space-between;
      text-align: left;
      width: 100%;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 7px 9px;
      font-size: 12px;
      font-weight: 400;
      color: var(--text);
      background: color-mix(in srgb, var(--card) 99%, var(--surface-tint));
      transition: transform 120ms ease, background 170ms ease, border-color 170ms ease, box-shadow 170ms ease;
      animation: navSlideIn 220ms ease both;
    }
    .nav-btn-text {
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      padding-right: 4px;
    }
    .nav-activity {
      position: relative;
      display: none;
      width: 22px;
      height: 22px;
      flex: 0 0 22px;
    }
    .nav-btn.has-activity .nav-activity {
      display: block;
    }
    .nav-activity-ring {
      position: absolute;
      inset: 0;
      border-radius: 50%;
      background: conic-gradient(
        var(--activity-color, var(--accent)) calc(var(--activity-progress, 0) * 1%),
        color-mix(in srgb, var(--muted) 30%, transparent) 0
      );
      transition: background 180ms ease;
    }
    .nav-activity-ring::after {
      content: "";
      position: absolute;
      inset: 3px;
      border-radius: 50%;
      background: color-mix(in srgb, var(--card) 96%, var(--surface-tint));
    }
    .nav-btn.active .nav-activity-ring::after {
      background: color-mix(in srgb, var(--accent) 62%, #000 18%);
    }
    .nav-activity-label {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1;
      font-size: 8px;
      font-weight: 700;
      color: var(--text);
      line-height: 1;
    }
    .nav-btn.active .nav-activity-label {
      color: #f8fbff;
    }
    .nav-btn.activity-indeterminate .nav-activity-ring {
      background: conic-gradient(
        var(--activity-color, var(--accent)) 0 18%,
        transparent 18% 46%,
        color-mix(in srgb, var(--muted) 28%, transparent) 46% 100%
      );
      animation: navActivitySpin 900ms linear infinite;
    }
    .nav-list .nav-btn:nth-child(1) { animation-delay: 20ms; }
    .nav-list .nav-btn:nth-child(2) { animation-delay: 35ms; }
    .nav-list .nav-btn:nth-child(3) { animation-delay: 50ms; }
    .nav-list .nav-btn:nth-child(4) { animation-delay: 65ms; }
    .nav-list .nav-btn:nth-child(5) { animation-delay: 80ms; }
    .nav-list .nav-btn:nth-child(6) { animation-delay: 95ms; }
    .nav-list .nav-btn:nth-child(7) { animation-delay: 110ms; }
    .nav-list .nav-btn:nth-child(8) { animation-delay: 125ms; }
    .nav-list .nav-btn:nth-child(9) { animation-delay: 140ms; }
    .nav-list .nav-btn:nth-child(10) { animation-delay: 155ms; }
    .nav-list .nav-btn:nth-child(11) { animation-delay: 170ms; }
    .nav-list .nav-btn:nth-child(12) { animation-delay: 185ms; }
    .nav-list .nav-btn:nth-child(13) { animation-delay: 200ms; }
    .nav-list .nav-btn:nth-child(14) { animation-delay: 215ms; }
    .nav-list .nav-btn:nth-child(15) { animation-delay: 230ms; }
    .nav-list .nav-btn:nth-child(16) { animation-delay: 245ms; }
    .nav-list .nav-btn:nth-child(17) { animation-delay: 260ms; }
    .nav-list .nav-btn:nth-child(18) { animation-delay: 275ms; }
    .nav-list .nav-btn:nth-child(19) { animation-delay: 290ms; }
    .nav-list .nav-btn:nth-child(20) { animation-delay: 305ms; }
    .nav-list .nav-btn:nth-child(21) { animation-delay: 320ms; }
    .nav-list .nav-btn:nth-child(22) { animation-delay: 335ms; }
    .nav-list .nav-btn:nth-child(23) { animation-delay: 350ms; }
    .nav-list .nav-btn:nth-child(24) { animation-delay: 365ms; }
    .nav-list .nav-btn:nth-child(25) { animation-delay: 380ms; }
    .nav-btn:hover {
      transform: translateX(1px);
      border-color: color-mix(in srgb, var(--accent) 32%, var(--border));
      box-shadow: 0 6px 14px rgba(15, 23, 42, 0.08);
      filter: none;
    }
    .nav-btn.active {
      background: var(--accent);
      color: #f8fbff;
      border-color: color-mix(in srgb, var(--accent) 78%, transparent);
      box-shadow: 0 8px 16px color-mix(in srgb, var(--accent) 28%, transparent);
    }
    .workspace {
      min-width: 0;
    }
    .workspace-panel {
      display: none;
    }
    .workspace-panel.active {
      display: block;
      animation: panelFade 220ms ease;
    }
    .card {
      background: color-mix(in srgb, var(--card) 99%, var(--surface-tint));
      border: 1px solid var(--border);
      border-radius: 10px;
      box-shadow: var(--surface-shadow-soft);
      padding: 12px;
      position: relative;
      overflow: visible;
    }
    .card::after {
      content: none;
    }
    .row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 8px;
      position: relative;
      z-index: 1;
    }
    input, textarea, button, select {
      font: inherit;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 10px;
      background: color-mix(in srgb, var(--card) 99%, var(--surface-tint));
      color: var(--text);
    }
    input, select { flex: 1 1 180px; }
    textarea { width: 100%; min-height: 96px; line-height: 1.45; }
    input:focus,
    textarea:focus,
    select:focus,
    button:focus-visible {
      outline: none;
      box-shadow: var(--focus-ring);
      border-color: color-mix(in srgb, var(--accent) 55%, var(--border));
    }
    input::placeholder,
    textarea::placeholder {
      color: color-mix(in srgb, var(--muted) 88%, transparent);
    }
    button {
      background: var(--accent);
      color: #fff;
      border: 1px solid color-mix(in srgb, var(--accent) 72%, transparent);
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0;
      box-shadow: 0 4px 12px color-mix(in srgb, var(--accent) 20%, transparent);
      transition: transform 120ms ease, filter 140ms ease, box-shadow 140ms ease;
    }
    button.secondary {
      background: var(--button-secondary-bg);
      color: var(--button-secondary-text);
      border-color: color-mix(in srgb, var(--button-secondary-text) 14%, var(--border));
    }
    button:hover {
      filter: brightness(1.02);
      transform: translateY(-1px);
      box-shadow: 0 8px 16px rgba(15, 23, 42, 0.12);
    }
    button:active {
      transform: translateY(0);
      box-shadow: 0 3px 10px rgba(15, 23, 42, 0.09);
    }
    pre {
      background: var(--pre-bg);
      color: var(--pre-fg);
      border-radius: 8px;
      padding: 10px;
      overflow: auto;
      max-height: none;
      margin: 10px 0 0;
      font-size: 11px;
      line-height: 1.5;
      font-family: var(--font-mono);
      border: 1px solid color-mix(in srgb, var(--pre-fg) 15%, transparent);
    }
    pre[id^="out-"] {
      min-height: 18rem;
      height: 18rem;
      resize: vertical;
    }
    .db-grid-controls input,
    .db-grid-controls select {
      flex: 1 1 220px;
    }
    .db-grid-controls input:disabled,
    .db-grid-controls button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    #db-grid-view {
      display: none;
      margin-top: 8px;
    }
    #db-grid-view.open {
      display: block;
    }
    .db-grid-scroll {
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: auto;
      max-height: 70vh;
      background: color-mix(in srgb, var(--card) 99%, var(--surface-tint));
    }
    .db-grid-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
      line-height: 1.35;
    }
    .db-grid-table th,
    .db-grid-table td {
      border-bottom: 1px solid var(--border);
      padding: 6px 8px;
      text-align: left;
      vertical-align: top;
    }
    .db-grid-table thead th {
      position: sticky;
      top: 0;
      z-index: 2;
      background: color-mix(in srgb, var(--card) 96%, var(--surface-tint));
    }
    .db-grid-table .db-filter-row th {
      top: 35px;
      z-index: 1;
    }
    .db-grid-table tbody tr:nth-child(even) {
      background: color-mix(in srgb, var(--accent-2) 10%, transparent);
    }
    .db-sort-btn {
      appearance: none;
      border: none;
      background: transparent;
      color: var(--text);
      cursor: pointer;
      font: inherit;
      font-weight: 700;
      padding: 0;
      line-height: 1.2;
    }
    .db-sort-btn:hover {
      text-decoration: underline;
    }
    .db-filter-input {
      width: 100%;
      min-width: 120px;
      padding: 4px 6px;
      font-size: 12px;
    }
    .inspector-list {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: color-mix(in srgb, var(--card) 99%, var(--surface-tint));
      padding: 12px;
      max-height: 24rem;
      overflow: auto;
      margin-top: 10px;
    }
    .inspector-card {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 11px;
      margin-bottom: 10px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
    }
    .inspector-card:last-child {
      margin-bottom: 0;
    }
    .inspector-card h4 {
      margin: 0 0 4px;
      font-size: 13px;
    }
    .inspector-meta {
      font-size: 12px;
      color: var(--muted);
      margin: 0 0 6px;
      word-break: break-word;
    }
    .inspector-copy-row {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .inspector-copy-row button {
      padding: 5px 8px;
      font-size: 12px;
    }
    .inspector-copy-status {
      margin-top: 6px;
      font-size: 12px;
      color: var(--muted);
    }
    .db-cell {
      max-width: 560px;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .dropzone {
      border: 1.5px dashed color-mix(in srgb, var(--accent) 42%, var(--border));
      border-radius: 10px;
      padding: 14px;
      text-align: center;
      color: var(--muted);
      background: var(--drop-bg);
      margin-bottom: 10px;
      transition: background 150ms ease, border-color 150ms ease, transform 150ms ease;
    }
    .dropzone.drag {
      background: var(--drop-drag-bg);
      border-color: var(--accent);
      transform: translateY(-1px);
    }
    .dropzone-scan-status {
      margin: -4px 0 10px;
      min-height: 18px;
      font-size: 12px;
      color: var(--muted);
      display: none;
      letter-spacing: 0.01em;
    }
    .dropzone-scan-status.active {
      display: block;
      color: color-mix(in srgb, var(--accent) 62%, var(--text));
    }
    .dropzone-scan-status.ok {
      display: block;
      color: color-mix(in srgb, #14965a 74%, var(--text));
    }
    .dropzone-scan-status.warn {
      display: block;
      color: color-mix(in srgb, #b26d00 82%, var(--text));
    }
    .dropzone-scan-status.error {
      display: block;
      color: color-mix(in srgb, #b42318 84%, var(--text));
    }
    .import-live {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: color-mix(in srgb, var(--card) 99%, var(--surface-tint));
      padding: 10px;
      margin-bottom: 10px;
      display: grid;
      grid-template-columns: minmax(280px, 34%) minmax(0, 1fr);
      gap: 10px;
      position: relative;
      z-index: 1;
    }
    .import-live.current-focus {
      border-color: color-mix(in srgb, var(--accent) 38%, var(--border));
      box-shadow: 0 0 0 1px color-mix(in srgb, var(--accent) 18%, transparent);
      background: color-mix(in srgb, var(--accent) 7%, var(--card));
    }
    .import-live.empty {
      grid-template-columns: 1fr;
    }
    .import-queue {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: color-mix(in srgb, var(--card) 99%, var(--surface-tint));
      padding: 8px;
      margin-bottom: 10px;
      max-height: 16.5rem;
      overflow: auto;
      display: grid;
      gap: 8px;
      position: relative;
      z-index: 1;
    }
    .import-queue-head {
      margin: 0 0 2px;
      font-size: 12px;
      color: var(--muted);
      letter-spacing: 0;
      font-weight: 500;
    }
    .import-queue-item {
      border: 1px solid var(--border);
      border-radius: 9px;
      padding: 8px 9px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
      font-size: 12px;
      line-height: 1.35;
      word-break: break-word;
    }
    .import-queue-item.processing {
      border-color: color-mix(in srgb, var(--accent) 52%, var(--border));
      box-shadow: 0 0 0 1px color-mix(in srgb, var(--accent) 20%, transparent);
      background: color-mix(in srgb, var(--accent) 10%, var(--card));
    }
    .import-queue-item.done {
      border-color: color-mix(in srgb, #14965a 45%, var(--border));
    }
    .import-queue-item.failed {
      border-color: color-mix(in srgb, #b42318 48%, var(--border));
      background: color-mix(in srgb, #b42318 8%, var(--card));
    }
    .import-queue-item.skipped {
      border-color: color-mix(in srgb, #b26d00 44%, var(--border));
      background: color-mix(in srgb, #b26d00 8%, var(--card));
    }
    .import-queue-item.cancelled {
      border-color: color-mix(in srgb, #6b7280 40%, var(--border));
      background: color-mix(in srgb, #6b7280 8%, var(--card));
    }
    .import-queue-item-head {
      margin: 0 0 3px;
      font-size: 12px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 6px;
      justify-content: space-between;
    }
    .import-queue-item-meta {
      margin: 0;
      color: var(--muted);
      font-size: 11px;
      line-height: 1.3;
    }
    .import-queue-item-detail {
      margin: 4px 0 0;
      color: var(--muted);
      font-size: 11px;
      line-height: 1.35;
    }
    .import-queue-actions {
      margin-top: 6px;
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .import-queue-action-btn {
      border: 1px solid var(--border);
      border-radius: 7px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
      color: var(--text);
      font-size: 10px;
      font-weight: 600;
      letter-spacing: 0.01em;
      padding: 3px 8px;
      cursor: pointer;
    }
    .import-queue-action-btn:hover:not([disabled]) {
      border-color: color-mix(in srgb, var(--accent) 45%, var(--border));
      color: color-mix(in srgb, var(--accent) 65%, var(--text));
    }
    .import-queue-action-btn[disabled] {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .import-preview {
      border: 1px solid var(--border);
      border-radius: 8px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
      min-height: 340px;
      overflow: hidden;
      display: grid;
      align-items: stretch;
      justify-items: stretch;
      color: var(--muted);
      font-size: 12px;
      text-align: center;
      padding: 10px 10px 8px;
    }
    .import-preview embed,
    .import-preview iframe {
      width: 100%;
      height: 232px;
      border: 0;
      background: #fff;
    }
    .import-preview img {
      max-width: 100%;
      max-height: 232px;
      object-fit: contain;
      display: block;
    }
    .import-preview-pdf {
      width: 100%;
      display: grid;
      justify-items: center;
      gap: 10px;
      align-content: start;
    }
    .import-preview-pdf-canvas-wrap {
      width: min(296px, 100%);
      min-height: 324px;
      position: relative;
      display: grid;
      place-items: center;
      background: #0f172a;
      border-radius: 8px;
      border: 1px solid rgba(15, 23, 42, 0.25);
      overflow: hidden;
      box-shadow: 0 8px 18px rgba(2, 6, 23, 0.28);
    }
    .import-preview-pdf-canvas {
      display: block;
      position: relative;
      z-index: 1;
      width: auto;
      height: auto;
      max-width: 100%;
      max-height: 320px;
      background: #ffffff;
    }
    .import-preview-pdf-overlay {
      position: absolute;
      inset: auto;
      z-index: 2;
      pointer-events: none;
    }
    .import-preview-pdf-placeholder {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      padding: 10px;
      font-size: 11px;
      line-height: 1.35;
      color: #e2e8f0;
      text-align: center;
      word-break: break-word;
      background: rgba(15, 23, 42, 0.58);
      z-index: 2;
    }
    .import-preview-pdf-title {
      margin: 0;
      max-width: 296px;
      font-size: 10px;
      line-height: 1.25;
      color: var(--muted);
      word-break: break-word;
      text-align: center;
    }
    .import-preview-caption {
      margin: 0;
      font-size: 11px;
      color: var(--muted);
      font-weight: 500;
      letter-spacing: 0;
    }
    .import-preview-live-signal {
      width: min(296px, 100%);
      border: 1px solid var(--border);
      border-radius: 8px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
      padding: 7px 8px;
      text-align: left;
      display: grid;
      gap: 6px;
      min-height: 72px;
    }
    .import-preview-live-signal-head {
      margin: 0;
      font-size: 11px;
      color: var(--muted);
      font-weight: 600;
    }
    .import-preview-live-signal-list {
      display: grid;
      gap: 4px;
    }
    .import-preview-live-signal-item {
      margin: 0;
      font-size: 11px;
      line-height: 1.35;
      color: var(--text);
      word-break: break-word;
      border-left: 2px solid color-mix(in srgb, var(--accent) 34%, transparent);
      padding-left: 6px;
    }
    .import-preview-live-signal-item .muted {
      color: var(--muted);
      font-size: 10px;
    }
    .import-preview-text,
    .import-preview-generic {
      width: 100%;
      display: grid;
      justify-items: stretch;
      align-content: start;
      gap: 8px;
    }
    .import-preview-file-meta {
      margin: 0;
      text-align: left;
      display: grid;
      gap: 3px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
      padding: 8px;
    }
    .import-preview-file-meta p {
      margin: 0;
      font-size: 11px;
      color: var(--muted);
      line-height: 1.35;
      word-break: break-word;
    }
    .import-preview-file-meta strong {
      color: var(--text);
      font-weight: 600;
    }
    .import-preview-text-content {
      margin: 0;
      min-height: 188px;
      max-height: 280px;
      overflow: auto;
      border-radius: 8px;
      border: 1px solid rgba(15, 23, 42, 0.32);
      background: #0f172a;
      color: #e2e8f0;
      font-size: 11px;
      line-height: 1.4;
      text-align: left;
      white-space: pre-wrap;
      word-break: break-word;
      padding: 8px 9px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    .import-preview-generic-embed {
      width: 100%;
      min-height: 238px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: #fff;
      overflow: hidden;
      display: grid;
      place-items: center;
    }
    .import-preview-generic-empty {
      padding: 12px;
      font-size: 12px;
      line-height: 1.4;
      color: var(--muted);
      text-align: center;
    }
    .import-title {
      margin: 0 0 4px;
      font-size: 16px;
      font-weight: 600;
      line-height: 1.2;
      word-break: break-word;
    }
    .import-meta {
      margin: 0 0 10px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.4;
      word-break: break-word;
    }
    .import-progress-track {
      width: 100%;
      height: 10px;
      border-radius: 999px;
      background: color-mix(in srgb, var(--accent-2) 16%, transparent);
      border: 1px solid color-mix(in srgb, var(--accent-2) 24%, transparent);
      overflow: hidden;
      margin-bottom: 8px;
    }
    .import-progress-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--accent), color-mix(in srgb, var(--accent-2) 72%, var(--accent)));
      border-radius: inherit;
      transition: width 180ms ease;
      position: relative;
    }
    .import-progress-bar.active::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(120deg, transparent 0%, rgba(255, 255, 255, 0.35) 45%, transparent 70%);
      animation: importShimmer 900ms linear infinite;
    }
    .import-status-line {
      margin: 0 0 8px;
      font-size: 12px;
      color: var(--muted);
      min-height: 18px;
    }
    .import-counters {
      margin: 0 0 10px;
      font-size: 12px;
      color: var(--muted);
      min-height: 18px;
    }
    .import-steps {
      display: grid;
      gap: 8px;
      margin-bottom: 12px;
    }
    .import-step {
      border: 1px solid var(--border);
      border-radius: 9px;
      padding: 8px 10px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
      font-size: 12px;
      line-height: 1.3;
      word-break: break-word;
    }
    .import-step-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 5px;
    }
    .import-step-head strong {
      font-size: 12px;
    }
    .step-progress-track {
      width: 100%;
      height: 7px;
      border-radius: 999px;
      background: color-mix(in srgb, var(--accent-2) 16%, transparent);
      border: 1px solid color-mix(in srgb, var(--accent-2) 24%, transparent);
      overflow: hidden;
      margin-bottom: 4px;
    }
    .step-progress-bar {
      height: 100%;
      width: 0%;
      border-radius: inherit;
      transition: width 160ms ease;
      background: linear-gradient(90deg, var(--accent), color-mix(in srgb, var(--accent-2) 72%, var(--accent)));
      position: relative;
    }
    .step-progress-bar.active::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(120deg, transparent 0%, rgba(255, 255, 255, 0.34) 45%, transparent 70%);
      animation: importShimmer 900ms linear infinite;
    }
    .import-step-detail {
      margin: 0;
      color: var(--muted);
      font-size: 11px;
      line-height: 1.35;
      min-height: 14px;
    }
    .import-step .step-badge {
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0;
      text-transform: none;
      border: 1px solid transparent;
    }
    .import-step.pending .step-badge {
      background: rgba(100, 116, 139, 0.14);
      border-color: rgba(100, 116, 139, 0.22);
      color: var(--muted);
    }
    .import-step.pending .step-progress-bar {
      background: rgba(100, 116, 139, 0.32);
    }
    .import-step.active .step-badge {
      background: rgba(14, 116, 144, 0.18);
      border-color: rgba(14, 116, 144, 0.36);
      color: #0f6a7d;
    }
    .import-step.done .step-badge {
      background: rgba(20, 150, 90, 0.18);
      border-color: rgba(20, 150, 90, 0.36);
      color: #0f7a4f;
    }
    .import-step.skipped .step-badge {
      background: rgba(100, 116, 139, 0.18);
      border-color: rgba(100, 116, 139, 0.32);
      color: var(--text);
    }
    .import-step.skipped .step-progress-bar {
      background: rgba(100, 116, 139, 0.5);
    }
    .import-step.error .step-badge {
      background: rgba(180, 35, 24, 0.16);
      border-color: rgba(180, 35, 24, 0.36);
      color: #9f1e14;
    }
    .import-step.error .step-progress-bar {
      background: linear-gradient(90deg, #b42318, #9f1e14);
    }
    .import-metrics {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
      gap: 10px;
      margin-bottom: 12px;
    }
    .import-metric {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 9px 10px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
    }
    .import-metric p {
      margin: 0;
      line-height: 1.25;
    }
    .import-metric .k {
      font-size: 12px;
      letter-spacing: 0;
      text-transform: none;
      color: var(--muted);
      font-weight: 500;
    }
    .import-metric .v {
      font-size: 16px;
      font-weight: 600;
      margin-top: 2px;
    }
    .import-history-title {
      margin: 12px 0 7px;
      font-size: 13px;
      color: var(--muted);
      text-transform: none;
      letter-spacing: 0;
      font-weight: 600;
    }
    .import-history {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: color-mix(in srgb, var(--card) 99%, var(--surface-tint));
      padding: 12px;
      max-height: 17rem;
      overflow: auto;
      display: grid;
      gap: 8px;
      position: relative;
      z-index: 1;
    }
    .import-history-item {
      border: 1px solid var(--border);
      border-radius: 9px;
      padding: 9px 10px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
      font-size: 12px;
      line-height: 1.35;
      word-break: break-word;
    }
    .import-history-item h4 {
      margin: 0 0 3px;
      font-size: 12px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .viewer-topbar {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 10px;
      margin-bottom: 8px;
    }
    .viewer-topbar-main {
      min-width: 0;
      display: grid;
      gap: 4px;
    }
    .viewer-breadcrumb {
      margin: 0;
      font-size: 11px;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      color: var(--muted);
    }
    .viewer-title-row {
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 0;
    }
    .viewer-doc-title {
      margin: 0;
      font-size: clamp(18px, 2vw, 25px);
      line-height: 1.1;
      font-weight: 650;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .viewer-title-edit {
      padding: 5px 9px;
      font-size: 12px;
      flex: 0 0 auto;
    }
    .viewer-doc-subtitle {
      margin: 0;
    }
    .viewer-topbar-actions {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: flex-end;
      align-items: flex-start;
      flex: 0 0 auto;
    }
    .viewer-topbar-actions button,
    .viewer-topbar-actions summary {
      font-size: 12px;
      padding: 6px 9px;
    }
    .viewer-more-actions {
      position: relative;
      margin: 0;
    }
    .viewer-more-actions > summary {
      cursor: pointer;
      border: 1px solid var(--border);
      border-radius: 8px;
      list-style: none;
      background: color-mix(in srgb, var(--card) 99%, var(--surface-tint));
    }
    .viewer-more-actions > summary::-webkit-details-marker {
      display: none;
    }
    .viewer-more-menu {
      display: none;
      position: absolute;
      right: 0;
      top: calc(100% + 4px);
      min-width: 220px;
      gap: 6px;
      padding: 8px;
      border: 1px solid var(--border);
      border-radius: 10px;
      box-shadow: var(--surface-shadow);
      background: color-mix(in srgb, var(--card) 99%, var(--surface-tint));
      z-index: 4;
    }
    .viewer-more-actions[open] .viewer-more-menu {
      display: grid;
    }
    .viewer-dev-tools {
      margin: 0 0 10px;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px;
      background: color-mix(in srgb, var(--card) 96%, var(--surface-tint));
    }
    .viewer-dev-tools > summary {
      cursor: pointer;
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 8px;
      user-select: none;
    }
    .viewer-toolbar {
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 8px;
      padding: 7px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: color-mix(in srgb, var(--card) 98%, var(--surface-tint));
    }
    .viewer-toolbar-group {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
    }
    .viewer-toolbar-group button {
      font-size: 12px;
      padding: 5px 9px;
    }
    .viewer-toolbar-overlays {
      margin-left: auto;
    }
    .viewer-toggle {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      font-size: 12px;
      color: var(--muted);
      user-select: none;
    }
    .viewer-toggle input {
      accent-color: var(--accent);
    }
    .viewer-mode-badge {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 3px 8px;
      font-size: 11px;
      color: var(--muted);
      background: color-mix(in srgb, var(--card) 96%, var(--surface-tint));
    }
    .viewer-status {
      margin: 0 0 8px;
      border-left: 3px solid color-mix(in srgb, var(--accent) 50%, var(--border));
      padding-left: 8px;
    }
    .doc-viewer-layout {
      display: grid;
      grid-template-columns: minmax(250px, 300px) minmax(0, 1fr) minmax(315px, 370px);
      gap: 10px;
      align-items: start;
    }
    .doc-viewer-layout.inspector-collapsed {
      grid-template-columns: minmax(250px, 300px) minmax(0, 1fr);
    }
    .doc-viewer-layout.inspector-collapsed .doc-viewer-side {
      display: none;
    }
    .doc-viewer-index {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
      padding: 10px;
      display: grid;
      gap: 9px;
      min-height: 560px;
      align-content: start;
    }
    .viewer-index-controls {
      display: grid;
      gap: 7px;
    }
    .viewer-index-controls input,
    .viewer-index-controls select {
      width: 100%;
      font-size: 12px;
      padding: 6px 8px;
    }
    .viewer-index-groups {
      display: grid;
      gap: 8px;
      min-height: 0;
    }
    .viewer-index-group {
      border: 1px solid var(--border);
      border-radius: 8px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
      overflow: hidden;
    }
    .viewer-index-group > summary {
      cursor: pointer;
      list-style: none;
      font-size: 12px;
      font-weight: 600;
      color: var(--text);
      padding: 8px 9px;
      border-bottom: 1px solid color-mix(in srgb, var(--border) 85%, transparent);
      background: color-mix(in srgb, var(--card) 97%, var(--surface-tint));
    }
    .viewer-index-group > summary::-webkit-details-marker {
      display: none;
    }
    .viewer-index-list {
      display: grid;
      gap: 6px;
      max-height: 16.5rem;
      overflow: auto;
      padding: 8px;
    }
    .viewer-index-item {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 7px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
      cursor: pointer;
      display: grid;
      gap: 3px;
    }
    .viewer-index-item.active {
      border-color: color-mix(in srgb, var(--accent) 58%, var(--border));
      box-shadow: 0 0 0 1px color-mix(in srgb, var(--accent) 26%, transparent);
    }
    .viewer-index-item h5 {
      margin: 0;
      font-size: 12px;
      color: var(--text);
      line-height: 1.3;
      word-break: break-word;
    }
    .viewer-index-item p {
      margin: 0;
      font-size: 11px;
      color: var(--muted);
      line-height: 1.35;
      word-break: break-word;
    }
    .viewer-index-pagination {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
      margin-top: 2px;
    }
    .viewer-index-pagination button {
      font-size: 11px;
      padding: 3px 7px;
    }
    .viewer-index-pagination .small {
      margin-left: auto;
    }
    .doc-viewer-stage {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
      min-height: 560px;
      padding: 6px;
    }
    .doc-viewer-scroll {
      position: relative;
      width: 100%;
      height: 100%;
      min-height: 540px;
      overflow: auto;
      border-radius: 8px;
      background: color-mix(in srgb, var(--page-bg) 90%, var(--card));
      border: 1px solid var(--border);
      cursor: default;
    }
    .doc-viewer-scroll.pan-enabled {
      cursor: grab;
    }
    .doc-viewer-scroll.pan-enabled.panning {
      cursor: grabbing;
    }
    #viewer-pdf-canvas {
      display: none;
      margin: 0 auto;
      background: #fff;
      box-shadow: 0 10px 22px rgba(2, 6, 23, 0.16);
    }
    #viewer-overlay-canvas {
      display: none;
      position: absolute;
      pointer-events: auto;
      z-index: 3;
      border: 0;
    }
    .doc-viewer-fallback {
      min-height: 520px;
      display: grid;
      place-items: start stretch;
      color: var(--muted);
      padding: 14px;
    }
    .viewer-empty-state {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px;
      background: color-mix(in srgb, var(--card) 98%, var(--surface-tint));
      width: 100%;
      max-width: 940px;
      margin: 0 auto;
      text-align: left;
    }
    .viewer-empty-state h3 {
      margin: 0 0 6px;
      color: var(--text);
      font-size: 16px;
      line-height: 1.25;
    }
    .viewer-empty-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin: 10px 0;
    }
    .viewer-empty-actions button,
    .viewer-empty-actions a {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 12px;
      color: var(--text);
      background: color-mix(in srgb, var(--card) 98%, var(--surface-tint));
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .viewer-fallback-embed {
      margin-top: 10px;
      border: 1px solid var(--border);
      border-radius: 10px;
      overflow: hidden;
      background: color-mix(in srgb, #fff 90%, var(--card));
    }
    .viewer-fallback-embed object,
    .viewer-fallback-embed iframe,
    .viewer-fallback-embed embed {
      width: 100%;
      min-height: 540px;
      border: 0;
      display: block;
      background: #fff;
    }
    .viewer-structured-view {
      display: grid;
      gap: 10px;
    }
    .viewer-structured-grid {
      display: grid;
      grid-template-columns: minmax(0, 1.45fr) minmax(280px, 1fr);
      gap: 10px;
      align-items: start;
    }
    .viewer-structured-block {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: color-mix(in srgb, var(--card) 99%, var(--surface-tint));
      padding: 10px;
      display: grid;
      gap: 7px;
      min-width: 0;
    }
    .viewer-structured-block h4 {
      margin: 0;
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.03em;
      font-weight: 600;
    }
    .viewer-structured-text {
      margin: 0;
      border-radius: 8px;
      border: 1px solid color-mix(in srgb, var(--border) 82%, transparent);
      background: color-mix(in srgb, var(--card) 96%, var(--surface-tint));
      padding: 9px;
      font-size: 12px;
      line-height: 1.5;
      white-space: pre-wrap;
      word-break: break-word;
      max-height: 19rem;
      overflow: auto;
    }
    .viewer-structured-text.loading {
      color: var(--muted);
      font-style: italic;
    }
    .viewer-structured-selection {
      margin: 0;
      border-left: 3px solid color-mix(in srgb, var(--accent) 54%, var(--border));
      padding: 8px 10px;
      border-radius: 8px;
      background: color-mix(in srgb, var(--accent) 8%, var(--card));
      font-size: 12px;
      line-height: 1.45;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .viewer-structured-selection mark {
      background: color-mix(in srgb, var(--accent) 32%, #facc15);
      color: inherit;
      border-radius: 2px;
      padding: 0 1px;
    }
    .viewer-structured-card-list {
      display: grid;
      gap: 8px;
      max-height: 22rem;
      overflow: auto;
    }
    .viewer-structured-card {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
      font-size: 12px;
      line-height: 1.4;
      word-break: break-word;
    }
    .viewer-structured-card.active {
      border-color: color-mix(in srgb, var(--accent) 58%, var(--border));
      box-shadow: 0 0 0 1px color-mix(in srgb, var(--accent) 24%, transparent);
    }
    .viewer-structured-table-wrap {
      border: 1px solid var(--border);
      border-radius: 9px;
      overflow: auto;
      max-height: 15rem;
    }
    .viewer-structured-table-wrap table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
      line-height: 1.35;
      min-width: 340px;
    }
    .viewer-structured-table-wrap th,
    .viewer-structured-table-wrap td {
      border: 1px solid var(--border);
      padding: 4px 6px;
      text-align: left;
      vertical-align: top;
      word-break: break-word;
    }
    .viewer-title-candidates {
      display: grid;
      gap: 6px;
      margin-top: 6px;
    }
    .viewer-title-candidate-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }
    .viewer-title-candidate-row select {
      min-width: 240px;
      flex: 1 1 240px;
      font-size: 12px;
      padding: 5px 8px;
    }
    .viewer-title-candidate-row button {
      font-size: 12px;
      padding: 5px 8px;
    }
    .doc-viewer-fallback img {
      max-width: 100%;
      max-height: 620px;
      border-radius: 8px;
      box-shadow: 0 8px 20px rgba(2, 6, 23, 0.14);
      margin: 0 auto;
    }
    .doc-viewer-side {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
      padding: 10px;
      display: grid;
      gap: 10px;
      min-height: 560px;
      align-content: start;
    }
    .viewer-inspector-meta {
      display: grid;
      gap: 8px;
    }
    .viewer-meta-block {
      border: 1px solid var(--border);
      border-radius: 9px;
      background: color-mix(in srgb, var(--card) 99%, var(--surface-tint));
      padding: 8px;
      display: grid;
      gap: 6px;
    }
    .viewer-meta-block h4 {
      margin: 0;
      font-size: 12px;
      color: var(--muted);
      font-weight: 600;
    }
    .viewer-meta-row {
      display: grid;
      grid-template-columns: minmax(95px, 120px) minmax(0, 1fr);
      gap: 8px;
      align-items: start;
      font-size: 12px;
      line-height: 1.35;
    }
    .viewer-meta-label {
      color: var(--muted);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.02em;
    }
    .viewer-meta-value {
      color: var(--text);
      min-width: 0;
      overflow-wrap: anywhere;
    }
    .viewer-meta-value.compact {
      font-family: var(--font-mono);
      font-size: 11px;
    }
    .viewer-meta-copy {
      margin-left: 6px;
      padding: 3px 7px;
      font-size: 11px;
      line-height: 1.1;
      border-radius: 7px;
    }
    .viewer-inspector-section {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px;
      display: grid;
      gap: 8px;
      background: color-mix(in srgb, var(--card) 99%, var(--surface-tint));
    }
    .viewer-inspector-section h4 {
      margin: 0;
      font-size: 12px;
      color: var(--muted);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }
    .viewer-inspector-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .viewer-inspector-tabs button {
      font-size: 12px;
      padding: 5px 8px;
    }
    .viewer-inspector-tabs button.active {
      background: color-mix(in srgb, var(--accent) 86%, transparent);
      border-color: color-mix(in srgb, var(--accent) 70%, transparent);
      color: #fff;
    }
    .viewer-inspector-panel {
      min-height: 140px;
    }
    .viewer-overlay-item {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 9px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
      cursor: pointer;
    }
    .viewer-overlay-item.active {
      border-color: color-mix(in srgb, var(--accent) 58%, var(--border));
      box-shadow: 0 0 0 1px color-mix(in srgb, var(--accent) 28%, transparent);
    }
    .viewer-overlay-item h4 {
      margin: 0 0 4px;
      font-size: 12px;
      line-height: 1.3;
    }
    .viewer-overlay-item p {
      margin: 0;
      font-size: 11px;
      line-height: 1.35;
      color: var(--muted);
      word-break: break-word;
    }
    .viewer-table {
      width: 100%;
      border-collapse: collapse;
      min-width: 360px;
      font-size: 12px;
    }
    .viewer-table th,
    .viewer-table td {
      border: 1px solid var(--border);
      padding: 4px 6px;
      vertical-align: top;
      text-align: left;
      word-break: break-word;
    }
    .viewer-table thead th {
      background: color-mix(in srgb, var(--card) 82%, var(--surface-tint));
      font-weight: 600;
    }
    .viewer-table th.viewer-col-header-active,
    .viewer-table th.viewer-row-header-active {
      background: color-mix(in srgb, var(--accent) 17%, var(--card));
      box-shadow: inset 0 0 0 1px color-mix(in srgb, var(--accent) 40%, transparent);
    }
    .viewer-table td.viewer-cell-row-active {
      background: color-mix(in srgb, var(--accent) 8%, var(--card));
    }
    .viewer-table td.viewer-cell-col-active {
      background: color-mix(in srgb, var(--accent-2) 10%, var(--card));
    }
    .viewer-table td.viewer-cell-active {
      background: color-mix(in srgb, var(--accent) 14%, var(--card));
      outline: 1px solid color-mix(in srgb, var(--accent) 48%, transparent);
      outline-offset: -1px;
    }
    .viewer-annotation-item {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 9px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
      font-size: 11px;
      line-height: 1.35;
      word-break: break-word;
    }
    .viewer-annotation-item.active {
      border-color: color-mix(in srgb, var(--accent) 58%, var(--border));
      box-shadow: 0 0 0 1px color-mix(in srgb, var(--accent) 26%, transparent);
    }
    .viewer-annotation-item h4 {
      margin: 0 0 3px;
      font-size: 12px;
      line-height: 1.3;
    }
    .viewer-annotation-item p {
      margin: 0;
      color: var(--muted);
    }
    .viewer-tech-details {
      margin-top: 4px;
    }
    .viewer-tech-details > summary {
      cursor: pointer;
      font-size: 11px;
      color: var(--muted);
    }
    .viewer-tech-details pre {
      margin: 6px 0 0;
      max-height: 160px;
      overflow: auto;
      background: var(--pre-bg);
      color: var(--pre-fg);
      padding: 8px;
      border-radius: 8px;
      font-size: 11px;
    }
    .viewer-image-gallery {
      display: grid;
      gap: 10px;
      max-height: 22rem;
      overflow: auto;
      padding-right: 2px;
    }
    .viewer-image-card {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px;
      background: color-mix(in srgb, var(--card) 98%, var(--surface-tint));
      display: grid;
      gap: 7px;
      cursor: pointer;
    }
    .viewer-image-card.active {
      border-color: color-mix(in srgb, var(--accent) 42%, var(--border));
      box-shadow: 0 0 0 1px color-mix(in srgb, var(--accent) 25%, transparent);
    }
    .viewer-image-card-head {
      margin: 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
    }
    .viewer-image-card-head h5 {
      margin: 0;
      font-size: 12px;
      color: var(--text);
      font-weight: 700;
    }
    .viewer-image-thumb {
      width: 100%;
      max-height: 200px;
      object-fit: contain;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: color-mix(in srgb, var(--surface) 92%, var(--card));
    }
    .viewer-image-card p {
      margin: 0;
      font-size: 12px;
      line-height: 1.4;
      color: color-mix(in srgb, var(--muted) 85%, var(--text));
      word-break: break-word;
      white-space: pre-wrap;
    }
    .viewer-table-actions {
      align-items: center;
      gap: 6px;
      margin: 4px 0 2px;
    }
    .viewer-table-actions button {
      font-size: 11px;
      padding: 4px 7px;
    }
    .viewer-selection-summary {
      margin: 0;
      border-left: 3px solid color-mix(in srgb, var(--accent) 50%, var(--border));
      padding-left: 8px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.4;
    }
    .viewer-toast {
      position: fixed;
      right: 16px;
      bottom: 16px;
      margin: 0;
      z-index: 30;
      border: 1px solid color-mix(in srgb, var(--accent) 42%, var(--border));
      background: color-mix(in srgb, var(--card) 98%, var(--surface-tint));
      color: var(--text);
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 12px;
      box-shadow: var(--surface-shadow-soft);
      opacity: 0;
      pointer-events: none;
      transform: translateY(8px);
      transition: opacity 140ms ease, transform 140ms ease;
    }
    .viewer-toast.visible {
      opacity: 1;
      transform: translateY(0);
    }
    @keyframes importShimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(200%); }
    }
    .small {
      color: var(--muted);
      font-size: 12px;
      line-height: 1.45;
      position: relative;
      z-index: 1;
    }
    .err { color: var(--error); font-size: 12px; }
    .metric-grid,
    .dashboard-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
      gap: 12px;
      margin: 12px 0;
    }
    .metric-card {
      border: 1px solid color-mix(in srgb, var(--border) 84%, transparent);
      border-radius: 12px;
      padding: 12px 14px;
      background: color-mix(in srgb, var(--card) 99%, var(--surface-tint));
      box-shadow: 0 2px 7px rgba(0, 0, 0, 0.05);
      position: relative;
      overflow: hidden;
    }
    .metric-card::before {
      content: none;
    }
    .metric-label {
      margin: 0 0 6px;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.2;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      text-transform: none;
      letter-spacing: 0;
      font-family: var(--font-sans);
      font-weight: 500;
    }
    .metric-value {
      margin: 0;
      font-size: 24px;
      font-weight: 600;
      line-height: 1.2;
      word-break: break-word;
    }
    .status-pill {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 11px;
      font-weight: 600;
      border: 1px solid transparent;
      letter-spacing: 0;
      text-transform: none;
    }
    .status-ok {
      background: rgba(20, 150, 90, 0.18);
      color: #0f7a4f;
      border-color: rgba(20, 150, 90, 0.36);
    }
    .status-warn {
      background: rgba(217, 119, 6, 0.18);
      color: #9a5a00;
      border-color: rgba(217, 119, 6, 0.36);
    }
    .status-error {
      background: rgba(180, 35, 24, 0.16);
      color: #9f1e14;
      border-color: rgba(180, 35, 24, 0.36);
    }
    .status-neutral {
      background: rgba(100, 116, 139, 0.18);
      color: var(--text);
      border-color: rgba(100, 116, 139, 0.32);
    }
    .issue-list {
      margin-top: 10px;
      display: grid;
      gap: 10px;
    }
    .issue-item {
      border: 1px solid var(--border);
      border-left: 4px solid transparent;
      border-radius: 10px;
      padding: 10px 11px;
      background: color-mix(in srgb, var(--card) 99%, var(--surface-tint));
      font-size: 13px;
      line-height: 1.35;
      word-break: break-word;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.04);
    }
    .issue-item strong {
      margin-right: 6px;
      text-transform: none;
      font-size: 11px;
      letter-spacing: 0;
      font-weight: 600;
    }
    .issue-item.issue-error {
      border-left-color: #b42318;
    }
    .issue-item.issue-warning {
      border-left-color: #d97706;
    }
    .issue-item.issue-info {
      border-left-color: #475569;
    }
    .dashboard-storage-panel {
      margin-top: 10px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: color-mix(in srgb, var(--card) 99%, var(--surface-tint));
      padding: 10px;
    }
    .dashboard-storage-layout {
      display: grid;
      grid-template-columns: minmax(280px, 1.05fr) minmax(280px, 1fr);
      gap: 14px;
      align-items: start;
    }
    .storage-column {
      min-width: 0;
    }
    .storage-kicker {
      margin: 0 0 8px;
      color: var(--muted);
      font-size: 11px;
      font-weight: 500;
      letter-spacing: 0.02em;
      text-transform: uppercase;
    }
    .storage-donut-wrap {
      display: grid;
      justify-items: center;
      gap: 8px;
    }
    .storage-donut {
      width: 200px;
      height: 200px;
      border-radius: 999px;
      position: relative;
      border: 1px solid color-mix(in srgb, var(--border) 76%, transparent);
      box-shadow: inset 0 0 0 1px color-mix(in srgb, var(--card) 52%, transparent);
    }
    .storage-donut::after {
      content: "";
      position: absolute;
      inset: 24px;
      border-radius: 999px;
      background: color-mix(in srgb, var(--card) 99%, var(--surface-tint));
      border: 1px solid color-mix(in srgb, var(--border) 76%, transparent);
    }
    .storage-donut-center {
      position: absolute;
      inset: 0;
      z-index: 1;
      display: grid;
      place-content: center;
      text-align: center;
      gap: 2px;
      pointer-events: none;
    }
    .storage-donut-label {
      font-size: 11px;
      color: var(--muted);
      font-weight: 500;
    }
    .storage-donut-value {
      font-size: 18px;
      font-weight: 650;
      color: var(--text);
      line-height: 1.1;
    }
    .storage-legend {
      margin: 0;
      padding: 0;
      list-style: none;
      display: grid;
      gap: 6px;
      width: 100%;
    }
    .storage-legend-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      border: 1px solid color-mix(in srgb, var(--border) 82%, transparent);
      border-radius: 8px;
      padding: 6px 8px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
      font-size: 12px;
    }
    .storage-legend-main {
      display: inline-flex;
      align-items: center;
      gap: 7px;
      min-width: 0;
    }
    .storage-swatch {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      flex: 0 0 auto;
      border: 1px solid color-mix(in srgb, #000000 16%, transparent);
    }
    .storage-legend-name {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      color: var(--text);
    }
    .storage-legend-size {
      color: var(--muted);
      font-variant-numeric: tabular-nums;
      flex: 0 0 auto;
    }
    .storage-device-block {
      display: grid;
      gap: 8px;
    }
    .storage-device-meta {
      font-size: 12px;
      color: var(--muted);
      line-height: 1.35;
    }
    .storage-device-bar {
      height: 16px;
      border-radius: 999px;
      border: 1px solid color-mix(in srgb, var(--border) 84%, transparent);
      overflow: hidden;
      display: flex;
      background: color-mix(in srgb, var(--card) 96%, var(--surface-tint));
    }
    .storage-device-used {
      background: linear-gradient(90deg, color-mix(in srgb, var(--accent) 75%, #64748b), color-mix(in srgb, var(--accent-2) 78%, #64748b));
      min-width: 2px;
    }
    .storage-device-free {
      background: color-mix(in srgb, #16a34a 42%, var(--card));
      min-width: 2px;
      border-left: 1px solid color-mix(in srgb, var(--border) 68%, transparent);
    }
    .storage-path-list {
      margin: 0;
      padding: 0;
      list-style: none;
      display: grid;
      gap: 6px;
    }
    .storage-path-item {
      border: 1px solid color-mix(in srgb, var(--border) 82%, transparent);
      border-radius: 8px;
      padding: 6px 8px;
      font-size: 11px;
      line-height: 1.35;
      color: var(--muted);
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
      word-break: break-word;
    }
    .storage-path-item strong {
      font-size: 11px;
      font-weight: 600;
      color: var(--text);
      display: inline-block;
      margin-right: 6px;
    }
    .info-icon {
      display: inline-flex;
      width: 16px;
      height: 16px;
      border-radius: 999px;
      border: 1px solid var(--border);
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: 700;
      background: var(--help-icon-bg);
      color: var(--help-icon-fg);
      cursor: help;
      user-select: none;
      line-height: 1;
      transition: transform 130ms ease, filter 130ms ease;
    }
    .info-icon:hover {
      transform: translateY(-1px);
      filter: brightness(1.07);
    }
    details.raw-json {
      margin-top: 10px;
      border: 1px solid var(--border);
      border-radius: 11px;
      background: color-mix(in srgb, var(--card) 95%, var(--surface-tint));
      overflow: hidden;
    }
    details.raw-json > summary {
      cursor: pointer;
      color: var(--muted);
      font-size: 12px;
      font-weight: 600;
      list-style: none;
      text-transform: none;
      letter-spacing: 0;
      padding: 10px 12px;
      background: color-mix(in srgb, var(--accent-2) 10%, transparent);
    }
    details.raw-json > summary::-webkit-details-marker {
      display: none;
    }
    .dashboard-section-title {
      margin: 13px 0 7px;
      font-size: 13px;
      color: var(--muted);
      font-weight: 600;
      letter-spacing: 0;
      text-transform: none;
    }
    .vector-card-list {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: color-mix(in srgb, var(--card) 99%, var(--surface-tint));
      padding: 12px;
      max-height: 22rem;
      overflow: auto;
      margin-top: 10px;
      display: grid;
      gap: 10px;
    }
    .vector-search-form {
      display: grid;
      grid-template-columns: minmax(0, 1fr) 170px auto;
      gap: 8px;
      margin-bottom: 8px;
      align-items: center;
    }
    .vector-search-form input {
      width: 100%;
      min-width: 0;
    }
    .vector-search-results-title {
      margin: 0;
      font-size: 12px;
      color: var(--muted);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }
    .vector-card {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
      word-break: break-word;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.04);
      display: grid;
      gap: 8px;
    }
    .vector-card-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
    }
    .vector-card h4 {
      margin: 0;
      font-size: 13px;
    }
    .vector-card p {
      margin: 0;
      font-size: 12px;
      color: color-mix(in srgb, var(--muted) 90%, var(--text));
      white-space: pre-wrap;
      line-height: 1.45;
    }
    .vector-hit-snippet {
      margin: 0;
      font-size: 15px;
      line-height: 1.5;
      color: var(--text);
      font-weight: 500;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .vector-hit-score {
      border: 1px solid color-mix(in srgb, var(--accent) 35%, var(--border));
      border-radius: 999px;
      padding: 3px 9px;
      font-size: 11px;
      color: color-mix(in srgb, var(--accent) 74%, var(--text));
      background: color-mix(in srgb, var(--accent) 8%, var(--card));
      font-weight: 700;
      letter-spacing: 0.02em;
    }
    .vector-hit-details > summary {
      cursor: pointer;
      color: var(--muted);
      font-size: 11px;
    }
    .vector-hit-details pre {
      margin-top: 6px;
      max-height: 10rem;
    }
    .vector-admin-panel {
      margin-top: 10px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: color-mix(in srgb, var(--card) 98%, var(--surface-tint));
      padding: 8px;
    }
    .vector-admin-panel > summary {
      cursor: pointer;
      font-size: 12px;
      color: var(--muted);
      font-weight: 600;
    }
    .vector-search-loading {
      border: 1px dashed color-mix(in srgb, var(--accent) 40%, var(--border));
      border-radius: 9px;
      padding: 11px;
      font-size: 13px;
      color: color-mix(in srgb, var(--accent) 72%, var(--text));
      background: color-mix(in srgb, var(--accent) 9%, var(--card));
    }
    .sources-url-list {
      margin: 0;
      padding-left: 18px;
      display: grid;
      gap: 6px;
      word-break: break-word;
    }
    .sources-url-list code {
      word-break: break-all;
    }
    .sources-text-preview {
      margin: 0;
      max-height: 180px;
      overflow: auto;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 9px;
      background: color-mix(in srgb, var(--card) 100%, var(--surface-tint));
      font-size: 12px;
      line-height: 1.45;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .sources-phase-item {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 9px;
      background: color-mix(in srgb, var(--card) 98%, var(--surface-tint));
      display: grid;
      gap: 6px;
    }
    .sources-phase-item.ok {
      border-color: color-mix(in srgb, #16a34a 42%, var(--border));
    }
    .sources-phase-item.fail {
      border-color: color-mix(in srgb, #f59e0b 34%, var(--border));
    }
    .sources-phase-head {
      margin: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      flex-wrap: wrap;
    }
    .sources-phase-item p {
      margin: 0;
      font-size: 12px;
      line-height: 1.4;
      color: color-mix(in srgb, var(--muted) 85%, var(--text));
    }
    .help-icon {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 30px;
      height: 30px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: var(--help-icon-bg);
      color: var(--help-icon-fg);
      font-weight: 700;
      line-height: 1;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      min-width: 30px;
      box-shadow: 0 7px 16px rgba(0, 0, 0, 0.16);
      transition: transform 140ms ease, filter 140ms ease;
      z-index: 2;
    }
    .help-icon:hover {
      filter: brightness(1.08);
      transform: translateY(-1px);
    }
    .help-modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: var(--help-overlay);
      z-index: 999;
      padding: 18px;
    }
    .help-modal.open {
      display: flex;
      animation: fadeIn 170ms ease;
    }
    .help-panel {
      width: min(920px, 100%);
      max-height: 86vh;
      overflow: auto;
      background: linear-gradient(170deg, color-mix(in srgb, var(--help-panel-bg) 92%, var(--surface-tint)), var(--help-panel-bg));
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 16px;
      box-shadow: 0 24px 60px rgba(12, 25, 41, 0.35);
      animation: panelFloatIn 190ms ease;
    }
    .help-panel::-webkit-scrollbar,
    .nav-column::-webkit-scrollbar,
    .vector-card-list::-webkit-scrollbar,
    .inspector-list::-webkit-scrollbar,
    .db-grid-scroll::-webkit-scrollbar,
    pre::-webkit-scrollbar {
      width: 10px;
      height: 10px;
    }
    .help-panel::-webkit-scrollbar-thumb,
    .nav-column::-webkit-scrollbar-thumb,
    .vector-card-list::-webkit-scrollbar-thumb,
    .inspector-list::-webkit-scrollbar-thumb,
    .db-grid-scroll::-webkit-scrollbar-thumb,
    pre::-webkit-scrollbar-thumb {
      background: color-mix(in srgb, var(--accent) 32%, var(--border));
      border-radius: 999px;
      border: 2px solid transparent;
      background-clip: padding-box;
    }
    .help-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      gap: 10px;
    }
    .help-head h3 { margin: 0; font-size: 18px; }
    .help-content h4 { margin: 12px 0 6px; }
    .help-content p { margin: 0 0 8px; }
    .help-content ul { margin: 0 0 12px 18px; padding: 0; }
    .help-content li { margin-bottom: 4px; }
    .help-content code {
      font-family: var(--font-mono);
      background: var(--help-code-bg);
      color: var(--help-code-fg);
      border-radius: 4px;
      padding: 1px 4px;
    }
    .help-content pre {
      margin: 8px 0 12px;
      max-height: none;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .help-content pre code {
      background: transparent;
      color: inherit;
      padding: 0;
      border-radius: 0;
    }
    @keyframes panelFade {
      from {
        opacity: 0;
        transform: translateY(7px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    @keyframes navSlideIn {
      from {
        opacity: 0;
        transform: translateX(-8px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }
    @keyframes panelFloatIn {
      from {
        opacity: 0;
        transform: translateY(10px) scale(0.99);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    @keyframes navActivitySpin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    @media (max-width: 980px) {
      .app-shell {
        grid-template-columns: 1fr;
        padding: 14px 12px 22px;
      }
      .nav-column {
        position: static;
        top: auto;
        left: auto;
        bottom: auto;
        width: auto;
        max-height: none;
        z-index: auto;
      }
      .nav-list {
        display: flex;
        flex-wrap: nowrap;
        overflow-x: auto;
      }
      .nav-btn {
        flex: 0 0 auto;
        width: auto;
        min-width: 178px;
      }
    }
    @media (prefers-reduced-motion: reduce) {
      .workspace-panel.active,
      .help-panel,
      .help-modal.open,
      .nav-btn {
        animation: none;
      }
      button,
      .help-icon,
      .nav-btn,
      .dropzone,
      .info-icon {
        transition: none;
      }
    }
    @media (max-width: 640px) {
      .card {
        padding: 10px;
      }
      .viewer-topbar {
        flex-direction: column;
      }
      .viewer-topbar-actions {
        width: 100%;
        justify-content: flex-start;
      }
      .viewer-doc-title {
        font-size: 18px;
      }
      .viewer-toolbar {
        align-items: flex-start;
      }
      .viewer-toolbar-overlays {
        margin-left: 0;
      }
      .metric-grid,
      .dashboard-grid {
        grid-template-columns: 1fr;
      }
      .vector-card-list,
      .inspector-list {
        max-height: 18rem;
      }
      .import-live {
        grid-template-columns: 1fr;
      }
      .doc-viewer-layout {
        grid-template-columns: 1fr;
      }
      .viewer-structured-grid {
        grid-template-columns: 1fr;
      }
      .vector-search-form {
        grid-template-columns: 1fr;
      }
      .doc-viewer-index {
        min-height: 0;
      }
      .doc-viewer-side {
        min-height: 0;
      }
      .viewer-fallback-embed object,
      .viewer-fallback-embed iframe,
      .viewer-fallback-embed embed {
        min-height: 380px;
      }
      .import-preview {
        min-height: 240px;
      }
      .import-preview embed,
      .import-preview iframe,
      .import-preview img {
        height: 240px;
        max-height: 240px;
      }
      .import-preview-text-content {
        max-height: 238px;
      }
      .import-preview-generic-embed {
        min-height: 236px;
      }
      .import-preview-pdf-canvas-wrap {
        width: min(232px, 96%);
        min-height: 248px;
      }
      .dashboard-storage-layout {
        grid-template-columns: 1fr;
        gap: 10px;
      }
      .storage-donut {
        width: 170px;
        height: 170px;
      }
      .storage-donut::after {
        inset: 20px;
      }
    }
  </style>
</head>
<body data-theme="harmonious-light">
  <header>
    <div class="header-top">
      <div class="brand-block">
        <div class="brand-identity">
          <img class="app-icon" src="/static/icons/icon-header-gold.png" alt="Stemma Codicum icon" />
          <h1>Stemma Codicum</h1>
        </div>
      </div>
      <div class="theme-picker">
        <label for="theme-select">Theme</label>
        <select id="theme-select" onchange="setTheme(this.value)">
          <option value="harmonious-light">Soft Light</option>
          <option value="restful-dark">Slate Dark</option>
          <option value="forest-mist">Forest Mist</option>
          <option value="sunset-paper">Paper Warm</option>
          <option value="midnight-contrast">Midnight Slate</option>
        </select>
      </div>
    </div>
  </header>
  <main class="app-shell">
    <aside class="nav-column">
      <div class="nav-list">
        <button class="secondary nav-btn" type="button" data-pane="dashboard">Home</button>
        <button class="secondary nav-btn" type="button" data-pane="project">Project and Health</button>
        <button class="secondary nav-btn" type="button" data-pane="database">Database Explorer</button>
        <button class="secondary nav-btn" type="button" data-pane="viewer">Document Viewer</button>
        <button class="secondary nav-btn" type="button" data-pane="ingest">Import</button>
        <button class="secondary nav-btn" type="button" data-pane="references">References</button>
        <button class="secondary nav-btn" type="button" data-pane="sources">Sources</button>
        <button class="secondary nav-btn" type="button" data-pane="extraction">Extraction</button>
        <button class="secondary nav-btn" type="button" data-pane="vector">Vector</button>
        <button class="secondary nav-btn" type="button" data-pane="claims">Claims</button>
        <button class="secondary nav-btn" type="button" data-pane="binding">Binding</button>
        <button class="secondary nav-btn" type="button" data-pane="verification">Verification and Reports</button>
        <button class="secondary nav-btn" type="button" data-pane="trace">Trace</button>
        <button class="secondary nav-btn" type="button" data-pane="ceapf">CEAPF</button>
      </div>
    </aside>

    <section class="workspace">
      <section class="card workspace-panel" data-pane="dashboard" data-help-key="dashboard">
      <div class="row">
        <button onclick="loadDashboard()">Refresh Summary</button>
        <button class="secondary" onclick="loadDashboard(true)">Refresh + Doctor</button>
      </div>
      <p id="dashboard-status" class="small">Load summary to view overall system status.</p>
      <h3 class="dashboard-section-title">System Snapshot</h3>
      <div id="dashboard-kpis" class="dashboard-grid"></div>
      <h3 class="dashboard-section-title">Storage and Paths</h3>
      <div id="dashboard-storage" class="dashboard-storage-panel">
        <p class="small">No storage summary loaded yet.</p>
      </div>
      <h3 class="dashboard-section-title">Recent Runs</h3>
      <div id="dashboard-runs" class="issue-list">
        <p class="small">No dashboard summary loaded yet.</p>
      </div>
      <details class="raw-json">
        <summary>Raw JSON</summary>
        <pre id="out-dashboard"></pre>
      </details>
      </section>

      <section class="card workspace-panel" data-pane="project" data-help-key="project">
      <div class="row">
        <button onclick="runInitProject()">Init Project</button>
        <button class="secondary" onclick="runDoctor()">Doctor</button>
      </div>
      <p id="project-health-status" class="small">Run Doctor to load health diagnostics.</p>
      <div id="project-health-visual" class="metric-grid"></div>
      <div id="project-health-issues" class="issue-list">
        <p class="small">No health issues loaded.</p>
      </div>
      <details class="raw-json">
        <summary>Raw JSON</summary>
        <pre id="out-project"></pre>
      </details>
      </section>

      <section class="card workspace-panel" data-pane="database" data-help-key="database">
      <div class="row">
        <button class="secondary" onclick="dbListTables()">List Tables</button>
        <select id="db-table-select">
          <option value="">Select table</option>
        </select>
      </div>
      <div class="row">
        <input id="db-limit" value="50" placeholder="Row limit" />
        <input id="db-offset" value="0" placeholder="Offset" />
        <button onclick="dbViewTable()">View Rows</button>
        <button class="secondary" onclick="dbDescribeTable()">Table Schema</button>
      </div>
      <div id="db-grid-controls" class="row db-grid-controls">
        <select id="db-view-mode" onchange="dbSetViewMode(this.value)">
          <option value="spreadsheet">Spreadsheet View</option>
          <option value="json">JSON View</option>
        </select>
        <input id="db-search" placeholder="Search current view (all columns)" />
        <button id="db-clear-filters" class="secondary" onclick="dbClearFilters()">Clear Filters</button>
      </div>
      <p class="small">Inspect table names, row counts, schema, and sample rows.</p>
      <div id="db-grid-view">
        <p class="small" id="db-grid-meta">Load a table to inspect data in spreadsheet mode.</p>
        <div class="db-grid-scroll">
          <table id="db-grid-table" class="db-grid-table"></table>
        </div>
      </div>
      <pre id="out-db"></pre>
      </section>

      <section class="card workspace-panel" data-pane="viewer" data-help-key="viewer">
      <div class="viewer-topbar">
        <div class="viewer-topbar-main">
          <p id="viewer-breadcrumb" class="viewer-breadcrumb">Project / Document Viewer</p>
          <div class="viewer-title-row">
            <h2 id="viewer-doc-title" class="viewer-doc-title">No document selected</h2>
            <button class="secondary viewer-title-edit" type="button" onclick="viewerPromptRenameTitle()">Rename</button>
          </div>
          <p id="viewer-doc-subtitle" class="small viewer-doc-subtitle">Select a document to read the source file and inspect extracted content.</p>
        </div>
        <div class="viewer-topbar-actions">
          <button class="secondary" type="button" onclick="viewerDownloadCurrent()">Download</button>
          <button class="secondary" type="button" onclick="viewerOpenCurrentExternal()">Open externally</button>
          <button class="secondary" type="button" onclick="viewerCopyDocumentLink()">Copy link</button>
          <button id="viewer-info-toggle" class="secondary" type="button" onclick="viewerToggleInspector()" aria-expanded="false" aria-controls="viewer-inspector">Info</button>
          <details class="viewer-more-actions">
            <summary>More</summary>
            <div class="viewer-more-menu">
              <button class="secondary" type="button" onclick="viewerCopyInternalReference()">Copy internal reference</button>
              <button class="secondary" type="button" onclick="viewerCopyDiagnosticReport()">Copy diagnostic report</button>
            </div>
          </details>
        </div>
      </div>
      <details class="viewer-dev-tools">
        <summary>Developer tools</summary>
        <div class="row">
          <select id="viewer-resource-select">
            <option value="">Select resource</option>
          </select>
          <button class="secondary" onclick="viewerRefreshResources()">Refresh Resources</button>
          <button onclick="viewerOpenSelected()">Open document</button>
        </div>
        <div class="row">
          <input id="viewer-resource-id" placeholder="Resource ID or digest" />
          <button class="secondary" onclick="viewerOpenFromInput()">Open by internal reference</button>
        </div>
      </details>
      <div class="row viewer-toolbar">
        <div class="viewer-toolbar-group">
          <button class="secondary" onclick="viewerPrevPage()">Prev Page</button>
          <button class="secondary" onclick="viewerNextPage()">Next Page</button>
          <span id="viewer-page-label" class="small">Page 1 / 1</span>
        </div>
        <div class="viewer-toolbar-group">
          <button class="secondary" onclick="viewerZoomOut()">-</button>
          <button class="secondary" onclick="viewerZoomIn()">+</button>
          <button class="secondary" onclick="viewerFitWidth()">Fit width</button>
          <span id="viewer-zoom-label" class="small">100%</span>
        </div>
        <div class="viewer-toolbar-group viewer-toolbar-overlays">
          <label class="viewer-toggle"><input id="viewer-toggle-tables" type="checkbox" checked onchange="viewerRenderOverlay()">Tables</label>
          <label class="viewer-toggle"><input id="viewer-toggle-segments" type="checkbox" checked onchange="viewerRenderOverlay()">Segments</label>
          <label class="viewer-toggle"><input id="viewer-toggle-annotations" type="checkbox" checked onchange="viewerRenderOverlay()">Annotations</label>
          <label class="viewer-toggle"><input id="viewer-pan-toggle" type="checkbox" onchange="viewerTogglePan(this.checked)">Pan Drag</label>
          <span id="viewer-render-mode-badge" class="viewer-mode-badge">No document</span>
        </div>
      </div>
      <p id="viewer-status" class="small viewer-status" aria-live="polite">Select a resource to inspect original source content, metadata, extracted tables, and annotation structure.</p>
      <div id="viewer-layout" class="doc-viewer-layout">
        <aside id="viewer-index" class="doc-viewer-index">
          <h3 class="dashboard-section-title">Extraction Index</h3>
          <div class="viewer-index-controls">
            <input id="viewer-index-search" placeholder="Search tables, segments, annotations" />
            <select id="viewer-index-type">
              <option value="all">All types</option>
              <option value="tables">Tables only</option>
              <option value="segments">Segments only</option>
              <option value="annotations">Annotations only</option>
            </select>
          </div>
          <div class="viewer-index-groups">
            <details class="viewer-index-group" open>
              <summary>Tables</summary>
              <div id="viewer-index-table-list" class="viewer-index-list">
                <p class="small">No tables loaded.</p>
              </div>
              <div class="viewer-index-pagination">
                <button id="viewer-index-table-prev" type="button" class="secondary">Prev</button>
                <button id="viewer-index-table-next" type="button" class="secondary">Next</button>
                <span id="viewer-index-table-page" class="small">Page 1 / 1</span>
              </div>
            </details>
            <details class="viewer-index-group" open>
              <summary>Segments</summary>
              <div id="viewer-index-segment-list" class="viewer-index-list">
                <p class="small">No segments loaded.</p>
              </div>
            </details>
            <details class="viewer-index-group">
              <summary>Annotations</summary>
              <div id="viewer-index-annotation-list" class="viewer-index-list">
                <p class="small">No annotations loaded.</p>
              </div>
            </details>
          </div>
        </aside>
        <div class="doc-viewer-stage">
          <div id="viewer-scroll" class="doc-viewer-scroll">
            <canvas id="viewer-pdf-canvas"></canvas>
            <canvas id="viewer-overlay-canvas"></canvas>
            <div id="viewer-fallback" class="doc-viewer-fallback">
              <div class="viewer-empty-state">
                <h3>Open a document to begin</h3>
                <p class="small">The viewer shows the original file, while the inspector provides overlays, tables, and annotations.</p>
              </div>
            </div>
          </div>
        </div>
        <aside id="viewer-inspector" class="doc-viewer-side">
          <h3 class="dashboard-section-title">Verification Inspector</h3>
          <p id="viewer-selection-summary" class="viewer-selection-summary">Select an extracted item from the left index or click a highlighted region in the PDF.</p>
          <div id="viewer-metadata" class="viewer-inspector-meta">
            <p class="small">No resource loaded.</p>
          </div>
          <section class="viewer-inspector-section">
            <h4>Extracted Images</h4>
            <div id="viewer-image-gallery" class="viewer-image-gallery">
              <p class="small">No extracted images available.</p>
            </div>
          </section>
          <section class="viewer-inspector-section">
            <h4>Selected Data</h4>
            <div class="viewer-inspector-tabs">
              <button id="viewer-tab-overlays" type="button" class="secondary active" onclick="viewerSetInspectorTab('overlays')">Segments</button>
              <button id="viewer-tab-tables" type="button" class="secondary" onclick="viewerSetInspectorTab('tables')">Table</button>
              <button id="viewer-tab-annotations" type="button" class="secondary" onclick="viewerSetInspectorTab('annotations')">Annotation</button>
            </div>
            <div id="viewer-panel-overlays" class="viewer-inspector-panel">
              <div id="viewer-overlay-list" class="inspector-list">
                <p class="small">No overlays yet.</p>
              </div>
            </div>
            <div id="viewer-panel-tables" class="viewer-inspector-panel" hidden>
              <div id="viewer-table-actions" class="row viewer-table-actions" hidden>
                <button class="secondary" type="button" onclick="viewerMarkSelection('approved')">Approve</button>
                <button class="secondary" type="button" onclick="viewerMarkSelection('needs_review')">Flag Review</button>
                <button class="secondary" id="viewer-edit-table-btn" type="button" onclick="viewerToggleTableEditMode()">Enable Edit</button>
                <span id="viewer-review-status" class="small"></span>
              </div>
              <div class="row">
                <input id="viewer-cell-row" placeholder="Row (1-based)" />
                <input id="viewer-cell-col" placeholder="Col (1-based)" />
                <button class="secondary" onclick="viewerFocusCell()">Focus Cell</button>
              </div>
              <p id="viewer-cell-status" class="small"></p>
              <div id="viewer-table-grid" class="db-grid-scroll">
                <p class="small">No table selected.</p>
              </div>
            </div>
            <div id="viewer-panel-annotations" class="viewer-inspector-panel" hidden>
              <div id="viewer-annotation-list" class="inspector-list">
                <p class="small">No annotations loaded.</p>
              </div>
            </div>
            <details class="viewer-tech-details">
              <summary>Developer tools</summary>
              <pre id="viewer-selected-raw">Select an element to inspect raw data.</pre>
            </details>
          </section>
        </aside>
      </div>
      <p id="viewer-toast" class="viewer-toast" aria-live="polite"></p>
      <details class="raw-json">
        <summary>Raw JSON</summary>
        <pre id="out-viewer"></pre>
      </details>
      </section>

      <section class="card workspace-panel" data-pane="ingest" data-help-key="ingest">
      <div id="dropzone" class="dropzone">Drop documents or folders here to import</div>
      <p id="dropzone-scan-status" class="dropzone-scan-status" aria-live="polite"></p>
      <div class="row">
        <input id="ingest-path" placeholder="Absolute file path" />
        <button onclick="ingestPath()">Import File Path</button>
      </div>
      <div class="row">
        <input id="resources-limit" value="20" />
        <button class="secondary" onclick="listResources()">List Resources</button>
      </div>
      <h3 class="import-history-title">Current Import</h3>
      <div id="import-live" class="import-live current-focus empty">
        <p class="small">Drop one or more documents to begin. This panel shows the currently processing file with thumbnail preview, staged progress, extraction/table/vector status, and confirmation metadata.</p>
      </div>
      <h3 class="import-history-title">Drop Queue</h3>
      <div id="import-drop-queue" class="import-queue">
        <p class="small">No files queued.</p>
      </div>
      <h3 class="import-history-title">Recent Imports</h3>
      <div id="import-history" class="import-history">
        <p class="small">No imports yet.</p>
      </div>
      <h3 class="dashboard-section-title">Mass Import (Recursive)</h3>
      <div class="row">
        <input id="pipe-root" value="/Volumes/X10/data/Institution" placeholder="Root directory" />
        <input id="pipe-max" placeholder="Max files (optional)" value="25" />
        <input id="pipe-timeout" placeholder="Extract timeout sec" value="300" />
        <select id="pipe-skip">
          <option value="false">extract enabled</option>
          <option value="true">skip extraction</option>
        </select>
        <button class="secondary" onclick="runMassImport()">Run Mass Import</button>
      </div>
      <p class="small">Mass import recursively scans the root path and processes all supported document types.</p>
      <details class="raw-json">
        <summary>Raw JSON</summary>
        <pre id="out-ingest"></pre>
      </details>
      </section>

      <section class="card workspace-panel" data-pane="references" data-help-key="references">
      <div class="row">
        <input id="bib-path" placeholder="/path/to/references.bib" />
        <button onclick="importBib()">Import BibTeX</button>
      </div>
      <div class="row">
        <input id="link-cite-id" placeholder="Cite ID" />
        <input id="link-digest" placeholder="Resource digest" />
        <button onclick="linkReference()">Link Ref->Resource</button>
      </div>
      <div class="row">
        <button class="secondary" onclick="callApi('GET','/api/refs',null,'out-refs')">List Refs</button>
        <button class="secondary" onclick="callApi('GET','/api/citations',null,'out-refs')">List Citations</button>
      </div>
      <pre id="out-refs"></pre>
      </section>

      <section class="card workspace-panel" data-pane="sources" data-help-key="sources">
      <div class="row">
        <input id="sources-filter" placeholder="Filter by title, filename, ID, URL" />
        <label class="viewer-toggle"><input id="sources-missing-only" type="checkbox" checked />Missing source only</label>
        <button class="secondary" onclick="sourcesRefreshResources()">Refresh</button>
      </div>
      <div class="row">
        <select id="sources-resource-select">
          <option value="">Select document</option>
        </select>
        <button onclick="sourcesLoadSelected()">Load Document</button>
      </div>
      <p id="sources-status" class="small">Choose a document to inspect and recover canonical source URLs/identifiers.</p>
      <div id="sources-summary" class="metric-grid"></div>
      <div id="sources-current" class="issue-list">
        <p class="small">No document selected.</p>
      </div>
      <div class="row">
        <button id="sources-recover-local-btn" class="secondary" onclick="sourcesRecover(false)">Recover From Local Metadata</button>
        <button id="sources-recover-web-btn" onclick="sourcesRecover(true)">Search Web And Recover</button>
        <label class="viewer-toggle"><input id="sources-wayback-toggle" type="checkbox" checked />Wayback</label>
        <label class="viewer-toggle"><input id="sources-manifest-toggle" type="checkbox" checked />Manifest scan</label>
      </div>
      <div class="row">
        <input id="sources-manual-url" placeholder="Set primary source URL or DOI" />
        <button class="secondary" onclick="sourcesSetPrimary()">Save Primary Source</button>
      </div>
      <h3 class="dashboard-section-title">Recovery Phase Log</h3>
      <div id="sources-recovery-log" class="inspector-list">
        <p class="small">No recovery run yet.</p>
      </div>
      <details class="raw-json">
        <summary>Raw JSON</summary>
        <pre id="out-sources"></pre>
      </details>
      </section>

      <section class="card workspace-panel" data-pane="extraction" data-help-key="extraction">
      <div class="row">
        <input id="extract-resource-id" placeholder="Resource ID (optional)" />
        <input id="extract-digest" placeholder="Resource digest (optional)" />
        <button onclick="extractRun()">Run Extract</button>
      </div>
      <div class="row">
        <input id="extract-tables-id" placeholder="Resource ID (optional)" />
        <input id="extract-tables-digest" placeholder="Resource digest (optional)" />
        <button class="secondary" onclick="extractTables()">List Tables</button>
      </div>
      <p class="small">Extraction Inspector: inspect canonical text, standoff segments, annotations, and full extraction dumps.</p>
      <div class="row">
        <input id="inspect-resource-id" placeholder="Inspector resource ID (optional)" />
        <input id="inspect-resource-digest" placeholder="Inspector resource digest (optional)" />
        <input id="inspect-run-id" placeholder="Inspector run ID (optional, latest if empty)" />
      </div>
      <div class="row">
        <input id="inspect-segment-type" placeholder="Segment type filter (e.g. layout:paragraph)" />
        <input id="inspect-layer" placeholder="Layer filter (e.g. domain_financial)" />
        <input id="inspect-category" placeholder="Category filter (e.g. metric)" />
        <input id="inspect-limit" value="200" placeholder="Limit" />
      </div>
      <div class="row">
        <input id="inspect-segment-limit" value="2000" placeholder="Dump segment limit" />
        <input id="inspect-annotation-limit" value="2000" placeholder="Dump annotation limit" />
        <input id="inspect-table-limit" value="500" placeholder="Dump table limit" />
      </div>
      <div class="row">
        <button class="secondary" onclick="extractInspectorText()">Inspect Text</button>
        <button class="secondary" onclick="extractInspectorSegments()">Inspect Segments</button>
        <button class="secondary" onclick="extractInspectorAnnotations()">Inspect Annotations</button>
        <button class="secondary" onclick="extractInspectorDump()">Inspect Dump</button>
      </div>
      <div id="extract-inspector-list" class="inspector-list">
        <p class="small">No inspector items loaded yet.</p>
      </div>
      <p id="extract-inspector-copy-status" class="inspector-copy-status"></p>
      <pre id="out-extract"></pre>
      <pre id="out-extract-inspector"></pre>
      </section>

      <section class="card workspace-panel" data-pane="vector" data-help-key="vector">
      <div class="row">
        <input id="vector-resource-id" placeholder="Resource ID (optional)" />
        <input id="vector-resource-digest" placeholder="Resource digest (optional)" />
        <input id="vector-extraction-run-id" placeholder="Extraction run ID (optional)" />
      </div>
      <div class="row">
        <input id="vector-status-limit" value="25" placeholder="Status run limit" />
        <select id="vector-force">
          <option value="false">skip if already indexed</option>
          <option value="true">force re-index</option>
        </select>
        <button onclick="vectorIndex()">Index</button>
        <button class="secondary" onclick="vectorStatus()">Status</button>
      </div>
      <div class="row">
        <input id="vector-backfill-limit-resources" value="100000" placeholder="Backfill limit resources" />
        <input id="vector-backfill-max-process" placeholder="Backfill max process (optional)" />
        <button class="secondary" onclick="vectorBackfill()">Backfill</button>
      </div>
      <p class="vector-search-results-title">Semantic Search</p>
      <form id="vector-search-form" class="vector-search-form">
        <input id="vector-query" placeholder="Semantic query" />
        <input id="vector-query-limit" value="10" placeholder="Search limit" />
        <button id="vector-search-btn" class="secondary" type="submit">Search</button>
      </form>
      <div id="vector-search-results" class="vector-card-list">
        <p class="small">No vector search results yet.</p>
      </div>
      <details id="vector-admin-panel" class="vector-admin-panel">
        <summary>Vector indexing runs and backend stats</summary>
        <p id="vector-status-note" class="small">Load status to inspect vector backend health and run history.</p>
        <div id="vector-summary" class="metric-grid"></div>
        <div id="vector-runs" class="vector-card-list">
          <p class="small">No vector runs loaded yet.</p>
        </div>
      </details>
      <details class="raw-json">
        <summary>Raw JSON</summary>
        <pre id="out-vector"></pre>
      </details>
      </section>

      <section class="card workspace-panel" data-pane="claims" data-help-key="claims">
      <div class="row">
        <input id="claims-file" placeholder="Claims file path" />
        <select id="claims-format">
          <option value="csv">csv</option>
          <option value="json">json</option>
          <option value="md">md</option>
        </select>
        <input id="claim-set" placeholder="Claim set name" />
        <button onclick="importClaims()">Import Claims</button>
      </div>
      <div class="row">
        <input id="claims-list-set" placeholder="Claim set filter (optional)" />
        <button class="secondary" onclick="listClaims()">List Claims</button>
        <button class="secondary" onclick="callApi('GET','/api/claim-sets',null,'out-claims')">List Claim Sets</button>
      </div>
      <pre id="out-claims"></pre>
      </section>

      <section class="card workspace-panel" data-pane="binding" data-help-key="binding">
      <div class="row">
        <input id="bind-claim-id" placeholder="Claim ID" />
        <input id="bind-resource-id" placeholder="Resource ID (optional)" />
        <input id="bind-digest" placeholder="Resource digest (optional)" />
      </div>
      <div class="row">
        <input id="bind-role" placeholder="Role (value-cell/quote/etc.)" />
      </div>
      <textarea id="bind-selectors">[{"type":"PageGeometrySelector","pageIndex":0,"boxes":[]},{"type":"TextQuoteSelector","exact":"example"}]</textarea>
      <div class="row">
        <button onclick="bindAdd()">Add Binding</button>
        <button class="secondary" onclick="bindValidate()">Validate Binding</button>
      </div>
      <pre id="out-bind"></pre>
      </section>

      <section class="card workspace-panel" data-pane="verification" data-help-key="verification">
      <div class="row">
        <input id="verify-claim-id" placeholder="Claim ID" />
        <button onclick="verifyClaim()">Verify Claim</button>
      </div>
      <div class="row">
        <input id="verify-claim-set" placeholder="Claim set" />
        <button onclick="verifySet()">Verify Set</button>
      </div>
      <div class="row">
        <input id="report-run-id" placeholder="Verification run ID" />
        <input id="report-json-out" placeholder="json output path (optional)" />
        <input id="report-md-out" placeholder="md output path (optional)" />
        <button class="secondary" onclick="reportVerification()">Get Report</button>
      </div>
      <pre id="out-verify"></pre>
      </section>

      <section class="card workspace-panel" data-pane="trace" data-help-key="trace">
      <div class="row">
        <input id="trace-claim-id" placeholder="Claim ID" />
        <button onclick="traceClaim()">Trace Claim</button>
      </div>
      <div class="row">
        <input id="trace-resource-id" placeholder="Resource ID (optional)" />
        <input id="trace-resource-digest" placeholder="Resource digest (optional)" />
        <button onclick="traceResource()">Trace Resource</button>
      </div>
      <div class="row">
        <input id="trace-cite-id" placeholder="Cite ID" />
        <button onclick="traceCitation()">Trace Citation</button>
      </div>
      <pre id="out-trace"></pre>
      </section>

      <section class="card workspace-panel" data-pane="ceapf" data-help-key="ceapf">
      <textarea id="ceapf-prop">{"subject":"org:InstitutionZ","predicate":"ceapf:spent","object":{"amount":3.4,"unit":"GBP"}}</textarea>
      <div class="row">
        <button onclick="addProposition()">Add Proposition</button>
        <button class="secondary" onclick="listPropositions()">List Propositions</button>
      </div>
      <div class="row">
        <input id="ceapf-prop-id" placeholder="Proposition ID" />
        <input id="ceapf-agent" placeholder="Agent" value="person:AuthorX" />
        <input id="ceapf-modality" placeholder="Modality" value="asserts" />
        <button onclick="addAssertion()">Add Assertion</button>
      </div>
      <div class="row">
        <input id="ceapf-rel-type" placeholder="Relation type" value="supports" />
        <input id="ceapf-from-type" placeholder="From type" value="assertion_event" />
        <input id="ceapf-from-id" placeholder="From ID" />
        <input id="ceapf-to-type" placeholder="To type" value="proposition" />
        <input id="ceapf-to-id" placeholder="To ID" />
        <button onclick="addRelation()">Add Relation</button>
      </div>
      <pre id="out-ceapf"></pre>
      </section>

    </section>
  </main>

<div id="help-modal" class="help-modal" aria-hidden="true">
  <div class="help-panel">
    <div class="help-head">
      <h3 id="help-title">Help</h3>
      <button class="secondary" onclick="closeHelp()">Close</button>
    </div>
    <div id="help-content" class="help-content"></div>
  </div>
</div>

<script>
const HELP_CONTENT = {
  dashboard: {
    title: "Home",
    basic: `
      <p>Use this panel for a single-page summary of core system health and workload state.</p>
      <ul>
        <li><code>Refresh Summary</code>: lightweight snapshot (counts + recent runs + vector state).</li>
        <li><code>Refresh + Doctor</code>: includes full integrity checks.</li>
      </ul>
    `,
    full: `
      <p>The dashboard is intended for triage and routine checks before deeper workflows.</p>
      <h4>Recommended cadence</h4>
      <ul>
        <li>Use lightweight summary during active work.</li>
        <li>Use doctor refresh before major ingest/extract batches.</li>
      </ul>
      <pre><code>GET /api/dashboard/summary
GET /api/dashboard/summary?include_doctor=true</code></pre>
    `,
  },
  project: {
    title: "Project and Health",
    basic: `
      <p>Use this card to initialize project files and run diagnostic checks.</p>
      <h4>Core actions</h4>
      <ul>
        <li><code>Init Project</code>: creates/repairs <code>.stemma/</code> and database schema.</li>
        <li><code>Doctor</code>: runs integrity checks and DB runtime checks.</li>
      </ul>
      <h4>Example flow</h4>
      <pre><code>1) Click Init Project
2) Click Doctor
3) Confirm "ok": true and db_runtime.journal_mode = "wal"</code></pre>
    `,
    full: `
      <p>This card corresponds to <code>stemma init</code> and <code>stemma doctor</code>. Run these before batch work or after crashes.</p>
      <h4>When to use</h4>
      <ul>
        <li>Fresh project setup.</li>
        <li>Before/after long import runs.</li>
        <li>To verify DB concurrency settings and archive integrity.</li>
      </ul>
      <h4>Example</h4>
      <pre><code>POST /api/init
GET /api/doctor

Expected doctor signals:
- checks_run >= 4
- db_runtime.journal_mode = "wal"
- db_runtime.busy_timeout_ms > 0</code></pre>
    `,
  },
  database: {
    title: "Database Explorer",
    basic: `
      <p>Inspect real database state: table list, row counts, schema, and sample rows.</p>
      <h4>Quick start</h4>
      <ul>
        <li>Click <code>List Tables</code> to load all tables and counts.</li>
        <li>Select a table and click <code>View Rows</code>.</li>
        <li>Use <code>Spreadsheet View</code> for sortable/filterable grid output.</li>
        <li>Use <code>Table Schema</code> to view create SQL and columns.</li>
      </ul>
      <h4>Example</h4>
      <pre><code>Table: resources
Limit: 50
Offset: 0
Action: View Rows</code></pre>
    `,
    full: `
      <p>This card is for learning and diagnostics. It uses read-only style inspection endpoints.</p>
      <h4>Recommended checks</h4>
      <ul>
        <li>After ingest: verify rows in <code>resources</code> and <code>resource_digests</code>.</li>
        <li>After extraction: verify <code>extraction_runs</code> and <code>extracted_tables</code>.</li>
        <li>After binding/verification: inspect <code>evidence_*</code> and <code>verification_*</code> tables.</li>
        <li>Use global search + per-column filters to narrow large result sets quickly.</li>
      </ul>
      <h4>Example sequence</h4>
      <pre><code>1) List Tables
2) Table Schema on extraction_runs
3) View Rows on extraction_runs (limit 20)
4) View Rows on extracted_tables (limit 20)</code></pre>
    `,
  },
  viewer: {
    title: "Document Viewer",
    basic: `
      <p>Inspect a source document with metadata, extraction overlays, table structures, and annotation traces.</p>
      <ul>
        <li>Load a resource by dropdown, ID, or digest.</li>
        <li>Use page + zoom controls and optional drag-pan mode for PDF navigation.</li>
        <li>Toggle table/segment/annotation overlays.</li>
        <li>Inspect table cells by row/column and review annotation snippets.</li>
      </ul>
    `,
    full: `
      <p>This panel combines immutable source file viewing with extracted structural data for audit workflows.</p>
      <h4>Designed for audit trails</h4>
      <ul>
        <li>Metadata: digest, media type, source URI, archive path, and ingest timestamps.</li>
        <li>Geometry overlays: table/segment bboxes when available from parser output.</li>
        <li>Table inspector: inspect row/col values and approximate cell coordinates.</li>
        <li>Annotation inspector: review labels/spans with contextual text snippets.</li>
      </ul>
      <pre><code>1) Open a resource
2) Move to page N
3) Select table T
4) Focus row R / col C for value traceability</code></pre>
    `,
  },
  ingest: {
    title: "Import",
    basic: `
      <p>Add source files into immutable archive storage with deduplication.</p>
      <ul>
        <li>Use drag/drop for quick file or folder import with recursive queue tracking.</li>
        <li>Use absolute path import for scripted workflows.</li>
        <li>Use mass import for recursive directory processing.</li>
        <li>Use <code>List Resources</code> to verify digest + metadata.</li>
      </ul>
      <pre><code>Path example:
/Users/you/downloads/report.pdf</code></pre>
    `,
    full: `
      <p>Equivalent to <code>stemma ingest ...</code>, <code>stemma resources</code>, and bulk import workflows. The archive is digest-addressed.</p>
      <h4>Tips</h4>
      <ul>
        <li>Duplicate file bytes return status <code>duplicate</code> without archive rewrite.</li>
        <li>Single-file import attempts extraction/vector indexing automatically for extractable media types.</li>
        <li>Mass import recursively scans a root path and resumes using state/log files under <code>.stemma/</code>.</li>
        <li>Use resources listing to obtain <code>resource.id</code> and digest for downstream steps.</li>
      </ul>
      <pre><code>Typical flow:
1) Import file or run mass import
2) List Resources (limit 20)
3) Confirm extraction/vector status in response</code></pre>
    `,
  },
  references: {
    title: "References",
    basic: `
      <p>Import bibliography records and connect citations to ingested resources.</p>
      <ul>
        <li><code>Import BibTeX</code> reads a .bib file.</li>
        <li><code>Link Ref-&gt;Resource</code> maps cite ID to resource digest.</li>
      </ul>
      <pre><code>Cite ID example: AB12
Digest example: 64-char sha256</code></pre>
    `,
    full: `
      <p>Use this when turning bibliographic metadata into auditable source links.</p>
      <h4>Recommended flow</h4>
      <ul>
        <li>Import BibTeX first.</li>
        <li>List citations to get generated cite IDs.</li>
        <li>Link each citation to a known ingested digest.</li>
      </ul>
      <pre><code>1) Import BibTeX
2) List Citations
3) Link Ref-&gt;Resource using cite_id + digest
4) List Refs to confirm links</code></pre>
    `,
  },
  sources: {
    title: "Sources",
    basic: `
      <p>Recover and manage canonical document source URLs for archived resources.</p>
      <ul>
        <li>Select a resource, inspect existing source metadata, and review extracted text clues.</li>
        <li>Run local-only recovery (xattrs, manifests, references, extracted DOI/URL clues).</li>
        <li>Run web-enabled recovery when local metadata is insufficient.</li>
        <li>Set a primary source URL or DOI manually when you already know the canonical source.</li>
      </ul>
    `,
    full: `
      <p>This panel is designed for provenance completion workflows where imported files are missing an origin URL.</p>
      <h4>Recovery strategy</h4>
      <ul>
        <li>Local metadata first: archive/source xattrs, local copies, manifests, linked references.</li>
        <li>Content signals next: DOI/URL extraction from latest extracted text.</li>
        <li>Web fallback last: lightweight search query built from title/author/filename/text hints.</li>
      </ul>
      <pre><code>1) Filter to missing-source resources
2) Load document
3) Recover from local metadata
4) If unresolved, run web-enabled recovery
5) Save/override primary source URL if needed</code></pre>
    `,
  },
  extraction: {
    title: "Extraction",
    basic: `
      <p>Run extraction for one resource, then inspect tables, text, segments, and annotations.</p>
      <ul>
        <li>Provide either resource ID or digest.</li>
        <li><code>Run Extract</code> creates extraction runs.</li>
        <li><code>List Tables</code> returns extracted table records.</li>
        <li><code>Extraction Inspector</code> calls text/segment/annotation/dump APIs.</li>
      </ul>
      <pre><code>Use exactly one selector:
- Resource ID
- Resource digest</code></pre>
    `,
    full: `
      <p>This maps to <code>stemma extract run</code>, <code>stemma extract tables</code>, <code>stemma extract text</code>, <code>stemma extract segments</code>, <code>stemma extract annotations</code>, and <code>stemma extract dump</code>.</p>
      <h4>What to watch</h4>
      <ul>
        <li>Summary fields: parser, timing, tables found.</li>
        <li>Table IDs are deterministic for stable binding.</li>
        <li>Inspector supports optional <code>run_id</code> for historical run debugging.</li>
        <li>Segments and annotations include compact cards with <code>Copy Selector JSON</code> actions.</li>
      </ul>
      <pre><code>1) Run Extract for digest
2) List Tables for same digest
3) Use Inspect Text / Segments / Annotations
4) Copy table_id into binding selectors if needed</code></pre>
    `,
  },
  vector: {
    title: "Vector",
    basic: `
      <p>Manage vector indexing and semantic search.</p>
      <ul>
        <li><code>Index</code>: index latest or specified extraction run for one resource.</li>
        <li><code>Status</code>: show backend, model, chunk counts, and recent runs.</li>
        <li><code>Backfill</code>: index missing latest runs in bulk.</li>
        <li><code>Search</code>: semantic lookup over indexed chunks.</li>
      </ul>
    `,
    full: `
      <p>This panel wraps <code>/api/vector/index</code>, <code>/api/vector/status</code>, <code>/api/vector/backfill</code>, and <code>/api/vector/search</code>.</p>
      <h4>Good workflow</h4>
      <ul>
        <li>Run extraction first.</li>
        <li>Index resource or backfill recent candidates.</li>
        <li>Use status to check chunk/point consistency.</li>
        <li>Run semantic queries and inspect hit metadata.</li>
      </ul>
    `,
  },
  claims: {
    title: "Claims",
    basic: `
      <p>Import claims into a claim set and inspect claim records.</p>
      <ul>
        <li>Choose format (<code>csv</code>, <code>json</code>, <code>md</code>).</li>
        <li>Set claim set name for grouping.</li>
      </ul>
      <pre><code>Claim set example: annual-report-2025</code></pre>
    `,
    full: `
      <p>This card is the entry point for structured assertion data.</p>
      <h4>Good workflow</h4>
      <ul>
        <li>Import into a named claim set.</li>
        <li>Use list filters to inspect only one set.</li>
        <li>Then bind evidence and run verification.</li>
      </ul>
      <pre><code>1) Import Claims
2) List Claim Sets
3) List Claims (claim set filter)</code></pre>
    `,
  },
  binding: {
    title: "Binding",
    basic: `
      <p>Attach evidence selectors to a claim and validate required roles.</p>
      <ul>
        <li>Provide claim ID and one resource selector (ID or digest).</li>
        <li>Provide role and selector JSON array.</li>
      </ul>
      <pre><code>[{"type":"PageGeometrySelector","pageIndex":0,"boxes":[]},
 {"type":"TextQuoteSelector","exact":"example"}]</code></pre>
    `,
    full: `
      <p>Bindings are the core of machine-verifiable provenance.</p>
      <h4>Guidance</h4>
      <ul>
        <li>Use at least two distinct selector types for robustness.</li>
        <li>Run <code>Validate Binding</code> after each add.</li>
        <li>For quantitative claims, include value-cell and supporting roles.</li>
      </ul>
      <pre><code>1) Add Binding
2) Validate Binding
3) Fix missing roles or selector diversity issues</code></pre>
    `,
  },
  verification: {
    title: "Verification and Reports",
    basic: `
      <p>Run deterministic verification and export run reports.</p>
      <ul>
        <li><code>Verify Claim</code>: one claim.</li>
        <li><code>Verify Set</code>: all claims in set.</li>
        <li><code>Get Report</code>: summary + optional file exports.</li>
      </ul>
      <pre><code>Policy profile defaults to "strict"</code></pre>
    `,
    full: `
      <p>Use verification after import + binding are complete.</p>
      <h4>Typical process</h4>
      <ul>
        <li>Verify set for batch signal.</li>
        <li>Use report output to inspect failures.</li>
        <li>Optionally export JSON and Markdown reports.</li>
      </ul>
      <pre><code>1) Verify Set (claim set)
2) Copy run_id from response
3) Get Report with run_id</code></pre>
    `,
  },
  trace: {
    title: "Trace",
    basic: `
      <p>Navigate links between claims, evidence, resources, and citations.</p>
      <ul>
        <li>Trace from claim ID, resource selector, or cite ID.</li>
      </ul>
      <pre><code>Trace by one anchor at a time:
- claim_id
- resource_id/resource_digest
- cite_id</code></pre>
    `,
    full: `
      <p>Trace is best for audits and debugging missing evidence links.</p>
      <h4>Use cases</h4>
      <ul>
        <li>Confirm which evidence items back a claim.</li>
        <li>Find all claims tied to one resource.</li>
        <li>Review citation-resource consistency.</li>
      </ul>
      <pre><code>1) Trace claim
2) Trace resource from returned resource id
3) Trace citation from cite id</code></pre>
    `,
  },
  ceapf: {
    title: "CEAPF",
    basic: `
      <p>Create propositions/assertions and connect them with argument relations.</p>
      <ul>
        <li>Add proposition JSON.</li>
        <li>Add assertion event for proposition.</li>
        <li>Add support/rebuttal relation edges.</li>
      </ul>
      <pre><code>{"subject":"org:X","predicate":"ceapf:spent","object":{"amount":3.4,"unit":"GBP"}}</code></pre>
    `,
    full: `
      <p>CEAPF supports higher-level argument graph modeling on top of evidence.</p>
      <h4>Practical flow</h4>
      <ul>
        <li>Create proposition first.</li>
        <li>Create assertion(s) with modality and agent.</li>
        <li>Connect assertions and propositions with directed relation types.</li>
      </ul>
      <pre><code>Relation types:
- supports
- rebuts
- undercuts
- qualifies</code></pre>
    `,
  },
};

function installHelpButtons() {
  document.querySelectorAll('.card[data-help-key]').forEach((card) => {
    const key = card.dataset.helpKey;
    const icon = document.createElement('button');
    icon.className = 'help-icon';
    icon.textContent = '?';
    icon.title = 'Help';
    icon.setAttribute('aria-label', 'Help');
    icon.onclick = () => showHelp(key);
    card.appendChild(icon);
  });
}

function showHelp(key) {
  const entry = HELP_CONTENT[key];
  if (!entry) return;
  document.getElementById('help-title').textContent = `${entry.title} Help`;
  document.getElementById('help-content').innerHTML = `
    <h4>Basic</h4>
    ${entry.basic || ''}
    <h4>Comprehensive</h4>
    ${entry.full || ''}
  `;
  const modal = document.getElementById('help-modal');
  modal.classList.add('open');
  modal.setAttribute('aria-hidden', 'false');
}

function closeHelp() {
  const modal = document.getElementById('help-modal');
  modal.classList.remove('open');
  modal.setAttribute('aria-hidden', 'true');
}

function navEnsureButtonStructure(btn) {
  if (!btn) return;
  if (btn.querySelector('.nav-btn-text') && btn.querySelector('.nav-activity')) return;
  const label = String(btn.textContent || '').trim();
  btn.textContent = '';
  const text = document.createElement('span');
  text.className = 'nav-btn-text';
  text.textContent = label;
  const activity = document.createElement('span');
  activity.className = 'nav-activity';
  activity.setAttribute('aria-hidden', 'true');
  const ring = document.createElement('span');
  ring.className = 'nav-activity-ring';
  const value = document.createElement('span');
  value.className = 'nav-activity-label';
  activity.appendChild(ring);
  activity.appendChild(value);
  btn.appendChild(text);
  btn.appendChild(activity);
}

function navSetPaneActivity(pane, activity = {}) {
  const paneName = String(pane || '').trim();
  if (!paneName) return;
  const btn = document.querySelector(`.nav-btn[data-pane="${paneName}"]`);
  if (!btn) return;
  navEnsureButtonStructure(btn);
  const active = Boolean(activity.active);
  const labelEl = btn.querySelector('.nav-activity-label');
  const ringEl = btn.querySelector('.nav-activity-ring');
  if (!active) {
    btn.classList.remove('has-activity', 'activity-indeterminate');
    btn.style.removeProperty('--activity-progress');
    if (labelEl) labelEl.textContent = '';
    if (ringEl) ringEl.removeAttribute('title');
    return;
  }

  const numeric = Number(activity.percent);
  const hasPercent = Number.isFinite(numeric);
  const progress = hasPercent ? Math.max(0, Math.min(100, Math.round(numeric))) : 0;
  const indeterminate = Boolean(activity.indeterminate) || !hasPercent;
  const title = String(activity.title || '').trim();

  btn.classList.add('has-activity');
  btn.classList.toggle('activity-indeterminate', indeterminate);
  btn.style.setProperty('--activity-progress', String(progress));
  if (labelEl) {
    labelEl.textContent = hasPercent ? String(progress) : '';
  }
  if (ringEl) {
    if (title) {
      ringEl.setAttribute('title', title);
    } else {
      ringEl.removeAttribute('title');
    }
  }
}

function setActivePane(pane) {
  const panels = Array.from(document.querySelectorAll('.workspace-panel[data-pane]'));
  if (!panels.length) return;

  const known = new Set(panels.map((panel) => panel.dataset.pane));
  const chosen = known.has(pane) ? pane : panels[0].dataset.pane;

  panels.forEach((panel) => {
    panel.classList.toggle('active', panel.dataset.pane === chosen);
  });
  document.querySelectorAll('.nav-btn[data-pane]').forEach((btn) => {
    btn.classList.toggle('active', btn.dataset.pane === chosen);
  });

  localStorage.setItem('stemmaActivePane', chosen);
}

function initWorkspaceNav() {
  const buttons = Array.from(document.querySelectorAll('.nav-btn[data-pane]'));
  buttons.forEach((btn) => navEnsureButtonStructure(btn));
  buttons.forEach((btn) => {
    btn.onclick = () => setActivePane(btn.dataset.pane);
  });
  const saved = localStorage.getItem('stemmaActivePane');
  const fallback = buttons.length ? buttons[0].dataset.pane : 'project';
  setActivePane(saved || fallback);
}

function initResizableOutputs() {
  const minHeightPx = 320;
  document.querySelectorAll('pre[id^="out-"]').forEach((panel) => {
    const key = `stemmaOutHeight:${panel.id}`;
    const saved = Number(localStorage.getItem(key) || "0");
    if (Number.isFinite(saved) && saved >= minHeightPx) {
      panel.style.height = `${saved}px`;
    }
    const persist = () => {
      const next = Math.max(minHeightPx, panel.clientHeight || minHeightPx);
      localStorage.setItem(key, String(next));
    };
    panel.addEventListener('mouseup', persist);
    panel.addEventListener('touchend', persist, { passive: true });
  });
}

function setTheme(themeName) {
  const allowed = new Set([
    'harmonious-light',
    'restful-dark',
    'forest-mist',
    'sunset-paper',
    'midnight-contrast',
  ]);
  const selected = allowed.has(themeName) ? themeName : 'harmonious-light';
  document.body.setAttribute('data-theme', selected);
  localStorage.setItem('stemmaTheme', selected);
  const picker = document.getElementById('theme-select');
  if (picker && picker.value !== selected) picker.value = selected;
}

function initTheme() {
  const saved = localStorage.getItem('stemmaTheme');
  setTheme(saved || 'harmonious-light');
}

function candidateApiUrls(url) {
  const results = [];
  const seen = new Set();
  const add = (u) => {
    if (!u || seen.has(u)) return;
    seen.add(u);
    results.push(u);
  };

  // Absolute path as configured in the UI.
  add(url);

  // Relative fallback (works when app is mounted under a path prefix).
  if (url.startsWith('/')) add(url.slice(1));

  // Prefix fallback for mounts like /stemma -> /stemma/api/...
  if (url.startsWith('/')) {
    const path = window.location.pathname || '/';
    const trimmed = path.replace(/\/+$/, '');
    const lastSeg = trimmed.split('/').pop() || '';
    if (trimmed && trimmed !== '/' && !lastSeg.includes('.')) {
      const prefixed = `${trimmed}${url}`;
      add(prefixed.replace(/\/{2,}/g, '/'));
    }
  }

  return results;
}

async function callApi(method, url, body, outId, isFormData=false) {
  const opts = { method, headers: {} };
  if (body !== null && body !== undefined) {
    if (isFormData) {
      opts.body = body;
    } else {
      opts.headers['Content-Type'] = 'application/json';
      opts.body = JSON.stringify(body);
    }
  }
  const attempts = candidateApiUrls(url);
  let lastData = null;
  try {
    for (const attemptUrl of attempts) {
      const res = await fetch(attemptUrl, opts);
      let data;
      const contentType = (res.headers.get('content-type') || '').toLowerCase();
      if (contentType.includes('application/json')) {
        data = await res.json();
      } else {
        const text = await res.text();
        data = { detail: text || `HTTP ${res.status}` };
      }

      if (!(res.status === 404 && data && data.detail === 'Not Found')) {
        if (outId) document.getElementById(outId).textContent = JSON.stringify(data, null, 2);
        return data;
      }
      lastData = data;
    }

    const payload = {
      ...(lastData || { detail: 'Not Found' }),
      attempted_urls: attempts,
    };
    if (outId) document.getElementById(outId).textContent = JSON.stringify(payload, null, 2);
    return payload;
  } catch (e) {
    if (outId) {
      document.getElementById(outId).textContent = JSON.stringify(
        { error: String(e), attempted_urls: attempts },
        null,
        2
      );
    }
    throw e;
  }
}

const HEALTH_FIELD_HELP = {
  ok: 'Overall result of the full doctor check suite.',
  checks_run: 'Number of health checks executed in this doctor run.',
  journal_mode: 'SQLite journal mode. WAL is required for robust concurrent access.',
  busy_timeout_ms: 'Milliseconds SQLite waits for a lock before failing.',
  foreign_keys: 'Whether SQLite foreign key constraints are enforced.',
  synchronous: 'SQLite durability level. Higher values increase durability.',
  wal_autocheckpoint_pages: 'WAL pages written before automatic checkpoint.',
  issues: 'Warnings and errors discovered during doctor checks.',
};

function toSafeInt(value, fallback = 0) {
  const parsed = Number(value);
  return Number.isFinite(parsed) ? Math.floor(parsed) : fallback;
}

function statusClass(status) {
  const normalized = String(status || '').toLowerCase();
  if (normalized === 'ok' || normalized === 'healthy' || normalized === 'success' || normalized === 'pass') {
    return 'status-ok';
  }
  if (normalized === 'warning' || normalized === 'warn' || normalized === 'degraded') {
    return 'status-warn';
  }
  if (normalized === 'error' || normalized === 'failed' || normalized === 'fail') {
    return 'status-error';
  }
  return 'status-neutral';
}

function titleCase(value) {
  const text = String(value || '').trim();
  if (!text) return '';
  return text.charAt(0).toUpperCase() + text.slice(1).toLowerCase();
}

function infoIcon(tooltip) {
  return `<span class="info-icon" title="${dbEscapeHtml(tooltip || '')}" aria-label="${dbEscapeHtml(tooltip || '')}">?</span>`;
}

function metricCard(label, valueHtml, helpText='') {
  return `
    <article class="metric-card">
      <p class="metric-label">${dbEscapeHtml(label)}${helpText ? ' ' + infoIcon(helpText) : ''}</p>
      <p class="metric-value">${valueHtml}</p>
    </article>
  `;
}

function renderIssueList(containerId, issues) {
  const container = document.getElementById(containerId);
  if (!container) return;
  if (!Array.isArray(issues) || !issues.length) {
    container.innerHTML = '<p class="small">No issues detected.</p>';
    return;
  }
  container.innerHTML = issues
    .map((issue) => {
      const level = String(issue.level || 'info').toLowerCase();
      const klass = level === 'error' ? 'issue-error' : (level === 'warning' ? 'issue-warning' : 'issue-info');
      return `<article class="issue-item ${klass}"><strong>${dbEscapeHtml(level)}</strong>${dbEscapeHtml(issue.message || '')}</article>`;
    })
    .join('');
}

function renderProjectHealth(payload) {
  const statusLine = document.getElementById('project-health-status');
  const visual = document.getElementById('project-health-visual');
  if (!statusLine || !visual) return;

  if (!payload || payload.ok === undefined) {
    statusLine.textContent = 'No health payload loaded.';
    visual.innerHTML = '';
    renderIssueList('project-health-issues', []);
    return;
  }

  if (payload.db_runtime) {
    const issues = Array.isArray(payload.issues) ? payload.issues : [];
    const errorCount = issues.filter((i) => String(i.level || '').toLowerCase() === 'error').length;
    const warningCount = issues.filter((i) => String(i.level || '').toLowerCase() === 'warning').length;
    const overall = payload.ok ? (warningCount > 0 ? 'warning' : 'ok') : 'error';
    statusLine.textContent = `Doctor loaded: ${payload.checks_run || 0} checks, ${errorCount} errors, ${warningCount} warnings.`;

    const runtime = payload.db_runtime || {};
    const syncCode = Number(runtime.synchronous);
    const syncName = (
      syncCode === 0 ? 'OFF' :
      syncCode === 1 ? 'NORMAL' :
      syncCode === 2 ? 'FULL' :
      syncCode === 3 ? 'EXTRA' :
      `CODE ${dbEscapeHtml(String(syncCode))}`
    );

    visual.innerHTML = `
      ${metricCard('Overall', `<span class="status-pill ${statusClass(overall)}">${dbEscapeHtml(titleCase(overall))}</span>`, HEALTH_FIELD_HELP.ok)}
      ${metricCard('Checks Run', dbEscapeHtml(String(payload.checks_run ?? 0)), HEALTH_FIELD_HELP.checks_run)}
      ${metricCard('Journal Mode', `<span class="status-pill ${statusClass(runtime.journal_mode === 'wal' ? 'ok' : 'warning')}">${dbEscapeHtml(titleCase(String(runtime.journal_mode || 'unknown')))}</span>`, HEALTH_FIELD_HELP.journal_mode)}
      ${metricCard('Busy Timeout', `${dbEscapeHtml(String(runtime.busy_timeout_ms ?? 0))} ms`, HEALTH_FIELD_HELP.busy_timeout_ms)}
      ${metricCard('Foreign Keys', `<span class="status-pill ${statusClass(runtime.foreign_keys ? 'ok' : 'error')}">${runtime.foreign_keys ? 'ENABLED' : 'DISABLED'}</span>`, HEALTH_FIELD_HELP.foreign_keys)}
      ${metricCard('Synchronous', dbEscapeHtml(syncName), HEALTH_FIELD_HELP.synchronous)}
      ${metricCard('WAL Auto-checkpoint', `${dbEscapeHtml(String(runtime.wal_autocheckpoint_pages ?? 'n/a'))} pages`, HEALTH_FIELD_HELP.wal_autocheckpoint_pages)}
      ${metricCard('Issues', dbEscapeHtml(String(issues.length)), HEALTH_FIELD_HELP.issues)}
    `;
    renderIssueList('project-health-issues', issues);
    return;
  }

  const created = Array.isArray(payload.paths_created) ? payload.paths_created : [];
  statusLine.textContent = payload.ok
    ? `Project initialized. ${created.length} path(s) created or repaired.`
    : 'Project initialization failed.';
  visual.innerHTML = `
    ${metricCard('Init Status', `<span class="status-pill ${statusClass(payload.ok ? 'ok' : 'error')}">${payload.ok ? 'READY' : 'FAILED'}</span>`, 'Result of project initialization.')}
    ${metricCard('Database Path', dbEscapeHtml(String(payload.db_path || 'n/a')), 'SQLite database path used by this project.')}
    ${metricCard('Paths Created', dbEscapeHtml(String(created.length)), 'Filesystem paths created or repaired by init.')}
  `;
  renderIssueList('project-health-issues', []);
}

async function runInitProject() {
  const payload = await callApi('POST', '/api/init', {}, 'out-project');
  renderProjectHealth(payload);
}

async function runDoctor() {
  const payload = await callApi('GET', '/api/doctor', null, 'out-project');
  renderProjectHealth(payload);
}

function dashboardRunCards(data) {
  const container = document.getElementById('dashboard-runs');
  if (!container) return;
  const extraction = data?.latest?.extraction_run || null;
  const verification = data?.latest?.verification_run || null;
  const cards = [];
  if (extraction) {
    cards.push(
      `<article class="issue-item issue-info"><strong>Extraction</strong>run ${dbEscapeHtml(extraction.id)} (${dbEscapeHtml(extraction.status || 'unknown')}) at ${dbEscapeHtml(extraction.created_at || 'n/a')}</article>`
    );
  }
  if (verification) {
    const counts = verification.result_status_counts || {};
    const statusSummary = Object.keys(counts).sort().map((k) => `${k}=${counts[k]}`).join(', ') || 'no results';
    cards.push(
      `<article class="issue-item issue-info"><strong>Verification</strong>run ${dbEscapeHtml(verification.id)} (${dbEscapeHtml(verification.policy_profile || 'n/a')}) at ${dbEscapeHtml(verification.created_at || 'n/a')} | ${dbEscapeHtml(statusSummary)}</article>`
    );
  }
  if (!cards.length) {
    container.innerHTML = '<p class="small">No recent extraction or verification runs found.</p>';
    return;
  }
  container.innerHTML = cards.join('');
}

function dashboardStorageCards(data) {
  const container = document.getElementById('dashboard-storage');
  if (!container) return;
  const project = (data && typeof data === 'object' && data.project && typeof data.project === 'object')
    ? data.project
    : {};
  const storage = (project.storage && typeof project.storage === 'object') ? project.storage : {};
  const segments = [
    { key: 'db_main', label: 'SQLite DB', path: storage.db_main_path || project.db_path, bytes: Number(storage.db_main_bytes || 0), color: '#2563eb' },
    { key: 'db_wal', label: 'WAL', path: storage.db_wal_path || `${project.db_path || ''}-wal`, bytes: Number(storage.db_wal_bytes || 0), color: '#14b8a6' },
    { key: 'db_shm', label: 'SHM', path: storage.db_shm_path || `${project.db_path || ''}-shm`, bytes: Number(storage.db_shm_bytes || 0), color: '#f59e0b' },
    { key: 'archive', label: 'Archive Store', path: storage.archive_dir || project.archive_dir, bytes: Number(storage.archive_bytes || 0), color: '#a855f7' },
    { key: 'vector', label: 'Vector Store', path: storage.qdrant_dir || project.qdrant_dir, bytes: Number(storage.qdrant_bytes || 0), color: '#ef4444' },
  ];
  if (!segments.some((row) => String(row.path || '').trim())) {
    container.innerHTML = '<p class="small">Storage summary not available.</p>';
    return;
  }
  const totalBytes = segments.reduce((sum, seg) => sum + (Number.isFinite(seg.bytes) && seg.bytes > 0 ? seg.bytes : 0), 0);
  let arcCursor = 0;
  const gradientParts = [];
  segments.forEach((segment) => {
    const value = Number.isFinite(segment.bytes) && segment.bytes > 0 ? segment.bytes : 0;
    if (value <= 0 || totalBytes <= 0) return;
    const angle = (value / totalBytes) * 360;
    const start = arcCursor;
    const end = arcCursor + angle;
    gradientParts.push(`${segment.color} ${start.toFixed(3)}deg ${end.toFixed(3)}deg`);
    arcCursor = end;
  });
  if (arcCursor < 360) {
    gradientParts.push(`color-mix(in srgb, var(--border) 44%, transparent) ${arcCursor.toFixed(3)}deg 360deg`);
  }
  const donutBackground = gradientParts.length
    ? `conic-gradient(${gradientParts.join(', ')})`
    : 'conic-gradient(color-mix(in srgb, var(--border) 44%, transparent) 0deg 360deg)';

  const legendHtml = segments
    .map((segment) => `
      <li class="storage-legend-item">
        <span class="storage-legend-main">
          <span class="storage-swatch" style="background:${segment.color};"></span>
          <span class="storage-legend-name">${dbEscapeHtml(segment.label)}</span>
        </span>
        <span class="storage-legend-size">${dbEscapeHtml(importFileSizeText(segment.bytes || 0))}</span>
      </li>
    `)
    .join('');

  const deviceAnchor = String(storage.device_anchor_path || project.db_path || project.root || 'n/a');
  const deviceTotal = Number(storage.device_total_bytes || 0);
  const deviceUsed = Number(storage.device_used_bytes || 0);
  const deviceFree = Number(storage.device_free_bytes || 0);
  const safeTotal = Number.isFinite(deviceTotal) && deviceTotal > 0 ? deviceTotal : 0;
  const usedPctRaw = safeTotal > 0 ? (Math.max(0, deviceUsed) / safeTotal) * 100 : 0;
  const usedPct = Math.max(0, Math.min(100, usedPctRaw));
  const freePct = Math.max(0, 100 - usedPct);
  const deviceMetaHtml = safeTotal > 0
    ? `${dbEscapeHtml(importFileSizeText(deviceUsed))} used  ${dbEscapeHtml(importFileSizeText(deviceFree))} free  ${dbEscapeHtml(importFileSizeText(deviceTotal))} total`
    : 'Device capacity unavailable.';

  const pathListHtml = segments
    .map((segment) => `
      <li class="storage-path-item">
        <strong>${dbEscapeHtml(segment.label)}</strong>
        <code>${dbEscapeHtml(String(segment.path || 'n/a'))}</code>
      </li>
    `)
    .join('');

  container.innerHTML = `
    <div class="dashboard-storage-layout">
      <section class="storage-column">
        <p class="storage-kicker">Storage Composition</p>
        <div class="storage-donut-wrap">
          <div class="storage-donut" style="background:${donutBackground};">
            <div class="storage-donut-center">
              <span class="storage-donut-label">Total</span>
              <span class="storage-donut-value">${dbEscapeHtml(importFileSizeText(totalBytes))}</span>
            </div>
          </div>
          <ul class="storage-legend">${legendHtml}</ul>
        </div>
      </section>
      <section class="storage-column">
        <p class="storage-kicker">Device Capacity</p>
        <div class="storage-device-block">
          <p class="storage-device-meta">Device anchor: <code>${dbEscapeHtml(deviceAnchor)}</code></p>
          <div class="storage-device-bar" aria-label="Device used and free space">
            <div class="storage-device-used" style="width:${usedPct.toFixed(2)}%"></div>
            <div class="storage-device-free" style="width:${freePct.toFixed(2)}%"></div>
          </div>
          <p class="storage-device-meta">${dbEscapeHtml(deviceMetaHtml)}</p>
          <ul class="storage-path-list">${pathListHtml}</ul>
        </div>
      </section>
    </div>
  `;
}

function renderDashboard(data, includeDoctor) {
  const statusEl = document.getElementById('dashboard-status');
  const kpiEl = document.getElementById('dashboard-kpis');
  if (!statusEl || !kpiEl) return;

  if (!data || data.ok !== true) {
    statusEl.textContent = 'Failed to load dashboard summary.';
    kpiEl.innerHTML = '';
    dashboardStorageCards(null);
    dashboardRunCards(null);
    return;
  }

  const counts = data.counts || {};
  const vector = data.vector || {};
  const health = data.health || null;
  const healthLabel = health
    ? (health.ok ? (health.warning_count > 0 ? 'WARNING' : 'OK') : 'ERROR')
    : 'NOT RUN';
  const healthTone = health
    ? (health.ok ? (health.warning_count > 0 ? 'warning' : 'ok') : 'error')
    : 'neutral';

  kpiEl.innerHTML = `
    ${metricCard('System Health', `<span class="status-pill ${statusClass(healthTone)}">${dbEscapeHtml(healthLabel)}</span>`, 'Doctor status snapshot.')}
    ${metricCard('Resources', dbEscapeHtml(String(counts.resources ?? 0)), 'Ingested source documents.')}
    ${metricCard('Claims', dbEscapeHtml(String(counts.claims ?? 0)), 'Claims available for verification.')}
    ${metricCard('Evidence Bindings', dbEscapeHtml(String(counts.claim_evidence_bindings ?? 0)), 'Claim-to-evidence links.')}
    ${metricCard('Extraction Runs', dbEscapeHtml(String(counts.extraction_runs ?? 0)), 'Total extraction runs in project history.')}
    ${metricCard('Verification Runs', dbEscapeHtml(String(counts.verification_runs ?? 0)), 'Total verification runs in project history.')}
    ${metricCard('Vector Backend', dbEscapeHtml(String(vector.backend || 'n/a')), 'Current vector backend mode.')}
    ${metricCard('Vector Points', dbEscapeHtml(String(vector.qdrant_points ?? 0)), 'Point count in vector database collection.')}
  `;

  statusEl.textContent = `Summary refreshed at ${data.generated_at || 'n/a'}${includeDoctor ? ' (doctor included).' : '.'}`;
  dashboardStorageCards(data);
  dashboardRunCards(data);

  if (health) {
    renderProjectHealth(health);
  }
}

async function loadDashboard(includeDoctor = false) {
  const query = includeDoctor ? '?include_doctor=true' : '';
  const payload = await callApi('GET', `/api/dashboard/summary${query}`, null, 'out-dashboard');
  renderDashboard(payload, includeDoctor);
}

function vectorTargetPayload() {
  const resourceId = (document.getElementById('vector-resource-id').value || '').trim();
  const resourceDigest = (document.getElementById('vector-resource-digest').value || '').trim();
  const extractionRunId = (document.getElementById('vector-extraction-run-id').value || '').trim();
  return {
    resourceId,
    resourceDigest,
    extractionRunId,
  };
}

function vectorStatusQuery() {
  const target = vectorTargetPayload();
  const limitRaw = document.getElementById('vector-status-limit').value || '25';
  const limit = Math.max(1, toSafeInt(limitRaw, 25));
  const params = new URLSearchParams();
  params.set('limit_runs', String(limit));
  if (target.resourceId) {
    params.set('resource_id', target.resourceId);
  } else if (target.resourceDigest) {
    params.set('resource_digest', target.resourceDigest);
  }
  return params.toString();
}

let vectorSearchInFlight = false;

function vectorScorePercent(score) {
  const n = Number(score);
  if (!Number.isFinite(n)) return null;
  if (n >= 0 && n <= 1) return Math.round(n * 100);
  if (n >= -1 && n <= 1) return Math.round(((n + 1) / 2) * 100);
  return Math.max(0, Math.min(100, Math.round(n * 100)));
}

function setVectorSearchLoading(isLoading) {
  const loading = Boolean(isLoading);
  vectorSearchInFlight = loading;
  const button = document.getElementById('vector-search-btn');
  if (button) {
    button.disabled = loading;
    button.textContent = loading ? 'Searching...' : 'Search';
  }
  const container = document.getElementById('vector-search-results');
  if (loading && container) {
    container.innerHTML = '<div class="vector-search-loading">Searching vector index...</div>';
  }
}

function renderVectorStatus(payload) {
  const note = document.getElementById('vector-status-note');
  const summary = document.getElementById('vector-summary');
  const runs = document.getElementById('vector-runs');
  if (!note || !summary || !runs) return;

  if (!payload || payload.ok !== true) {
    navSetPaneActivity('vector', { active: false });
    note.textContent = 'Vector status request failed.';
    summary.innerHTML = '';
    runs.innerHTML = '<p class="small">No vector status available.</p>';
    return;
  }

  const runList = Array.isArray(payload.runs) ? payload.runs : [];
  const successCount = runList.filter((r) => r.status === 'success').length;
  const failedCount = runList.filter((r) => r.status === 'failed').length;
  const runningCount = runList.filter((r) => r.status === 'running').length;
  const skippedCount = runList.filter((r) => r.status === 'skipped').length;
  const runningRun = runList.find((r) => String(r.status || '').toLowerCase() === 'running') || null;
  const runningChunksIndexed = Number(runningRun?.chunks_indexed);
  const runningChunksTotal = Number(runningRun?.chunks_total);
  const runningHasProgress = Number.isFinite(runningChunksTotal)
    && Number.isFinite(runningChunksIndexed)
    && runningChunksTotal > 0;
  const runningPercent = runningHasProgress
    ? Math.round((Math.max(0, Math.min(runningChunksIndexed, runningChunksTotal)) / runningChunksTotal) * 100)
    : null;
  navSetPaneActivity(
    'vector',
    runningCount > 0
      ? {
          active: true,
          percent: runningPercent,
          indeterminate: runningPercent === null,
          title: runningPercent === null
            ? `Vector indexing running (${runningCount} run${runningCount === 1 ? '' : 's'})`
            : `Vector indexing ${runningPercent}%`,
        }
      : { active: false }
  );

  summary.innerHTML = `
    ${metricCard('Backend', dbEscapeHtml(String(payload.backend || 'n/a')), 'Vector backend currently in use.')}
    ${metricCard('Collection', dbEscapeHtml(String(payload.collection_name || 'n/a')), 'Qdrant collection name.')}
    ${metricCard('Embedding Model', dbEscapeHtml(String(payload.embedding_model || 'n/a')), 'Embedding model used for indexing and querying.')}
    ${metricCard('Chunk Rows', dbEscapeHtml(String(payload.vector_chunk_rows ?? 0)), 'Rows in SQLite vector_chunks table.')}
    ${metricCard('Distinct Chunks', dbEscapeHtml(String(payload.distinct_chunk_ids ?? 0)), 'Distinct chunk identifiers indexed in SQLite.')}
    ${metricCard('Vector Points', dbEscapeHtml(String(payload.qdrant_points ?? 0)), 'Point count in vector database.')}
    ${metricCard('Run Success', dbEscapeHtml(String(successCount)), 'Recent successful vector index runs.')}
    ${metricCard('Run Failures', dbEscapeHtml(String(failedCount)), 'Recent failed vector index runs.')}
    ${metricCard('Run Running', dbEscapeHtml(String(runningCount)), 'Recent in-progress vector index runs.')}
    ${metricCard('Run Skipped', dbEscapeHtml(String(skippedCount)), 'Recent skipped vector index runs.')}
  `;
  note.textContent = `Loaded ${runList.length} recent vector run(s).`;

  if (!runList.length) {
    runs.innerHTML = '<p class="small">No vector runs found.</p>';
    return;
  }
  runs.innerHTML = runList
    .map((run) => {
      const tone = run.status === 'success' ? 'ok' : (run.status === 'failed' ? 'error' : (run.status === 'running' ? 'warning' : 'neutral'));
      const err = run.error_message ? `\nerror: ${run.error_message}` : '';
      return `
        <article class="vector-card">
          <div class="vector-card-head">
            <h4><span class="status-pill ${statusClass(tone)}">${dbEscapeHtml(titleCase(String(run.status || 'unknown')))}</span> ${dbEscapeHtml((run.id || '').slice(0, 12))}</h4>
          </div>
          <p>resource: ${dbEscapeHtml(run.resource_id || 'n/a')}
extraction_run: ${dbEscapeHtml(run.extraction_run_id || 'n/a')}
chunks: ${dbEscapeHtml(String(run.chunks_indexed ?? 0))}/${dbEscapeHtml(String(run.chunks_total ?? 0))}
created: ${dbEscapeHtml(run.created_at || 'n/a')}
finished: ${dbEscapeHtml(run.finished_at || 'n/a')}${dbEscapeHtml(err)}</p>
        </article>
      `;
    })
    .join('');
}

function renderVectorSearch(payload) {
  const container = document.getElementById('vector-search-results');
  if (!container) return;
  if (!payload || payload.ok !== true) {
    container.innerHTML = '<p class="small">Vector search request failed.</p>';
    return;
  }
  const hits = Array.isArray(payload.hits) ? payload.hits : [];
  if (!hits.length) {
    container.innerHTML = '<p class="small">No semantic matches found.</p>';
    return;
  }
  container.innerHTML = hits
    .map((hit, idx) => {
      const scorePct = vectorScorePercent(hit.score);
      const scoreLabel = scorePct === null
        ? `score ${dbEscapeHtml(String(hit.score ?? 'n/a'))}`
        : `${dbEscapeHtml(String(scorePct))}% relevance`;
      const details = {
        score_raw: hit.score,
        chunk_id: hit.chunk_id || '',
        resource_id: hit.resource_id || '',
        extraction_run_id: hit.extraction_run_id || '',
        source_type: hit.source_type || '',
        source_ref: hit.source_ref || '',
        page_index: hit.page_index,
        start_offset: hit.start_offset,
        end_offset: hit.end_offset,
      };
      return `
        <article class="vector-card">
          <div class="vector-card-head">
            <h4>Result #${idx + 1}</h4>
            <span class="vector-hit-score">${scoreLabel}</span>
          </div>
          <p class="vector-hit-snippet">${dbEscapeHtml(String(hit.text_content || ''))}</p>
          <details class="vector-hit-details">
            <summary>View details</summary>
            <pre>${dbEscapeHtml(JSON.stringify(details, null, 2))}</pre>
          </details>
        </article>
      `;
    })
    .join('');
}

async function vectorStatus() {
  const payload = await callApi('GET', `/api/vector/status?${vectorStatusQuery()}`, null, 'out-vector');
  renderVectorStatus(payload);
}

async function vectorIndex() {
  const target = vectorTargetPayload();
  if (!target.resourceId && !target.resourceDigest) {
    document.getElementById('out-vector').textContent = JSON.stringify(
      { error: 'Provide resource ID or resource digest.' },
      null,
      2
    );
    return;
  }
  const payload = await callApi(
    'POST',
    '/api/vector/index',
    {
      resource_id: target.resourceId || null,
      resource_digest: target.resourceDigest || null,
      extraction_run_id: target.extractionRunId || null,
      force: document.getElementById('vector-force').value === 'true',
    },
    'out-vector'
  );
  document.getElementById('vector-status-note').textContent = payload.ok
    ? 'Vector index request completed. Refreshing status...'
    : 'Vector index request failed.';
  await vectorStatus();
}

async function vectorBackfill() {
  const limitResources = Math.max(1, toSafeInt(document.getElementById('vector-backfill-limit-resources').value, 100000));
  const maxProcessRaw = (document.getElementById('vector-backfill-max-process').value || '').trim();
  const maxProcess = maxProcessRaw ? Math.max(1, toSafeInt(maxProcessRaw, 1)) : null;
  const payload = await callApi(
    'POST',
    '/api/vector/backfill',
    {
      limit_resources: limitResources,
      max_process: maxProcess,
    },
    'out-vector'
  );
  document.getElementById('vector-status-note').textContent = payload.ok
    ? 'Backfill request completed. Refreshing status...'
    : 'Backfill request failed.';
  await vectorStatus();
}

async function vectorSearch() {
  if (vectorSearchInFlight) return;
  const target = vectorTargetPayload();
  const query = (document.getElementById('vector-query').value || '').trim();
  const limit = Math.max(1, toSafeInt(document.getElementById('vector-query-limit').value, 10));
  if (!query) {
    document.getElementById('out-vector').textContent = JSON.stringify(
      { error: 'Provide a semantic query string.' },
      null,
      2
    );
    return;
  }
  setVectorSearchLoading(true);
  try {
    const payload = await callApi(
      'POST',
      '/api/vector/search',
      {
        query,
        limit,
        resource_id: target.resourceId || null,
        resource_digest: target.resourceDigest || null,
        extraction_run_id: target.extractionRunId || null,
      },
      'out-vector'
    );
    renderVectorSearch(payload);
  } finally {
    setVectorSearchLoading(false);
  }
}

function initVectorPane() {
  const form = document.getElementById('vector-search-form');
  if (form) {
    form.addEventListener('submit', (event) => {
      event.preventDefault();
      vectorSearch();
    });
  }
}

let sourcesState = {
  resources: [],
  current: null,
  recoverInFlight: false,
};

function sourcesSelectedId() {
  const select = document.getElementById('sources-resource-select');
  return select ? String(select.value || '').trim() : '';
}

function sourcesSetStatus(message) {
  const el = document.getElementById('sources-status');
  if (el) el.textContent = String(message || '');
}

function sourcesDisplayLabel(resource) {
  const title = String(resource?.display_title || '').trim();
  const filename = String(resource?.original_filename || '').trim();
  const id = String(resource?.id || '').trim();
  if (title && filename) return `${title} (${filename})`;
  if (title) return title;
  if (filename) return filename;
  return id || 'resource';
}

function sourcesRenderList(resources) {
  const select = document.getElementById('sources-resource-select');
  if (!select) return;
  const prior = sourcesSelectedId();
  const options = ['<option value="">Select document</option>'];
  (resources || []).forEach((resource) => {
    const id = String(resource?.id || '');
    if (!id) return;
    options.push(`<option value="${dbEscapeHtml(id)}">${dbEscapeHtml(sourcesDisplayLabel(resource))}</option>`);
  });
  select.innerHTML = options.join('');
  if (prior && resources.some((resource) => String(resource?.id || '') === prior)) {
    select.value = prior;
  } else if (resources.length === 1) {
    select.value = String(resources[0].id || '');
  }
}

function sourcesRenderRecoveryLog(result) {
  const host = document.getElementById('sources-recovery-log');
  if (!host) return;
  const logs = Array.isArray(result?.phase_logs) ? result.phase_logs : [];
  if (!logs.length) {
    host.innerHTML = '<p class="small">No recovery run yet.</p>';
    return;
  }
  host.innerHTML = logs
    .map((row) => {
      const ok = Boolean(row?.success);
      const urls = Array.isArray(row?.urls) ? row.urls : [];
      const urlMarkup = urls.length
        ? `<ul class="sources-url-list">${urls.slice(0, 4).map((url) => `<li><code>${dbEscapeHtml(String(url || ''))}</code></li>`).join('')}</ul>`
        : '';
      return `
        <article class="sources-phase-item ${ok ? 'ok' : 'fail'}">
          <p class="sources-phase-head">
            <strong>${dbEscapeHtml(String(row?.phase || 'phase'))}</strong>
            <span class="status-pill ${statusClass(ok ? 'ok' : 'warning')}">${ok ? 'hit' : 'miss'}</span>
          </p>
          <p>${dbEscapeHtml(String(row?.detail || ''))}</p>
          ${urlMarkup}
        </article>
      `;
    })
    .join('');
}

function sourcesRenderDetail(payload) {
  const summary = document.getElementById('sources-summary');
  const current = document.getElementById('sources-current');
  if (!summary || !current) return;
  if (!payload || payload.ok !== true) {
    summary.innerHTML = '';
    current.innerHTML = '<p class="small">No document selected.</p>';
    return;
  }
  const resource = payload.resource || {};
  const sources = payload.sources || {};
  const candidates = Array.isArray(sources.candidates) ? sources.candidates : [];
  const references = Array.isArray(payload.references) ? payload.references : [];
  const extraction = payload.extraction || {};
  const hasSource = Boolean(sources.has_external_source);

  summary.innerHTML = `
    ${metricCard('Resource ID', `<code>${dbEscapeHtml(String(resource.id || 'n/a'))}</code>`, 'Internal immutable resource identifier.')}
    ${metricCard('Primary Source', hasSource ? `<code>${dbEscapeHtml(String(sources.primary_url || ''))}</code>` : '<span class="status-pill status-warn">missing</span>', 'Canonical external source URL currently recorded.')}
    ${metricCard('Source Candidates', dbEscapeHtml(String(candidates.length)), 'Known URL/DOI candidates stored for this resource.')}
    ${metricCard('Linked References', dbEscapeHtml(String(references.length)), 'Reference entries linked through citation mappings.')}
    ${metricCard('Extracted Text', extraction.available ? `${dbEscapeHtml(String(extraction.char_count || 0))} chars` : 'not available', 'Latest extracted text used for source signal mining.')}
  `;

  const sourceUri = String(sources.source_uri || '').trim();
  const sourceUriMarkup = sourceUri
    ? `<p><strong>source_uri:</strong> <code>${dbEscapeHtml(sourceUri)}</code></p>`
    : '<p><strong>source_uri:</strong> not set</p>';
  const candidateMarkup = candidates.length
    ? `<ul class="sources-url-list">${candidates.map((url) => `<li><code>${dbEscapeHtml(String(url || ''))}</code></li>`).join('')}</ul>`
    : '<p class="small">No source candidates stored yet.</p>';
  const refsMarkup = references.length
    ? `<ul class="sources-url-list">${references.slice(0, 8).map((ref) => {
      const cite = String(ref?.cite_id || '');
      const title = String(ref?.title || '');
      const doi = String(ref?.doi || '');
      const url = String(ref?.url || '');
      const bits = [];
      if (cite) bits.push(`<strong>${dbEscapeHtml(cite)}</strong>`);
      if (title) bits.push(dbEscapeHtml(title));
      if (doi) bits.push(`<code>${dbEscapeHtml(doi)}</code>`);
      if (url) bits.push(`<code>${dbEscapeHtml(url)}</code>`);
      return `<li>${bits.join('  ')}</li>`;
    }).join('')}</ul>`
    : '<p class="small">No linked references.</p>';
  const preview = String(extraction.text_preview || '').trim();
  const previewMarkup = preview
    ? `<pre class="sources-text-preview">${dbEscapeHtml(preview)}</pre>`
    : '<p class="small">No extracted text preview available.</p>';

  current.innerHTML = `
    <article class="issue-item issue-info">
      <strong>${dbEscapeHtml(sourcesDisplayLabel(resource))}</strong>
      ${sourceUriMarkup}
      <p><strong>Primary source:</strong> ${sources.primary_url ? `<code>${dbEscapeHtml(String(sources.primary_url))}</code>` : 'missing'}</p>
      <p><strong>Source candidates</strong></p>
      ${candidateMarkup}
      <p><strong>Linked references</strong></p>
      ${refsMarkup}
      <p><strong>Extracted text preview</strong></p>
      ${previewMarkup}
    </article>
  `;
}

function sourcesSetRecoverLoading(loading) {
  const isLoading = Boolean(loading);
  sourcesState.recoverInFlight = isLoading;
  const localBtn = document.getElementById('sources-recover-local-btn');
  const webBtn = document.getElementById('sources-recover-web-btn');
  if (localBtn) localBtn.disabled = isLoading;
  if (webBtn) {
    webBtn.disabled = isLoading;
    webBtn.textContent = isLoading ? 'Searching...' : 'Search Web And Recover';
  }
}

async function sourcesRefreshResources() {
  const q = (document.getElementById('sources-filter').value || '').trim();
  const missingOnly = Boolean(document.getElementById('sources-missing-only')?.checked);
  const params = new URLSearchParams();
  params.set('limit', '10000');
  if (q) params.set('q', q);
  if (missingOnly) params.set('missing_only', 'true');
  sourcesSetStatus('Loading source inventory...');
  const payload = await callApi('GET', `/api/sources/resources?${params.toString()}`, null, 'out-sources');
  if (!payload || payload.ok !== true) {
    const detail = String(payload?.detail || payload?.error || '').trim();
    sourcesSetStatus(detail ? `Unable to load source inventory: ${detail}` : 'Unable to load source inventory.');
    return;
  }
  const resources = Array.isArray(payload.resources) ? payload.resources : [];
  sourcesState.resources = resources;
  sourcesRenderList(resources);
  sourcesSetStatus(`Loaded ${resources.length} resource(s).`);
}

async function sourcesLoadSelected() {
  const resourceId = sourcesSelectedId();
  if (!resourceId) {
    sourcesSetStatus('Select a document first.');
    return;
  }
  sourcesSetStatus('Loading source details...');
  const payload = await callApi('GET', `/api/sources/resources/${encodeURIComponent(resourceId)}`, null, 'out-sources');
  if (!payload || payload.ok !== true) {
    const detail = String(payload?.detail || payload?.error || '').trim();
    sourcesSetStatus(detail ? `Unable to load source details: ${detail}` : 'Unable to load source details.');
    return;
  }
  sourcesState.current = payload;
  sourcesRenderDetail(payload);
  sourcesSetStatus('Source details loaded.');
}

async function sourcesRecover(enableWebSearch) {
  if (sourcesState.recoverInFlight) return;
  const resourceId = sourcesSelectedId();
  if (!resourceId) {
    sourcesSetStatus('Select a document before running recovery.');
    return;
  }
  const enableWayback = Boolean(document.getElementById('sources-wayback-toggle')?.checked);
  const enableManifest = Boolean(document.getElementById('sources-manifest-toggle')?.checked);
  sourcesSetRecoverLoading(true);
  navSetPaneActivity('sources', { active: true, indeterminate: true, title: 'Recovering source URLs...' });
  sourcesSetStatus(enableWebSearch ? 'Running full source recovery (including web query)...' : 'Running local source recovery...');
  try {
    const payload = await callApi(
      'POST',
      `/api/sources/resources/${encodeURIComponent(resourceId)}/recover`,
      {
        enable_web_search: Boolean(enableWebSearch),
        enable_wayback_lookup: enableWayback,
        use_manifest_scan: enableManifest,
        manifest_root: '/Volumes/X10/data',
      },
      'out-sources'
    );
    if (!payload || payload.ok !== true) {
      const detail = String(payload?.detail || payload?.error || '').trim();
      sourcesSetStatus(detail ? `Source recovery failed: ${detail}` : 'Source recovery failed.');
      return;
    }
    const result = payload.result || {};
    sourcesRenderRecoveryLog(result);
    await sourcesLoadSelected();
    const resolved = String(result?.resolved_url || '').trim();
    const phase = String(result?.selected_phase || '').trim();
    if (resolved) {
      sourcesSetStatus(`Recovered source URL via ${phase || 'recovery'}: ${resolved}`);
    } else if (result?.blocked_reason) {
      sourcesSetStatus(`No source URL resolved. Search appears blocked (${result.blocked_reason}); manual browser fallback may be required.`);
    } else {
      sourcesSetStatus('No source URL resolved for this document.');
    }
  } finally {
    sourcesSetRecoverLoading(false);
    navSetPaneActivity('sources', { active: false });
  }
}

async function sourcesSetPrimary() {
  const resourceId = sourcesSelectedId();
  if (!resourceId) {
    sourcesSetStatus('Select a document first.');
    return;
  }
  const url = (document.getElementById('sources-manual-url').value || '').trim();
  if (!url) {
    sourcesSetStatus('Enter a source URL or DOI to save.');
    return;
  }
  sourcesSetStatus('Saving primary source...');
  const payload = await callApi(
    'POST',
    `/api/sources/resources/${encodeURIComponent(resourceId)}/primary`,
    { url },
    'out-sources'
  );
  if (!payload || payload.ok !== true) {
    const detail = String(payload?.detail || payload?.error || '').trim();
    sourcesSetStatus(detail ? `Unable to save primary source: ${detail}` : 'Unable to save primary source.');
    return;
  }
  await sourcesLoadSelected();
  sourcesSetStatus('Primary source updated.');
}

function initSourcesPane() {
  const filter = document.getElementById('sources-filter');
  if (filter) {
    filter.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        sourcesRefreshResources();
      }
    });
  }
  const missingOnly = document.getElementById('sources-missing-only');
  if (missingOnly) {
    missingOnly.addEventListener('change', () => {
      sourcesRefreshResources();
    });
  }
  sourcesRefreshResources();
}

let dbTables = [];
let dbLastPayload = null;
let dbGridSource = null;
let dbGridState = {
  sortColumn: null,
  sortDirection: 'asc',
  globalSearch: '',
  columnFilters: {},
};

function currentDbTable() {
  return document.getElementById('db-table-select').value;
}

function dbOutputMode() {
  const select = document.getElementById('db-view-mode');
  return select ? select.value : 'spreadsheet';
}

function renderDbResult(payload) {
  dbLastPayload = payload;
  document.getElementById('out-db').textContent = JSON.stringify(payload, null, 2);
}

function dbEscapeHtml(value) {
  return String(value)
    .replaceAll('&', '&amp;')
    .replaceAll('<', '&lt;')
    .replaceAll('>', '&gt;')
    .replaceAll('"', '&quot;')
    .replaceAll("'", '&#39;');
}

function dbCellText(value) {
  if (value === null || value === undefined) return '';
  if (typeof value === 'object') return JSON.stringify(value);
  return String(value);
}

function dbMaybeNumber(value) {
  if (typeof value === 'number' && Number.isFinite(value)) return value;
  if (typeof value !== 'string') return null;
  const trimmed = value.trim();
  if (!trimmed) return null;
  if (!/^[+-]?\d+(\.\d+)?$/.test(trimmed)) return null;
  const num = Number(trimmed);
  return Number.isFinite(num) ? num : null;
}

function dbResetGridState() {
  dbGridState.sortColumn = null;
  dbGridState.sortDirection = 'asc';
  dbGridState.globalSearch = '';
  dbGridState.columnFilters = {};
  const search = document.getElementById('db-search');
  if (search) search.value = '';
}

function dbSetGridSource(source) {
  dbGridSource = source;
  dbResetGridState();
  if (dbOutputMode() === 'spreadsheet') dbRenderGrid();
}

function dbSetGridMessage(message) {
  const meta = document.getElementById('db-grid-meta');
  const table = document.getElementById('db-grid-table');
  if (meta) meta.textContent = message;
  if (table) table.innerHTML = '';
}

function dbFilteredSortedRows() {
  if (!dbGridSource) return [];
  const columns = dbGridSource.columns;
  const global = (dbGridState.globalSearch || '').trim().toLowerCase();
  let rows = dbGridSource.rows.filter((row) => {
    if (global) {
      const hasGlobal = columns.some((col) => dbCellText(row[col]).toLowerCase().includes(global));
      if (!hasGlobal) return false;
    }
    for (const col of columns) {
      const filter = (dbGridState.columnFilters[col] || '').trim().toLowerCase();
      if (!filter) continue;
      if (!dbCellText(row[col]).toLowerCase().includes(filter)) return false;
    }
    return true;
  });

  const sortCol = dbGridState.sortColumn;
  if (!sortCol) return rows;
  const direction = dbGridState.sortDirection === 'desc' ? -1 : 1;
  rows = [...rows].sort((a, b) => {
    const av = a[sortCol];
    const bv = b[sortCol];
    if (av === bv) return 0;
    if (av === null || av === undefined) return 1 * direction;
    if (bv === null || bv === undefined) return -1 * direction;

    const an = dbMaybeNumber(av);
    const bn = dbMaybeNumber(bv);
    if (an !== null && bn !== null) return (an - bn) * direction;

    const as = dbCellText(av);
    const bs = dbCellText(bv);
    return as.localeCompare(bs, undefined, { numeric: true, sensitivity: 'base' }) * direction;
  });
  return rows;
}

function dbRenderGrid() {
  if (!dbGridSource || !Array.isArray(dbGridSource.columns) || !dbGridSource.columns.length) {
    dbSetGridMessage('No tabular data loaded yet.');
    return;
  }
  const columns = dbGridSource.columns;
  const visibleRows = dbFilteredSortedRows();
  const meta = document.getElementById('db-grid-meta');
  if (meta) {
    const loaded = dbGridSource.rows.length;
    const total = dbGridSource.totalRows ?? loaded;
    const offset = dbGridSource.offset ?? 0;
    const limit = dbGridSource.limit ?? loaded;
    const scope = dbGridSource.title || 'Current view';
    meta.textContent = `${scope}: ${visibleRows.length} matching rows (loaded ${loaded}, table total ${total}, offset ${offset}, limit ${limit}).`;
  }

  const table = document.getElementById('db-grid-table');
  const header = columns
    .map((col, idx) => {
      const active = dbGridState.sortColumn === col;
      const arrow = active ? (dbGridState.sortDirection === 'asc' ? ' ' : ' ') : '';
      return `<th><button class="db-sort-btn" type="button" data-col-idx="${idx}">${dbEscapeHtml(col)}${arrow}</button></th>`;
    })
    .join('');
  const filters = columns
    .map((col, idx) => {
      const value = dbGridState.columnFilters[col] || '';
      return `<th><input class="db-filter-input" data-col-idx="${idx}" value="${dbEscapeHtml(value)}" placeholder="Filter" /></th>`;
    })
    .join('');
  const body = visibleRows.length
    ? visibleRows
        .map((row) => {
          const cells = columns.map((col) => `<td class="db-cell">${dbEscapeHtml(dbCellText(row[col]))}</td>`).join('');
          return `<tr>${cells}</tr>`;
        })
        .join('')
    : `<tr><td class="small" colspan="${columns.length}">No rows match current filters.</td></tr>`;

  table.innerHTML = `<thead><tr>${header}</tr><tr class="db-filter-row">${filters}</tr></thead><tbody>${body}</tbody>`;

  table.querySelectorAll('.db-sort-btn').forEach((button) => {
    button.addEventListener('click', () => {
      const idx = Number(button.getAttribute('data-col-idx'));
      const col = columns[idx];
      if (!col) return;
      if (dbGridState.sortColumn === col) {
        dbGridState.sortDirection = dbGridState.sortDirection === 'asc' ? 'desc' : 'asc';
      } else {
        dbGridState.sortColumn = col;
        dbGridState.sortDirection = 'asc';
      }
      dbRenderGrid();
    });
  });
  table.querySelectorAll('.db-filter-input').forEach((input) => {
    input.addEventListener('input', () => {
      const idx = Number(input.getAttribute('data-col-idx'));
      const col = columns[idx];
      if (!col) return;
      dbGridState.columnFilters[col] = input.value || '';
      dbRenderGrid();
    });
  });
}

function dbSetViewMode(mode) {
  const allowed = new Set(['json', 'spreadsheet']);
  const selected = allowed.has(mode) ? mode : 'spreadsheet';
  const modeSelect = document.getElementById('db-view-mode');
  if (modeSelect && modeSelect.value !== selected) modeSelect.value = selected;
  localStorage.setItem('stemmaDbViewMode', selected);

  const pre = document.getElementById('out-db');
  const grid = document.getElementById('db-grid-view');
  const search = document.getElementById('db-search');
  const clear = document.getElementById('db-clear-filters');
  if (selected === 'spreadsheet') {
    if (grid) grid.classList.add('open');
    if (pre) pre.style.display = 'none';
    if (search) search.disabled = false;
    if (clear) clear.disabled = false;
    dbRenderGrid();
  } else {
    if (grid) grid.classList.remove('open');
    if (pre) pre.style.display = '';
    if (search) search.disabled = true;
    if (clear) clear.disabled = true;
    if (dbLastPayload) renderDbResult(dbLastPayload);
  }
}

function initDbExplorer() {
  const search = document.getElementById('db-search');
  if (search) {
    search.addEventListener('input', () => {
      dbGridState.globalSearch = search.value || '';
      if (dbOutputMode() === 'spreadsheet') dbRenderGrid();
    });
  }

  const savedMode = localStorage.getItem('stemmaDbViewMode');
  const modeSelect = document.getElementById('db-view-mode');
  if (modeSelect && (savedMode === 'json' || savedMode === 'spreadsheet')) {
    modeSelect.value = savedMode;
  }
  dbSetViewMode(modeSelect ? modeSelect.value : 'spreadsheet');
}

function dbClearFilters() {
  dbResetGridState();
  if (dbOutputMode() === 'spreadsheet') dbRenderGrid();
}

function refreshDbSelect() {
  const select = document.getElementById('db-table-select');
  const current = select.value;
  select.innerHTML = '';
  const placeholder = document.createElement('option');
  placeholder.value = '';
  placeholder.textContent = 'Select table';
  select.appendChild(placeholder);
  dbTables.forEach((t) => {
    const opt = document.createElement('option');
    opt.value = t.name;
    opt.textContent = `${t.name} (${t.row_count} rows)`;
    select.appendChild(opt);
  });
  if (current && dbTables.some((t) => t.name === current)) {
    select.value = current;
  }
}

async function dbListTables() {
  const data = await callApi('GET', '/api/db/tables', null, null);
  if (data && data.detail === 'Not Found') {
    const payload = {
      ok: false,
      error: 'Database Explorer API endpoint was not found on this server instance.',
      hint: 'Restart the web server from the current workspace so /api/db/tables is registered.',
      attempted_urls: data.attempted_urls || [],
    };
    renderDbResult(payload);
    dbSetGridMessage(payload.error);
    return;
  }

  dbTables = Array.isArray(data.tables) ? data.tables : [];
  refreshDbSelect();

  renderDbResult(data);
  dbSetGridSource({
    title: 'Table list',
    table: null,
    columns: ['name', 'row_count', 'column_count'],
    rows: dbTables.map((t) => ({
      name: t.name,
      row_count: t.row_count,
      column_count: Array.isArray(t.columns) ? t.columns.length : 0,
    })),
    totalRows: dbTables.length,
    offset: 0,
    limit: dbTables.length,
  });
}

async function dbViewTable() {
  const name = currentDbTable();
  if (!name) {
    const payload = { error: 'Select a table first.' };
    renderDbResult(payload);
    dbSetGridMessage(payload.error);
    return;
  }
  const limit = Number(document.getElementById('db-limit').value || '50');
  const offset = Number(document.getElementById('db-offset').value || '0');
  const safeLimit = Number.isFinite(limit) && limit > 0 ? Math.floor(limit) : 50;
  const safeOffset = Number.isFinite(offset) && offset >= 0 ? Math.floor(offset) : 0;
  const data = await callApi(
    'GET',
    `/api/db/table?name=${encodeURIComponent(name)}&limit=${safeLimit}&offset=${safeOffset}`,
    null,
    null
  );
  renderDbResult(data);
  if (!data || data.ok !== true || !Array.isArray(data.rows)) {
    dbSetGridMessage(data?.detail || data?.error || 'Unable to load table rows.');
    return;
  }
  dbSetGridSource({
    title: `Table: ${name}`,
    table: name,
    columns: Array.isArray(data.columns) ? data.columns : [],
    rows: data.rows,
    totalRows: Number.isFinite(data.total_rows) ? data.total_rows : data.rows.length,
    offset: safeOffset,
    limit: safeLimit,
  });
}

function dbDescribeTable() {
  const name = currentDbTable();
  if (!name) {
    const payload = { error: 'Select a table first.' };
    renderDbResult(payload);
    dbSetGridMessage(payload.error);
    return;
  }
  const match = dbTables.find((t) => t.name === name);
  if (!match) {
    const payload = { error: 'Table metadata not loaded. Click "List Tables" first.' };
    renderDbResult(payload);
    dbSetGridMessage(payload.error);
    return;
  }
  const payload = {
    ok: true,
    table: name,
    row_count: match.row_count,
    columns: match.columns,
    create_sql: match.create_sql,
  };
  renderDbResult(payload);
  dbSetGridSource({
    title: `Schema: ${name}`,
    table: name,
    columns: ['name', 'type', 'notnull', 'pk'],
    rows: Array.isArray(match.columns)
      ? match.columns.map((c) => ({
          name: c.name,
          type: c.type,
          notnull: c.notnull,
          pk: c.pk,
        }))
      : [],
    totalRows: Array.isArray(match.columns) ? match.columns.length : 0,
    offset: 0,
    limit: Array.isArray(match.columns) ? match.columns.length : 0,
  });
}

const VIEWER_PDFJS_SRC = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js';
const VIEWER_PDFJS_WORKER_SRC = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

const viewerState = {
  resources: [],
  payload: null,
  resourceId: '',
  displayTitle: '',
  displayTitleOverrideById: {},
  sourceLabel: '',
  inspectorOpen: true,
  inspectorTab: 'overlays',
  renderMode: 'empty',
  renderError: '',
  renderDiagnostics: null,
  selectedTableId: '',
  selectedSegmentId: '',
  selectedAnnotationId: '',
  selectedImageId: '',
  selectedKind: '',
  reviewByKey: {},
  tableEditMode: false,
  indexTablePage: 1,
  indexTablePageSize: 24,
  indexFilterText: '',
  indexFilterType: 'all',
  selectedCellRow: null,
  selectedCellCol: null,
  contentKind: 'binary',
  nonPdfTextContent: '',
  nonPdfTextLoading: false,
  nonPdfTextResourceId: '',
  nonPdfTextToken: 0,
  page: 1,
  pageCount: 1,
  zoom: 1,
  minZoom: 0.5,
  maxZoom: 3.2,
  pageIndexBase: 0,
  pageOffsetRangeByIndex: {},
  syntheticPageOffsetRangeByIndex: {},
  syntheticPageOffsetPromise: null,
  pageTextLayoutCache: {},
  pageTextLayoutPromises: {},
  pdfDoc: null,
  pdfJsPromise: null,
  pdfLoadToken: 0,
  renderToken: 0,
  pageBaseWidth: 0,
  pageBaseHeight: 0,
  panEnabled: false,
  panDragging: false,
  panStartX: 0,
  panStartY: 0,
  panScrollLeft: 0,
  panScrollTop: 0,
  toastTimer: null,
};

function viewerSetStatus(message) {
  const el = document.getElementById('viewer-status');
  if (el) el.textContent = String(message || '');
}

function viewerFlashToast(message) {
  const toast = document.getElementById('viewer-toast');
  if (!toast) return;
  toast.textContent = String(message || '');
  toast.classList.add('visible');
  if (viewerState.toastTimer) window.clearTimeout(viewerState.toastTimer);
  viewerState.toastTimer = window.setTimeout(() => {
    toast.classList.remove('visible');
  }, 1600);
}

function viewerFormatDate(value) {
  if (!value) return 'n/a';
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) return String(value);
  return date.toLocaleString();
}

function viewerLooksLikeUuid(value) {
  return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(String(value || '').trim());
}

function viewerCleanTitleCandidate(value) {
  let text = String(value || '').trim();
  if (!text) return '';
  text = text.replace(/^upload:/i, '');
  text = text.replace(/\?.*$/, '');
  text = text.replace(/^.*[\\/]/, '');
  text = text.replace(/\.[a-z0-9]{2,6}$/i, '');
  text = text.replace(/[_]+/g, ' ');
  text = text.replace(/[-]+/g, ' ');
  text = text.replace(/\s+/g, ' ').trim();
  if (!text || viewerLooksLikeUuid(text)) return '';
  return text;
}

function viewerReadableHost(sourceUri) {
  const value = String(sourceUri || '').trim();
  if (!value) return '';
  if (value.startsWith('upload:')) return 'Uploaded file';
  try {
    const url = new URL(value);
    return url.hostname || '';
  } catch {
    return '';
  }
}

function viewerDeriveDisplayTitle(payload) {
  const meta = payload?.metadata || {};
  const resource = payload?.resource || {};
  const candidates = [
    resource.display_title,
    meta.display_title,
    resource.title,
    meta.title,
    meta.original_filename,
    resource.original_filename,
    meta.source_uri,
    resource.source_uri,
  ];
  for (const candidate of candidates) {
    const cleaned = viewerCleanTitleCandidate(candidate);
    if (cleaned) return cleaned;
  }
  const id = String(meta.resource_id || resource.id || '').slice(0, 8);
  return id ? `Document ${id}` : 'Untitled document';
}

function viewerTitleCandidates(payload) {
  const meta = payload?.metadata || {};
  const resource = payload?.resource || {};
  const parsed = viewerTryParseJson(
    meta.title_candidates_json || resource.title_candidates_json,
    []
  );
  const values = [];
  if (Array.isArray(parsed)) {
    parsed.forEach((entry) => {
      const cleaned = String(entry || '').trim();
      if (!cleaned || values.includes(cleaned)) return;
      values.push(cleaned);
    });
  }
  const current = String(resource.display_title || meta.display_title || '').trim();
  if (current && !values.includes(current)) values.unshift(current);
  return values.slice(0, 12);
}

function viewerDeriveSourceLabel(payload) {
  const meta = payload?.metadata || {};
  const resource = payload?.resource || {};
  const sourceUri = String(meta.source_uri || resource.source_uri || '');
  const host = viewerReadableHost(sourceUri);
  if (host) return host;
  const filename = viewerCleanTitleCandidate(meta.original_filename || resource.original_filename);
  return filename || 'Local archive';
}

function viewerEffectiveTitle(payload) {
  const resourceId = String(payload?.resource?.id || payload?.metadata?.resource_id || '');
  const override = viewerState.displayTitleOverrideById[resourceId];
  if (override && String(override).trim()) return String(override).trim();
  return viewerDeriveDisplayTitle(payload);
}

function viewerSetRenderMode(mode, diagnostics = null) {
  viewerState.renderMode = mode;
  viewerState.renderDiagnostics = diagnostics;
  const badge = document.getElementById('viewer-render-mode-badge');
  if (badge) {
    let label = 'No document';
    if (mode === 'interactive') label = 'Interactive PDF';
    if (mode === 'fallback') label = 'Fallback PDF';
    if (mode === 'nonpdf') label = 'Source view';
    if (mode === 'empty') label = 'No document';
    badge.textContent = label;
  }
  const overlaysEnabled = mode === 'interactive';
  viewerSetOverlayControlsEnabled(overlaysEnabled, overlaysEnabled ? '' : 'Overlays are only available in interactive PDF mode.');
}

function viewerSetOverlayControlsEnabled(enabled, reason = '') {
  const ids = ['viewer-toggle-tables', 'viewer-toggle-segments', 'viewer-toggle-annotations', 'viewer-pan-toggle'];
  ids.forEach((id) => {
    const el = document.getElementById(id);
    if (!el) return;
    el.disabled = !enabled;
    if (!enabled) {
      el.title = reason;
      if (id === 'viewer-pan-toggle') el.checked = false;
    } else {
      el.title = '';
    }
  });
  if (!enabled) viewerTogglePan(false);
}

function viewerToggleInspector(forceOpen) {
  const layout = document.getElementById('viewer-layout');
  const button = document.getElementById('viewer-info-toggle');
  if (!layout || !button) return;
  if (typeof forceOpen === 'boolean') {
    viewerState.inspectorOpen = forceOpen;
  } else {
    viewerState.inspectorOpen = !viewerState.inspectorOpen;
  }
  layout.classList.toggle('inspector-collapsed', !viewerState.inspectorOpen);
  button.setAttribute('aria-expanded', viewerState.inspectorOpen ? 'true' : 'false');
}

function viewerSetInspectorTab(tab) {
  const allowed = new Set(['overlays', 'tables', 'annotations']);
  const nextTab = allowed.has(tab) ? tab : 'overlays';
  viewerState.inspectorTab = nextTab;
  ['overlays', 'tables', 'annotations'].forEach((name) => {
    const panel = document.getElementById(`viewer-panel-${name}`);
    const button = document.getElementById(`viewer-tab-${name}`);
    const active = name === nextTab;
    if (panel) panel.hidden = !active;
    if (button) button.classList.toggle('active', active);
  });
}

function viewerPageLinkFragment() {
  return `#page=${Math.max(1, viewerState.page)}&zoom=${Math.round(viewerState.zoom * 100)}`;
}

function viewerCurrentContentUrl(includeDownload = false) {
  const url = String(viewerState.payload?.content?.url || '');
  if (!url) return '';
  if (!includeDownload) return url;
  return url.includes('?') ? `${url}&download=true` : `${url}?download=true`;
}

async function viewerCopyText(text) {
  const value = String(text || '');
  if (!value) return;
  if (navigator.clipboard && navigator.clipboard.writeText) {
    await navigator.clipboard.writeText(value);
    return;
  }
  const area = document.createElement('textarea');
  area.value = value;
  area.setAttribute('readonly', 'readonly');
  area.style.position = 'absolute';
  area.style.left = '-9999px';
  document.body.appendChild(area);
  area.select();
  document.execCommand('copy');
  document.body.removeChild(area);
}

async function viewerCopyField(value, label = 'Value') {
  const text = String(value || '').trim();
  if (!text) {
    viewerSetStatus(`No ${label.toLowerCase()} available to copy.`);
    return;
  }
  try {
    await viewerCopyText(text);
    viewerFlashToast(`${label} copied.`);
  } catch (error) {
    viewerSetStatus(`Unable to copy ${label.toLowerCase()}: ${String(error)}`);
  }
}

function viewerBuildDiagnosticPayload(errorMessage = '') {
  const payload = viewerState.payload || {};
  const meta = payload.metadata || {};
  const extraction = payload.extraction || {};
  return {
    render_mode: viewerState.renderMode,
    render_error: String(errorMessage || viewerState.renderError || ''),
    resource_id: meta.resource_id || payload?.resource?.id || '',
    digest_sha256: meta.digest_sha256 || '',
    media_type: meta.media_type || payload?.resource?.media_type || '',
    content_kind: payload?.content?.kind || viewerState.contentKind || '',
    content_url: payload?.content?.url || '',
    page: viewerState.page,
    zoom_percent: Math.round(viewerState.zoom * 100),
    overlay_ready: Boolean(extraction.overlay_ready),
    extraction_error: extraction.error || '',
    user_agent: navigator.userAgent,
    timestamp_iso: new Date().toISOString(),
  };
}

function viewerCopyDiagnosticReport() {
  const diagnostics = viewerBuildDiagnosticPayload();
  viewerCopyField(JSON.stringify(diagnostics, null, 2), 'Diagnostic report');
}

function viewerCopyInternalReference() {
  const payload = viewerState.payload || {};
  const meta = payload.metadata || {};
  const ref = {
    resource_id: meta.resource_id || payload?.resource?.id || '',
    digest_sha256: meta.digest_sha256 || '',
  };
  viewerCopyField(JSON.stringify(ref, null, 2), 'Internal reference');
}

function viewerCopyDocumentLink() {
  const resourceId = String(viewerState.payload?.resource?.id || viewerState.resourceId || '').trim();
  if (!resourceId) {
    viewerSetStatus('Load a document before copying a link.');
    return;
  }
  const url = `${window.location.origin}/api/viewer/document?resource_id=${encodeURIComponent(resourceId)}`;
  viewerCopyField(url, 'Document link');
}

function viewerOpenCurrentExternal() {
  const url = viewerCurrentContentUrl(false);
  if (!url) {
    viewerSetStatus('No source URL available for this document.');
    return;
  }
  window.open(url, '_blank', 'noopener');
}

function viewerDownloadCurrent() {
  const url = viewerCurrentContentUrl(true);
  if (!url) {
    viewerSetStatus('No downloadable source URL available.');
    return;
  }
  window.open(url, '_blank', 'noopener');
}

async function viewerPersistTitle(title, candidates = null) {
  const resourceId = String(viewerState.payload?.resource?.id || viewerState.resourceId || '').trim();
  if (!resourceId) {
    viewerSetStatus('Load a document before renaming its display title.');
    return false;
  }
  const payload = await callApi(
    'POST',
    `/api/resources/${encodeURIComponent(resourceId)}/title`,
    {
      title,
      title_candidates: Array.isArray(candidates) ? candidates : null,
    },
    'out-viewer'
  );
  if (!payload || payload.ok !== true || !payload.resource) {
    viewerSetStatus(payload?.detail || payload?.error || 'Failed to persist display title.');
    return false;
  }
  if (viewerState.payload && viewerState.payload.resource) {
    viewerState.payload.resource = payload.resource;
  }
  if (viewerState.payload && viewerState.payload.metadata) {
    viewerState.payload.metadata.display_title = payload.resource.display_title || null;
    viewerState.payload.metadata.title_candidates_json = payload.resource.title_candidates_json || null;
  }
  return true;
}

async function viewerPromptRenameTitle() {
  const current = String(viewerState.displayTitle || '').trim();
  const next = window.prompt('Document title', current);
  if (next === null) return;
  const cleaned = String(next).trim();
  const resourceId = String(viewerState.payload?.resource?.id || viewerState.resourceId || '').trim();
  if (!resourceId) {
    viewerSetStatus('Load a document before renaming its display title.');
    return;
  }
  if (!cleaned) {
    delete viewerState.displayTitleOverrideById[resourceId];
  } else {
    viewerState.displayTitleOverrideById[resourceId] = cleaned;
  }
  const persisted = await viewerPersistTitle(cleaned || null, viewerTitleCandidates(viewerState.payload));
  if (!persisted) return;
  viewerState.displayTitle = viewerEffectiveTitle(viewerState.payload);
  viewerRenderHeader();
  viewerRenderMetadata();
  viewerFlashToast('Display title updated.');
}

async function viewerApplyTitleCandidate() {
  const select = document.getElementById('viewer-title-candidate-select');
  const value = String(select?.value || '').trim();
  if (!value) {
    viewerSetStatus('Choose a title candidate first.');
    return;
  }
  const persisted = await viewerPersistTitle(value, viewerTitleCandidates(viewerState.payload));
  if (!persisted) return;
  const resourceId = String(viewerState.payload?.resource?.id || viewerState.resourceId || '').trim();
  if (resourceId) viewerState.displayTitleOverrideById[resourceId] = value;
  viewerState.displayTitle = viewerEffectiveTitle(viewerState.payload);
  viewerRenderHeader();
  viewerRenderMetadata();
  viewerFlashToast('Title candidate applied.');
}

function viewerRenderHeader() {
  const payload = viewerState.payload;
  const titleEl = document.getElementById('viewer-doc-title');
  const subEl = document.getElementById('viewer-doc-subtitle');
  const breadcrumb = document.getElementById('viewer-breadcrumb');
  if (!titleEl || !subEl || !breadcrumb) return;
  if (!payload) {
    titleEl.textContent = 'No document selected';
    titleEl.title = '';
    subEl.textContent = 'Select a document to read the source file and inspect extracted content.';
    breadcrumb.textContent = 'Project / Document Viewer';
    return;
  }
  const meta = payload.metadata || {};
  const resource = payload.resource || {};
  const source = viewerState.sourceLabel || viewerDeriveSourceLabel(payload);
  const mediaType = String(meta.media_type || resource.media_type || payload?.content?.kind || 'unknown');
  const size = Number(payload?.content?.size_bytes || 0);
  const sizeMb = size > 0 ? `${(size / (1024 * 1024)).toFixed(2)} MB` : 'size n/a';
  const subtitle = `${source}  ${mediaType}  ${sizeMb}`;
  titleEl.textContent = viewerState.displayTitle || viewerDeriveDisplayTitle(payload);
  titleEl.title = titleEl.textContent;
  subEl.textContent = subtitle;
  breadcrumb.textContent = `Project / ${source} / Document`;
}

function viewerUpdatePageZoomLabels() {
  const page = document.getElementById('viewer-page-label');
  if (page) page.textContent = `Page ${viewerState.page} / ${viewerState.pageCount}`;
  const zoom = document.getElementById('viewer-zoom-label');
  if (zoom) zoom.textContent = `${Math.round(viewerState.zoom * 100)}%`;
}

function viewerResetPdfScrollPosition() {
  const scroll = document.getElementById('viewer-scroll');
  if (!scroll) return;
  scroll.scrollTop = 0;
  scroll.scrollLeft = 0;
}

function viewerTryParseJson(value, fallback = null) {
  if (value === null || value === undefined) return fallback;
  if (typeof value === 'object') return value;
  if (typeof value !== 'string') return fallback;
  try {
    return JSON.parse(value);
  } catch {
    return fallback;
  }
}

function viewerListLabel(resource) {
  if (!resource || typeof resource !== 'object') return 'unknown';
  const file = viewerCleanTitleCandidate(
    resource.display_title || resource.title || resource.original_filename || resource.source_uri
  ) || 'document';
  const media = String(resource.media_type || 'unknown');
  const source = viewerReadableHost(resource.source_uri);
  return source ? `${file} (${media})  ${source}` : `${file} (${media})`;
}

function viewerPopulateResourceSelect(selectedResourceId = '') {
  const select = document.getElementById('viewer-resource-select');
  if (!select) return;
  const current = selectedResourceId || select.value || viewerState.resourceId || '';
  select.innerHTML = '';
  const placeholder = document.createElement('option');
  placeholder.value = '';
  placeholder.textContent = 'Select resource';
  select.appendChild(placeholder);
  viewerState.resources.forEach((resource) => {
    const opt = document.createElement('option');
    opt.value = resource.id;
    opt.textContent = viewerListLabel(resource);
    select.appendChild(opt);
  });
  if (current && viewerState.resources.some((r) => r.id === current)) {
    select.value = current;
  }
}

async function viewerRefreshResources() {
  const payload = await callApi('GET', '/api/resources?limit=500', null, null);
  viewerState.resources = Array.isArray(payload?.resources) ? payload.resources : [];
  viewerPopulateResourceSelect();
}

function viewerSetActiveResource(resourceId) {
  viewerState.resourceId = resourceId || '';
  const select = document.getElementById('viewer-resource-select');
  if (select && viewerState.resourceId && viewerState.resources.some((r) => r.id === viewerState.resourceId)) {
    select.value = viewerState.resourceId;
  }
  const input = document.getElementById('viewer-resource-id');
  if (input) input.value = viewerState.resourceId || '';
}

function viewerCurrentTable() {
  if (!viewerState.payload || !Array.isArray(viewerState.payload.tables)) return null;
  return viewerState.payload.tables.find((t) => t.id === viewerState.selectedTableId) || null;
}

function viewerCurrentSegment() {
  if (!viewerState.payload || !Array.isArray(viewerState.payload.segments)) return null;
  return viewerState.payload.segments.find((s) => s.id === viewerState.selectedSegmentId) || null;
}

function viewerCurrentAnnotation() {
  if (!viewerState.payload || !Array.isArray(viewerState.payload.annotations)) return null;
  return viewerState.payload.annotations.find((a) => a.id === viewerState.selectedAnnotationId) || null;
}

function viewerCurrentImage() {
  if (!viewerState.payload || !Array.isArray(viewerState.payload.images)) return null;
  return viewerState.payload.images.find((img) => img.id === viewerState.selectedImageId) || null;
}

function viewerSelectionKey(kind, id) {
  const safeKind = String(kind || '').trim();
  const safeId = String(id || '').trim();
  if (!safeKind || !safeId) return '';
  return `${safeKind}:${safeId}`;
}

function viewerSetSelectionRaw(data) {
  const raw = document.getElementById('viewer-selected-raw');
  if (!raw) return;
  if (!data) {
    raw.textContent = 'Select an element to inspect raw data.';
    return;
  }
  raw.textContent = JSON.stringify(data, null, 2);
}

function viewerTableTitle(table, idx = 0) {
  const caption = String(table?.caption || '').trim();
  if (caption) return caption;
  const headers = Array.isArray(table?.col_headers)
    ? table.col_headers.map((h) => String(h || '').trim()).filter(Boolean)
    : [];
  if (headers.length) return `Table ${idx + 1}: ${headers.slice(0, 2).join(' / ')}`;
  const page = Number.isFinite(Number(table?.page_number)) ? `Page ${table.page_number}` : 'Page n/a';
  return `Table ${idx + 1} (${page})`;
}

function viewerMatchesIndexFilter(text) {
  const needle = String(viewerState.indexFilterText || '').trim().toLowerCase();
  if (!needle) return true;
  return String(text || '').toLowerCase().includes(needle);
}

function viewerOverlayToggleValue(id, fallback = true) {
  const el = document.getElementById(id);
  if (!el) return fallback;
  if (el.disabled) return false;
  return Boolean(el.checked);
}

function viewerToPageIndex(value) {
  if (value === null || value === undefined || value === '') return null;
  const raw = Number(value);
  if (!Number.isFinite(raw)) return null;
  const base = Number(viewerState.pageIndexBase) === 1 ? 1 : 0;
  const normalized = base === 1 ? (raw - 1) : raw;
  if (!Number.isFinite(normalized) || normalized < 0) return null;
  return Math.floor(normalized);
}

function viewerInferPageIndexBase(payload) {
  const values = [];
  const collect = (rows) => {
    if (!Array.isArray(rows)) return;
    rows.forEach((row) => {
      const n = Number(row?.page_index);
      if (Number.isFinite(n) && n >= 0) values.push(Math.floor(n));
    });
  };
  collect(payload?.tables);
  collect(payload?.segments);
  if (!values.length) return 0;
  return Math.min(...values) >= 1 ? 1 : 0;
}

function viewerClampPageNumber(pageNumber) {
  const n = Number(pageNumber);
  if (!Number.isFinite(n) || n < 1) return null;
  return Math.floor(n);
}

function viewerEntityPageNumber(entity) {
  if (!entity || typeof entity !== 'object') return null;
  const fromIndex = viewerToPageIndex(entity.page_index);
  const resolved = fromIndex !== null
    ? viewerClampPageNumber(fromIndex + 1)
    : viewerClampPageNumber(entity.page_number);
  if (resolved === null) return null;
  if (viewerState.pdfDoc && Number.isFinite(Number(viewerState.pageCount)) && Number(viewerState.pageCount) > 0) {
    return Math.max(1, Math.min(resolved, Math.floor(Number(viewerState.pageCount))));
  }
  return resolved;
}

function viewerNumericOffset(value) {
  const n = Number(value);
  if (!Number.isFinite(n)) return null;
  return Math.floor(n);
}

function viewerBuildPageOffsetRanges(segments) {
  const grouped = {};
  const rows = Array.isArray(segments) ? segments : [];
  rows.forEach((segment) => {
    if (!segment || typeof segment !== 'object') return;
    const pageIndex = viewerToPageIndex(segment.page_index);
    if (pageIndex === null) return;
    const start = viewerNumericOffset(segment.start_offset);
    const end = viewerNumericOffset(segment.end_offset);
    if (start === null || end === null) return;
    const safeStart = Math.min(start, end);
    const safeEnd = Math.max(start, end);
    if (safeEnd <= safeStart) return;
    const type = String(segment.segment_type || '').toLowerCase();
    let priority = 1;
    if (type.includes('layout:document')) priority = 3;
    else if (type.includes('paragraph')) priority = 2;
    const key = String(pageIndex);
    if (!grouped[key]) grouped[key] = [];
    grouped[key].push({ start: safeStart, end: safeEnd, priority });
  });

  const byPage = {};
  Object.entries(grouped).forEach(([key, entries]) => {
    if (!Array.isArray(entries) || !entries.length) return;
    const bestPriority = Math.max(...entries.map((entry) => Number(entry.priority) || 0));
    const picked = entries.filter((entry) => (Number(entry.priority) || 0) === bestPriority);
    const start = Math.min(...picked.map((entry) => Number(entry.start)));
    const end = Math.max(...picked.map((entry) => Number(entry.end)));
    if (!Number.isFinite(start) || !Number.isFinite(end) || end <= start) return;
    byPage[key] = {
      start: Math.floor(start),
      end: Math.floor(end),
      span: Math.max(1, Math.floor(end - start)),
      priority: bestPriority,
    };
  });
  return byPage;
}

function viewerPageIndexFromSegmentAttrs(segment) {
  if (!segment || typeof segment !== 'object') return null;
  const attrs = segment.attrs;
  if (!attrs || typeof attrs !== 'object') return null;

  const directIndexKeys = ['page_index', 'pageIndex'];
  for (const key of directIndexKeys) {
    const value = viewerToPageIndex(attrs[key]);
    if (value !== null) return value;
  }
  const oneBasedKeys = ['page_number', 'pageNumber', 'page_no', 'pageNo', 'page'];
  for (const key of oneBasedKeys) {
    const value = viewerClampPageNumber(attrs[key]);
    if (value !== null) return value - 1;
  }

  const prov = Array.isArray(attrs.prov)
    ? attrs.prov
    : (Array.isArray(attrs.provenance) ? attrs.provenance : []);
  for (const entry of prov) {
    if (!entry || typeof entry !== 'object') continue;
    for (const key of directIndexKeys) {
      const value = viewerToPageIndex(entry[key]);
      if (value !== null) return value;
    }
    for (const key of oneBasedKeys) {
      const value = viewerClampPageNumber(entry[key]);
      if (value !== null) return value - 1;
    }
  }
  return null;
}

function viewerOffsetRangeEntries(rangeMap) {
  return Object.entries(rangeMap || {})
    .map(([key, value]) => {
      const pageIndex = Number(key);
      const rangeStart = viewerNumericOffset(value?.start);
      const rangeEnd = viewerNumericOffset(value?.end);
      if (!Number.isFinite(pageIndex) || rangeStart === null || rangeEnd === null || rangeEnd <= rangeStart) {
        return null;
      }
      return { pageIndex: Math.floor(pageIndex), start: rangeStart, end: rangeEnd, span: rangeEnd - rangeStart };
    })
    .filter(Boolean);
}

function viewerCombinedPageOffsetRanges() {
  const primary = viewerState.pageOffsetRangeByIndex || {};
  const synthetic = viewerState.syntheticPageOffsetRangeByIndex || {};
  if (Object.keys(primary).length) return primary;
  return synthetic;
}

function viewerGetPageOffsetRange(pageIndex) {
  const key = String(Math.floor(Number(pageIndex)));
  const primary = viewerState.pageOffsetRangeByIndex || {};
  if (primary[key]) return primary[key];
  const synthetic = viewerState.syntheticPageOffsetRangeByIndex || {};
  if (synthetic[key]) return synthetic[key];
  return null;
}

async function viewerEnsureSyntheticPageOffsetRanges() {
  if (!viewerState.pdfDoc) return {};
  if (Object.keys(viewerState.syntheticPageOffsetRangeByIndex || {}).length) {
    return viewerState.syntheticPageOffsetRangeByIndex;
  }
  if (viewerState.syntheticPageOffsetPromise) return viewerState.syntheticPageOffsetPromise;

  viewerState.syntheticPageOffsetPromise = (async () => {
    const next = {};
    const totalPages = Math.max(1, Math.floor(Number(viewerState.pageCount) || 1));
    let cursor = 0;
    for (let page = 1; page <= totalPages; page += 1) {
      const layout = await viewerEnsurePageTextLayout(page);
      const chars = Math.max(1, Math.floor(Number(layout?.totalChars) || 0));
      next[String(page - 1)] = {
        start: cursor,
        end: cursor + chars,
        span: chars,
        synthetic: true,
      };
      cursor += chars;
    }
    viewerState.syntheticPageOffsetRangeByIndex = next;
    return next;
  })();

  try {
    return await viewerState.syntheticPageOffsetPromise;
  } catch {
    return viewerState.syntheticPageOffsetRangeByIndex || {};
  } finally {
    viewerState.syntheticPageOffsetPromise = null;
  }
}

function viewerPrimeSyntheticPageRanges() {
  if (!viewerState.pdfDoc || viewerState.contentKind !== 'pdf') return;
  if (Object.keys(viewerState.pageOffsetRangeByIndex || {}).length) return;
  viewerEnsureSyntheticPageOffsetRanges().then(() => {
    if (!viewerState.payload) return;
    viewerRenderStructuredData();
    viewerRenderOverlayList();
    viewerRenderOverlay();
  });
}

function viewerInferPageIndexFromOffsetRange(startOffset, endOffset, rangeMap = null) {
  const start = viewerNumericOffset(startOffset);
  const end = viewerNumericOffset(endOffset);
  if (start === null || end === null) return null;
  const safeStart = Math.min(start, end);
  const safeEnd = Math.max(start, end);
  if (safeEnd <= safeStart) return null;

  const ranges = viewerOffsetRangeEntries(rangeMap || viewerCombinedPageOffsetRanges());
  if (!ranges.length) return null;

  const mid = (safeStart + safeEnd) / 2;
  const overlaps = [];
  const nearest = [];
  for (const range of ranges) {
    if (range.end > safeStart && range.start < safeEnd) {
      const center = (range.start + range.end) / 2;
      overlaps.push({ pageIndex: range.pageIndex, span: range.span, dist: Math.abs(center - mid) });
      continue;
    }
    const distance = safeEnd <= range.start ? (range.start - safeEnd) : (safeStart - range.end);
    const center = (range.start + range.end) / 2;
    nearest.push({ pageIndex: range.pageIndex, distance, dist: Math.abs(center - mid) });
  }
  if (overlaps.length) {
    overlaps.sort((a, b) => (a.span - b.span) || (a.dist - b.dist) || (a.pageIndex - b.pageIndex));
    return overlaps[0].pageIndex;
  }
  if (nearest.length) {
    nearest.sort((a, b) => (a.distance - b.distance) || (a.dist - b.dist) || (a.pageIndex - b.pageIndex));
    return nearest[0].pageIndex;
  }
  return null;
}

function viewerResolvedSegmentPageIndex(segment) {
  if (!segment || typeof segment !== 'object') return null;
  const explicit = viewerToPageIndex(segment.page_index);
  if (explicit !== null) return explicit;
  const topLevelPageNumber = viewerClampPageNumber(segment.page_number);
  if (topLevelPageNumber !== null) return topLevelPageNumber - 1;
  const attrsPage = viewerPageIndexFromSegmentAttrs(segment);
  if (attrsPage !== null) return attrsPage;
  const inferred = viewerInferPageIndexFromOffsetRange(segment.start_offset, segment.end_offset, viewerState.pageOffsetRangeByIndex);
  if (inferred !== null) return inferred;
  return viewerInferPageIndexFromOffsetRange(segment.start_offset, segment.end_offset, viewerState.syntheticPageOffsetRangeByIndex);
}

function viewerResolvedSegmentPageNumber(segment) {
  const pageIndex = viewerResolvedSegmentPageIndex(segment);
  if (pageIndex === null) return null;
  return pageIndex + 1;
}

function viewerResetStage() {
  viewerState.pdfDoc = null;
  viewerState.page = 1;
  viewerState.pageCount = 1;
  viewerState.pageBaseWidth = 0;
  viewerState.pageBaseHeight = 0;
  viewerState.syntheticPageOffsetRangeByIndex = {};
  viewerState.syntheticPageOffsetPromise = null;
  viewerState.pageTextLayoutCache = {};
  viewerState.pageTextLayoutPromises = {};
  viewerState.renderError = '';
  viewerState.renderDiagnostics = null;
  viewerUpdatePageZoomLabels();
  const canvas = document.getElementById('viewer-pdf-canvas');
  const overlay = document.getElementById('viewer-overlay-canvas');
  if (canvas) {
    canvas.style.display = 'none';
    canvas.width = 0;
    canvas.height = 0;
  }
  if (overlay) {
    overlay.style.display = 'none';
    overlay.width = 0;
    overlay.height = 0;
  }
  viewerSetRenderMode('empty');
}

function viewerShowFallback(html) {
  const fallback = document.getElementById('viewer-fallback');
  if (fallback) fallback.innerHTML = html;
  const canvas = document.getElementById('viewer-pdf-canvas');
  const overlay = document.getElementById('viewer-overlay-canvas');
  if (canvas) canvas.style.display = 'none';
  if (overlay) overlay.style.display = 'none';
}

function viewerBuildPdfFallbackState(url, errorMessage = '') {
  const rawUrl = String(url || '');
  const openUrl = dbEscapeHtml(rawUrl);
  const downloadUrl = dbEscapeHtml(rawUrl ? `${rawUrl}${rawUrl.includes('?') ? '&' : '?'}download=true` : '');
  const embedUrl = dbEscapeHtml(`${rawUrl}${viewerPageLinkFragment()}`);
  const diagnosticPayload = viewerBuildDiagnosticPayload(errorMessage);
  const details = dbEscapeHtml(JSON.stringify(diagnosticPayload, null, 2));
  return `
    <section class="viewer-empty-state" role="status">
      <h3>This PDF could not be displayed in interactive mode.</h3>
      <p class="small">You can still read it using fallback rendering, open it externally, or download the original file.</p>
      <div class="viewer-empty-actions">
        <button type="button" onclick="viewerRetryInteractivePdf()">Try interactive rendering again</button>
        <a href="${openUrl}" target="_blank" rel="noopener">Open in system viewer</a>
        <a href="${downloadUrl}" target="_blank" rel="noopener">Download original</a>
        <button type="button" onclick="viewerCopyDiagnosticReport()">Copy diagnostic report</button>
      </div>
      <div class="viewer-fallback-embed">
        <object id="viewer-fallback-object" data="${embedUrl}" type="application/pdf">
          <embed id="viewer-fallback-embed" src="${embedUrl}" type="application/pdf" />
        </object>
        <iframe id="viewer-fallback-iframe" src="${embedUrl}" title="Fallback PDF viewer"></iframe>
      </div>
      <details class="viewer-tech-details">
        <summary>Show technical details</summary>
        <pre>${details}</pre>
      </details>
    </section>
  `;
}

async function viewerRetryInteractivePdf() {
  const payload = viewerState.payload;
  if (!payload || String(payload?.content?.kind || '') !== 'pdf') return;
  await viewerLoadPdfSource(String(payload?.content?.url || ''));
}

function viewerSyncFallbackPdfView() {
  if (viewerState.renderMode !== 'fallback') return;
  const url = viewerCurrentContentUrl(false);
  if (!url) return;
  const target = `${url}${viewerPageLinkFragment()}`;
  const object = document.getElementById('viewer-fallback-object');
  const embed = document.getElementById('viewer-fallback-embed');
  const iframe = document.getElementById('viewer-fallback-iframe');
  if (object) object.setAttribute('data', target);
  if (embed) embed.setAttribute('src', target);
  if (iframe) iframe.setAttribute('src', target);
}

function viewerEscapeAttr(value) {
  return dbEscapeHtml(String(value || ''));
}

function viewerRenderMetadata() {
  const container = document.getElementById('viewer-metadata');
  if (!container) return;
  const payload = viewerState.payload;
  if (!payload || !payload.metadata) {
    container.innerHTML = '<p class="small">No resource loaded.</p>';
    return;
  }
  const meta = payload.metadata;
  const extraction = payload.extraction || {};
  const counts = extraction.counts || {};
  const run = extraction.run || {};
  const pagesGeom = Array.isArray(extraction.pages_with_geometry) ? extraction.pages_with_geometry : [];
  const pagesTables = Array.isArray(extraction.pages_with_tables) ? extraction.pages_with_tables : [];
  const images = Array.isArray(payload.images) ? payload.images : [];
  const pagesImages = new Set(
    images
      .map((img) => Number(img?.page_number))
      .filter((n) => Number.isFinite(n) && n > 0)
      .map((n) => Math.floor(n))
  );
  const sourceUri = String(meta.source_uri || 'n/a');
  const titleCandidates = viewerTitleCandidates(payload);
  const processingState = extraction.error
    ? 'Error'
    : (extraction.available ? (extraction.overlay_ready ? 'Extracted' : 'Imported') : 'Imported');

  const row = (label, value, options = {}) => {
    const text = String(value ?? 'n/a');
    const compactClass = options.compact ? ' compact' : '';
    const encoded = encodeURIComponent(text);
    const copyButton = options.copy
      ? ` <button class="secondary viewer-meta-copy" type="button" data-copy="${encoded}" data-copy-label="${dbEscapeHtml(options.copyLabel || label)}">Copy</button>`
      : '';
    return `
      <div class="viewer-meta-row">
        <span class="viewer-meta-label">${dbEscapeHtml(label)}</span>
        <span class="viewer-meta-value${compactClass}">${dbEscapeHtml(text)}${copyButton}</span>
      </div>
    `;
  };

  const titleCandidatesMarkup = titleCandidates.length
    ? `
      <div class="viewer-title-candidates">
        <div class="viewer-title-candidate-row">
          <select id="viewer-title-candidate-select">
            ${titleCandidates.map((title) => `<option value="${viewerEscapeAttr(title)}">${dbEscapeHtml(title)}</option>`).join('')}
          </select>
          <button class="secondary" type="button" onclick="viewerApplyTitleCandidate()">Apply title</button>
        </div>
      </div>
    `
    : '';

  container.innerHTML = `
    <section class="viewer-meta-block">
      <h4>Document</h4>
      ${row('Title', viewerState.displayTitle || viewerDeriveDisplayTitle(payload), { copy: true, copyLabel: 'Title' })}
      ${titleCandidatesMarkup}
      ${row('Source', viewerState.sourceLabel || viewerDeriveSourceLabel(payload))}
      ${row('Imported', viewerFormatDate(meta.ingested_at))}
      ${row('Type', meta.media_type || payload?.content?.kind || 'unknown')}
    </section>
    <section class="viewer-meta-block">
      <h4>Processing</h4>
      ${row('State', processingState)}
      ${row('Last run', viewerFormatDate(run.created_at || run.started_at || run.completed_at || ''))}
      ${row('Tables', counts.tables ?? 0)}
      ${row('Segments', counts.segments ?? 0)}
      ${row('Annotations', counts.annotations ?? 0)}
      ${row('Images', counts.images ?? images.length)}
      ${row('Pages with tables', pagesTables.length || 0)}
      ${row('Pages with geometry', pagesGeom.length || 0)}
      ${row('Pages with images', pagesImages.size || 0)}
    </section>
    <details class="viewer-tech-details">
      <summary>Technical details</summary>
      <section class="viewer-meta-block">
        ${row('Internal reference', meta.resource_id || '', { compact: true, copy: true, copyLabel: 'Resource ID' })}
        ${row('Digest', meta.digest_sha256 || '', { compact: true, copy: true, copyLabel: 'Digest' })}
        ${row('Source URI', sourceUri, { compact: true, copy: true, copyLabel: 'Source URI' })}
        ${row('Content URL', payload?.content?.url || '', { compact: true, copy: true, copyLabel: 'Content URL' })}
      </section>
    </details>
  `;
  container.querySelectorAll('button[data-copy]').forEach((button) => {
    button.addEventListener('click', async () => {
      const text = decodeURIComponent(button.getAttribute('data-copy') || '');
      const label = button.getAttribute('data-copy-label') || 'Value';
      await viewerCopyField(text, label);
    });
  });
}

function viewerRenderImageGallery() {
  const container = document.getElementById('viewer-image-gallery');
  if (!container) return;
  const images = Array.isArray(viewerState.payload?.images) ? viewerState.payload.images : [];
  if (!images.length) {
    container.innerHTML = '<p class="small">No extracted images available for this document.</p>';
    return;
  }
  const shown = images.slice(0, 200);
  container.innerHTML = shown.map((image, idx) => {
    const imageId = String(image?.id || '');
    const pageNumberRaw = Number(image?.page_number);
    const pageLabel = Number.isFinite(pageNumberRaw) && pageNumberRaw > 0
      ? `Page ${Math.floor(pageNumberRaw)}`
      : 'Page n/a';
    const imageIndexRaw = Number(image?.image_index);
    const imageLabel = Number.isFinite(imageIndexRaw) && imageIndexRaw >= 1
      ? `Image ${Math.floor(imageIndexRaw)}`
      : `Image ${idx + 1}`;
    const src = viewerResolveContentUrl(String(image?.content_url || ''));
    const desc = String(image?.description_text || '').trim();
    const fallbackDesc = desc || 'No generated description available.';
    const sourceW = Number(image?.source_width_px);
    const sourceH = Number(image?.source_height_px);
    const outW = Number(image?.output_width_px);
    const outH = Number(image?.output_height_px);
    const renderedWmm = Number(image?.rendered_width_mm);
    const renderedHmm = Number(image?.rendered_height_mm);
    const sourceDims = Number.isFinite(sourceW) && Number.isFinite(sourceH) && sourceW > 0 && sourceH > 0
      ? `${Math.floor(sourceW)}${Math.floor(sourceH)} px`
      : 'n/a';
    const outputDims = Number.isFinite(outW) && Number.isFinite(outH) && outW > 0 && outH > 0
      ? `${Math.floor(outW)}${Math.floor(outH)} px`
      : 'n/a';
    const renderedMm = Number.isFinite(renderedWmm) && Number.isFinite(renderedHmm) && renderedWmm > 0 && renderedHmm > 0
      ? `${renderedWmm.toFixed(1)}${renderedHmm.toFixed(1)} mm`
      : 'n/a';
    const descriptionModel = String(image?.description_model || '').trim();
    const active = imageId && imageId === viewerState.selectedImageId && viewerState.selectedKind === 'image'
      ? ' active'
      : '';
    const openLink = src
      ? `<a class="small" data-viewer-image-open href="${dbEscapeHtml(src)}" target="_blank" rel="noopener">Open image</a>`
      : '';
    return `
      <article class="viewer-image-card${active}" data-viewer-image-id="${dbEscapeHtml(imageId)}">
        <div class="viewer-image-card-head">
          <h5>${dbEscapeHtml(`${imageLabel}  ${pageLabel}`)}</h5>
          ${openLink}
        </div>
        ${src ? `<img class="viewer-image-thumb" src="${dbEscapeHtml(src)}" loading="lazy" alt="${dbEscapeHtml(`${imageLabel} ${pageLabel}`)}" />` : ''}
        <p>${dbEscapeHtml(fallbackDesc)}</p>
        <p>Original: ${dbEscapeHtml(sourceDims)}  Stored: ${dbEscapeHtml(outputDims)}  Rendered: ${dbEscapeHtml(renderedMm)}</p>
        ${descriptionModel ? `<p class="small">Description model: ${dbEscapeHtml(descriptionModel)}</p>` : ''}
      </article>
    `;
  }).join('');
  container.querySelectorAll('[data-viewer-image-id]').forEach((node) => {
    node.addEventListener('click', () => {
      viewerSelectImage(node.getAttribute('data-viewer-image-id') || '', { jumpPage: true });
    });
  });
  container.querySelectorAll('[data-viewer-image-open]').forEach((node) => {
    node.addEventListener('click', (event) => {
      event.stopPropagation();
    });
  });
  if (images.length > shown.length) {
    container.insertAdjacentHTML(
      'beforeend',
      `<p class="small">Showing ${shown.length} of ${images.length} extracted images.</p>`
    );
  }
}

function viewerRenderAnnotations() {
  const container = document.getElementById('viewer-annotation-list');
  if (!container) return;
  const payload = viewerState.payload;
  const annotations = Array.isArray(payload?.annotations) ? payload.annotations : [];
  if (!annotations.length) {
    container.innerHTML = '<p class="small">No annotations available.</p>';
    return;
  }
  const shown = annotations.slice(0, 220);
  container.innerHTML = shown.map((annotation) => {
    const spans = Array.isArray(annotation.spans) ? annotation.spans : [];
    const spanText = spans.length
      ? spans.slice(0, 3).map((s) => `${s.start}-${s.end}`).join(', ')
      : 'no spans';
    const active = annotation.id === viewerState.selectedAnnotationId && viewerState.selectedKind === 'annotation'
      ? ' active'
      : '';
    return `
      <article class="viewer-annotation-item${active}" data-viewer-annotation-id="${dbEscapeHtml(String(annotation.id || ''))}">
        <h4>${dbEscapeHtml(String(annotation.category || 'annotation'))} <span class="small">(${dbEscapeHtml(String(annotation.layer || 'layer'))})</span></h4>
        <p>${dbEscapeHtml(String(annotation.label || annotation.source || ''))}</p>
        <p>${dbEscapeHtml(String(annotation.snippet || ''))}</p>
        <p>spans: ${dbEscapeHtml(spanText)}</p>
      </article>
    `;
  }).join('');
  container.querySelectorAll('[data-viewer-annotation-id]').forEach((node) => {
    node.addEventListener('click', () => {
      viewerSelectAnnotation(node.getAttribute('data-viewer-annotation-id') || '', { jumpPage: true, source: 'inspector' });
    });
  });
}

function viewerTableShape(table) {
  const cells = Array.isArray(table?.cells) ? table.cells : [];
  let rows = Array.isArray(table?.row_headers) ? table.row_headers.length : 0;
  let cols = Array.isArray(table?.col_headers) ? table.col_headers.length : 0;
  cells.forEach((cell) => {
    const r = Number(cell?.row_index);
    const c = Number(cell?.col_index);
    if (Number.isFinite(r)) rows = Math.max(rows, Math.floor(r) + 1);
    if (Number.isFinite(c)) cols = Math.max(cols, Math.floor(c) + 1);
  });
  rows = Math.max(0, rows);
  cols = Math.max(0, cols);
  return { rows, cols };
}

function viewerEstimateCellBox(table, rowIndex, colIndex) {
  const bbox = viewerExtractBBox(table?.bbox);
  if (!bbox) return null;
  const shape = viewerTableShape(table);
  if (shape.rows <= 0 || shape.cols <= 0) return null;
  const row = Math.max(0, Math.min(shape.rows - 1, Number(rowIndex)));
  const col = Math.max(0, Math.min(shape.cols - 1, Number(colIndex)));
  const width = (bbox.x1 - bbox.x0) / shape.cols;
  const height = (bbox.y1 - bbox.y0) / shape.rows;
  return {
    x0: bbox.x0 + (col * width),
    y0: bbox.y0 + (row * height),
    x1: bbox.x0 + ((col + 1) * width),
    y1: bbox.y0 + ((row + 1) * height),
  };
}

function viewerTableCellMap(table) {
  const cellMap = new Map();
  (Array.isArray(table.cells) ? table.cells : []).forEach((cell) => {
    const r = Number(cell?.row_index);
    const c = Number(cell?.col_index);
    if (!Number.isFinite(r) || !Number.isFinite(c)) return;
    cellMap.set(`${Math.floor(r)}:${Math.floor(c)}`, String(cell?.value || ''));
  });
  return cellMap;
}

function viewerBuildTableMarkup(table, options = {}) {
  const { rows, cols } = viewerTableShape(table);
  const cellMap = viewerTableCellMap(table);
  const rowHeaders = Array.isArray(table.row_headers) ? table.row_headers : [];
  const colHeaders = Array.isArray(table.col_headers) ? table.col_headers : [];
  const activeRow = Number.isFinite(options.activeRow) ? Number(options.activeRow) : null;
  const activeCol = Number.isFinite(options.activeCol) ? Number(options.activeCol) : null;

  const maxRows = Number.isFinite(options.maxRows) ? Math.max(1, Math.floor(Number(options.maxRows))) : rows;
  const maxCols = Number.isFinite(options.maxCols) ? Math.max(1, Math.floor(Number(options.maxCols))) : cols;
  const renderRows = Math.max(0, Math.min(rows, maxRows));
  const renderCols = Math.max(0, Math.min(cols, maxCols));

  let headerHtml = '<th>#</th>';
  for (let c = 0; c < renderCols; c += 1) {
    const label = colHeaders[c] || `C${c + 1}`;
    const colClass = activeCol === c ? ' class="viewer-col-header-active"' : '';
    headerHtml += `<th${colClass}>${dbEscapeHtml(label)}</th>`;
  }
  if (renderCols < cols) headerHtml += '<th></th>';

  let bodyHtml = '';
  for (let r = 0; r < renderRows; r += 1) {
    const rowHeaderClass = activeRow === r ? ' class="viewer-row-header-active"' : '';
    let row = `<tr><th${rowHeaderClass}>${dbEscapeHtml(rowHeaders[r] || `R${r + 1}`)}</th>`;
    for (let c = 0; c < renderCols; c += 1) {
      const key = `${r}:${c}`;
      const value = cellMap.get(key) || '';
      const classes = [];
      if (activeRow === r) classes.push('viewer-cell-row-active');
      if (activeCol === c) classes.push('viewer-cell-col-active');
      if (activeRow === r && activeCol === c) classes.push('viewer-cell-active');
      const activeClass = classes.length ? ` class="${classes.join(' ')}"` : '';
      const editable = options.editable ? ' contenteditable="true" data-viewer-edit-cell="1"' : '';
      row += `<td${activeClass}${editable}>${dbEscapeHtml(value)}</td>`;
    }
    if (renderCols < cols) row += '<td></td>';
    row += '</tr>';
    bodyHtml += row;
  }
  if (renderRows < rows) {
    bodyHtml += `<tr><td colspan="${Math.max(2, renderCols + 2)}"> ${dbEscapeHtml(String(rows - renderRows))} more row(s)</td></tr>`;
  }

  return `
    <table class="viewer-table${options.preview ? ' viewer-table-preview' : ''}">
      <thead><tr>${headerHtml}</tr></thead>
      <tbody>${bodyHtml || '<tr><td colspan="99">No cells extracted.</td></tr>'}</tbody>
    </table>
  `;
}

function viewerRenderTableGrid() {
  const container = document.getElementById('viewer-table-grid');
  if (!container) return;
  const table = viewerCurrentTable();
  if (!table) {
    container.innerHTML = '<p class="small">No table selected.</p>';
    return;
  }
  container.innerHTML = viewerBuildTableMarkup(table, {
    activeRow: viewerState.selectedCellRow,
    activeCol: viewerState.selectedCellCol,
    editable: viewerState.tableEditMode,
  });
  const editBtn = document.getElementById('viewer-edit-table-btn');
  if (editBtn) editBtn.textContent = viewerState.tableEditMode ? 'Disable Edit' : 'Enable Edit';
}

function viewerRenderSelectionSummary() {
  const summaryEl = document.getElementById('viewer-selection-summary');
  const reviewStatus = document.getElementById('viewer-review-status');
  const actionRow = document.getElementById('viewer-table-actions');
  if (!summaryEl) return;

  const table = viewerCurrentTable();
  const image = viewerCurrentImage();
  const segment = viewerCurrentSegment();
  const annotation = viewerCurrentAnnotation();
  let summary = 'Select an extracted item from the left index or click a highlighted region in the PDF.';
  let rawPayload = null;

  if (table && viewerState.selectedKind === 'table') {
    const page = Number.isFinite(Number(table?.page_number)) ? `Page ${table.page_number}` : 'Page n/a';
    const shape = viewerTableShape(table);
    summary = `Selected table: ${viewerTableTitle(table)} (${page}, ${shape.rows} rows, ${shape.cols} cols).`;
    rawPayload = table;
    if (actionRow) actionRow.hidden = false;
    if (reviewStatus) {
      const key = viewerSelectionKey('table', table.id);
      const mark = viewerState.reviewByKey[key];
      reviewStatus.textContent = mark ? `Status: ${mark.replace('_', ' ')}` : '';
    }
  } else if (image && viewerState.selectedKind === 'image') {
    const page = Number.isFinite(Number(image?.page_number)) ? `Page ${image.page_number}` : 'Page n/a';
    const idx = Number.isFinite(Number(image?.image_index)) ? `Image ${image.image_index}` : 'Image';
    const description = String(image?.description_text || '').trim();
    summary = `Selected ${idx}: ${page}${description ? `  ${description}` : ''}`;
    rawPayload = image;
    if (actionRow) actionRow.hidden = true;
    if (reviewStatus) reviewStatus.textContent = '';
  } else if (annotation && viewerState.selectedKind === 'annotation') {
    const spans = Array.isArray(annotation.spans) ? annotation.spans : [];
    const spanText = spans.length ? spans.slice(0, 2).map((s) => `${s.start}-${s.end}`).join(', ') : 'none';
    summary = `Selected annotation: ${annotation.category || 'annotation'}  ${annotation.label || annotation.source || 'unlabeled'}  spans ${spanText}.`;
    rawPayload = annotation;
    if (actionRow) actionRow.hidden = true;
    if (reviewStatus) reviewStatus.textContent = '';
  } else if (segment && viewerState.selectedKind === 'segment') {
    const resolvedPage = viewerResolvedSegmentPageNumber(segment);
    const page = Number.isFinite(Number(resolvedPage)) ? `Page ${resolvedPage}` : 'Page n/a';
    summary = `Selected segment: ${segment.segment_type || 'segment'} (${page}, ${segment.start_offset || 0}-${segment.end_offset || 0}).`;
    rawPayload = segment;
    if (actionRow) actionRow.hidden = true;
    if (reviewStatus) reviewStatus.textContent = '';
  } else {
    if (actionRow) actionRow.hidden = true;
    if (reviewStatus) reviewStatus.textContent = '';
  }

  summaryEl.textContent = summary;
  viewerSetSelectionRaw(rawPayload);
}

function viewerRenderExtractionIndex() {
  const tableList = document.getElementById('viewer-index-table-list');
  const segmentList = document.getElementById('viewer-index-segment-list');
  const annotationList = document.getElementById('viewer-index-annotation-list');
  const pageLabel = document.getElementById('viewer-index-table-page');
  const prevBtn = document.getElementById('viewer-index-table-prev');
  const nextBtn = document.getElementById('viewer-index-table-next');
  if (!tableList || !segmentList || !annotationList || !pageLabel || !prevBtn || !nextBtn) return;

  const payload = viewerState.payload;
  if (!payload) {
    tableList.innerHTML = '<p class="small">No tables loaded.</p>';
    segmentList.innerHTML = '<p class="small">No segments loaded.</p>';
    annotationList.innerHTML = '<p class="small">No annotations loaded.</p>';
    pageLabel.textContent = 'Page 1 / 1';
    prevBtn.disabled = true;
    nextBtn.disabled = true;
    return;
  }

  const kindFilter = String(viewerState.indexFilterType || 'all');
  const tables = Array.isArray(payload.tables) ? payload.tables : [];
  const segments = Array.isArray(payload.segments) ? payload.segments : [];
  const annotations = Array.isArray(payload.annotations) ? payload.annotations : [];

  const filteredTables = tables.filter((table, idx) => {
    if (kindFilter !== 'all' && kindFilter !== 'tables') return false;
    const page = Number.isFinite(Number(table?.page_number)) ? `page ${table.page_number}` : 'page n/a';
    const haystack = `${viewerTableTitle(table, idx)} ${page} ${table?.table_id || ''}`;
    return viewerMatchesIndexFilter(haystack);
  });
  const totalPages = Math.max(1, Math.ceil(filteredTables.length / viewerState.indexTablePageSize));
  if (viewerState.indexTablePage > totalPages) viewerState.indexTablePage = totalPages;
  if (viewerState.indexTablePage < 1) viewerState.indexTablePage = 1;
  const tableStart = (viewerState.indexTablePage - 1) * viewerState.indexTablePageSize;
  const shownTables = filteredTables.slice(tableStart, tableStart + viewerState.indexTablePageSize);

  if (!shownTables.length) {
    tableList.innerHTML = '<p class="small">No tables match current filters.</p>';
  } else {
    tableList.innerHTML = shownTables.map((table, idx) => {
      const page = Number.isFinite(Number(table?.page_number)) ? table.page_number : 'n/a';
      const localIndex = tableStart + idx;
      const active = table.id && table.id === viewerState.selectedTableId && viewerState.selectedKind === 'table'
        ? ' active'
        : '';
      return `
        <article class="viewer-index-item${active}" data-viewer-index-table="${dbEscapeHtml(String(table.id || ''))}">
          <h5>${dbEscapeHtml(viewerTableTitle(table, localIndex))}</h5>
          <p>Page ${dbEscapeHtml(String(page))}</p>
        </article>
      `;
    }).join('');
    tableList.querySelectorAll('[data-viewer-index-table]').forEach((node) => {
      node.addEventListener('click', () => {
        viewerSelectTable(node.getAttribute('data-viewer-index-table') || '', { jumpPage: true, source: 'index' });
      });
    });
  }

  pageLabel.textContent = `Page ${viewerState.indexTablePage} / ${totalPages}`;
  prevBtn.disabled = viewerState.indexTablePage <= 1;
  nextBtn.disabled = viewerState.indexTablePage >= totalPages;

  const filteredSegments = segments.filter((segment) => {
    if (kindFilter !== 'all' && kindFilter !== 'segments') return false;
    const resolvedPage = viewerResolvedSegmentPageNumber(segment);
    const page = Number.isFinite(Number(resolvedPage)) ? `page ${resolvedPage}` : 'page n/a';
    const haystack = `${segment?.segment_type || ''} ${page} ${segment?.start_offset || 0} ${segment?.end_offset || 0}`;
    return viewerMatchesIndexFilter(haystack);
  });
  filteredSegments.sort((a, b) => {
    const pageA = viewerResolvedSegmentPageNumber(a);
    const pageB = viewerResolvedSegmentPageNumber(b);
    const safePageA = Number.isFinite(Number(pageA)) ? Number(pageA) : Number.POSITIVE_INFINITY;
    const safePageB = Number.isFinite(Number(pageB)) ? Number(pageB) : Number.POSITIVE_INFINITY;
    if (safePageA !== safePageB) return safePageA - safePageB;
    const startA = Number(a?.start_offset);
    const startB = Number(b?.start_offset);
    const safeStartA = Number.isFinite(startA) ? startA : Number.POSITIVE_INFINITY;
    const safeStartB = Number.isFinite(startB) ? startB : Number.POSITIVE_INFINITY;
    if (safeStartA !== safeStartB) return safeStartA - safeStartB;
    return String(a?.id || '').localeCompare(String(b?.id || ''));
  });
  const shownSegments = filteredSegments.slice(0, 140);
  if (!shownSegments.length) {
    segmentList.innerHTML = '<p class="small">No segments match current filters.</p>';
  } else {
    segmentList.innerHTML = shownSegments.map((segment) => {
      const active = segment.id && segment.id === viewerState.selectedSegmentId && viewerState.selectedKind === 'segment'
        ? ' active'
        : '';
      return `
        <article class="viewer-index-item${active}" data-viewer-index-segment="${dbEscapeHtml(String(segment.id || ''))}">
          <h5>${dbEscapeHtml(String(segment.segment_type || 'segment'))}</h5>
          <p>Page ${dbEscapeHtml(String(viewerResolvedSegmentPageNumber(segment) || 'n/a'))}  ${dbEscapeHtml(String(segment.start_offset || 0))}-${dbEscapeHtml(String(segment.end_offset || 0))}</p>
        </article>
      `;
    }).join('');
    segmentList.querySelectorAll('[data-viewer-index-segment]').forEach((node) => {
      node.addEventListener('click', () => {
        viewerSelectSegment(node.getAttribute('data-viewer-index-segment') || '', { jumpPage: true, source: 'index' });
      });
    });
    if (filteredSegments.length > shownSegments.length) {
      segmentList.insertAdjacentHTML('beforeend', `<p class="small">Showing ${shownSegments.length} of ${filteredSegments.length} segments.</p>`);
    }
  }

  const filteredAnnotations = annotations.filter((annotation) => {
    if (kindFilter !== 'all' && kindFilter !== 'annotations') return false;
    const spans = Array.isArray(annotation?.spans) ? annotation.spans : [];
    const spanText = spans.length ? spans.slice(0, 2).map((s) => `${s.start}-${s.end}`).join(' ') : '';
    const haystack = `${annotation?.category || ''} ${annotation?.label || annotation?.source || ''} ${spanText}`;
    return viewerMatchesIndexFilter(haystack);
  });
  const shownAnnotations = filteredAnnotations.slice(0, 140);
  if (!shownAnnotations.length) {
    annotationList.innerHTML = '<p class="small">No annotations match current filters.</p>';
  } else {
    annotationList.innerHTML = shownAnnotations.map((annotation) => {
      const active = annotation.id && annotation.id === viewerState.selectedAnnotationId && viewerState.selectedKind === 'annotation'
        ? ' active'
        : '';
      const label = annotation?.label || annotation?.source || 'unlabeled';
      return `
        <article class="viewer-index-item${active}" data-viewer-index-annotation="${dbEscapeHtml(String(annotation.id || ''))}">
          <h5>${dbEscapeHtml(String(annotation.category || 'annotation'))}</h5>
          <p>${dbEscapeHtml(String(label))}</p>
        </article>
      `;
    }).join('');
    annotationList.querySelectorAll('[data-viewer-index-annotation]').forEach((node) => {
      node.addEventListener('click', () => {
        viewerSelectAnnotation(node.getAttribute('data-viewer-index-annotation') || '', { jumpPage: true, source: 'index' });
      });
    });
    if (filteredAnnotations.length > shownAnnotations.length) {
      annotationList.insertAdjacentHTML('beforeend', `<p class="small">Showing ${shownAnnotations.length} of ${filteredAnnotations.length} annotations.</p>`);
    }
  }
}

function viewerRenderStructuredData() {
  viewerRenderExtractionIndex();
  viewerRenderImageGallery();
  viewerRenderSelectionSummary();
  viewerUpdateStructuredSelection();
}

function viewerFocusCell() {
  const table = viewerCurrentTable();
  if (!table) {
    const status = document.getElementById('viewer-cell-status');
    if (status) status.textContent = 'Select a table first.';
    return;
  }
  const rowInput = document.getElementById('viewer-cell-row');
  const colInput = document.getElementById('viewer-cell-col');
  const r = Number((rowInput?.value || '').trim());
  const c = Number((colInput?.value || '').trim());
  if (!Number.isFinite(r) || !Number.isFinite(c) || r < 1 || c < 1) {
    const status = document.getElementById('viewer-cell-status');
    if (status) status.textContent = 'Provide valid 1-based row and column numbers.';
    return;
  }
  viewerState.selectedCellRow = Math.floor(r) - 1;
  viewerState.selectedCellCol = Math.floor(c) - 1;
  viewerRenderTableGrid();
  const status = document.getElementById('viewer-cell-status');
  const { rows, cols } = viewerTableShape(table);
  const cell = (Array.isArray(table.cells) ? table.cells : []).find(
    (x) => Number(x?.row_index) === viewerState.selectedCellRow && Number(x?.col_index) === viewerState.selectedCellCol
  );
  const value = cell ? String(cell.value || '') : '(empty)';
  const approxBox = viewerEstimateCellBox(table, viewerState.selectedCellRow, viewerState.selectedCellCol);
  const coordText = approxBox
    ? `  bbox approx (${approxBox.x0.toFixed(2)}, ${approxBox.y0.toFixed(2)}, ${approxBox.x1.toFixed(2)}, ${approxBox.y1.toFixed(2)})`
    : '';
  const cellInfo = `Table ${table.table_id || table.id || ''}  page ${Number.isFinite(Number(table.page_number)) ? table.page_number : 'n/a'}  row ${viewerState.selectedCellRow + 1}/${rows || '?'}  col ${viewerState.selectedCellCol + 1}/${cols || '?'}  value: ${value}${coordText}`;
  if (status) status.textContent = cellInfo;
}

function viewerOpenOverlayTable(tableId) {
  viewerSelectTable(tableId, { jumpPage: true, source: 'overlay-list' });
}

function viewerSelectImage(imageId, options = {}) {
  const { jumpPage = true } = options;
  viewerState.selectedKind = 'image';
  viewerState.selectedImageId = String(imageId || '');
  viewerState.selectedTableId = '';
  viewerState.selectedSegmentId = '';
  viewerState.selectedAnnotationId = '';
  viewerState.selectedCellRow = null;
  viewerState.selectedCellCol = null;
  viewerState.tableEditMode = false;
  const image = viewerCurrentImage();
  const currentPage = viewerState.page;
  const pageNumber = Number(image?.page_number);
  const targetPage = jumpPage && Number.isFinite(pageNumber) && pageNumber > 0
    ? Math.floor(pageNumber)
    : null;
  const didPageChange = jumpPage && targetPage !== null && targetPage !== currentPage;
  if (jumpPage && targetPage !== null) {
    viewerState.page = targetPage;
    if (didPageChange) viewerResetPdfScrollPosition();
  }
  viewerToggleInspector(true);
  viewerRenderStructuredData();
  viewerRenderOverlayList();
  viewerRenderTableGrid();
  viewerRenderAnnotations();
  viewerRenderOverlay();
  if (jumpPage && didPageChange) {
    if (viewerState.pdfDoc) viewerRenderCurrentPdfPage();
    else viewerSyncFallbackPdfView();
  }
  const statusNote = Number.isFinite(pageNumber) && pageNumber > 0
    ? `Selected extracted image on page ${Math.floor(pageNumber)}.`
    : 'Selected extracted image.';
  viewerSetStatus(statusNote);
}

function viewerSelectTable(tableId, options = {}) {
  const { jumpPage = true } = options;
  viewerState.selectedKind = 'table';
  viewerState.selectedImageId = '';
  viewerState.selectedTableId = String(tableId || '');
  viewerState.selectedSegmentId = '';
  viewerState.selectedAnnotationId = '';
  viewerState.selectedCellRow = null;
  viewerState.selectedCellCol = null;
  viewerState.tableEditMode = false;
  const table = viewerCurrentTable();
  const currentPage = viewerState.page;
  const targetPage = jumpPage ? viewerEntityPageNumber(table) : null;
  const didPageChange = jumpPage && targetPage !== null && targetPage !== currentPage;
  if (jumpPage && targetPage !== null) {
    viewerState.page = targetPage;
    if (didPageChange) viewerResetPdfScrollPosition();
  }
  viewerSetInspectorTab('tables');
  viewerToggleInspector(true);
  viewerRenderStructuredData();
  viewerRenderOverlayList();
  viewerRenderTableGrid();
  viewerRenderAnnotations();
  viewerRenderOverlay();
  if (jumpPage && didPageChange) {
    if (viewerState.pdfDoc) viewerRenderCurrentPdfPage();
    else viewerSyncFallbackPdfView();
  }
}

function viewerSelectSegment(segmentId, options = {}) {
  const { jumpPage = true } = options;
  const selectedId = String(segmentId || '');
  viewerState.selectedKind = 'segment';
  viewerState.selectedImageId = '';
  viewerState.selectedSegmentId = selectedId;
  viewerState.selectedTableId = '';
  viewerState.selectedAnnotationId = '';
  viewerState.selectedCellRow = null;
  viewerState.selectedCellCol = null;
  viewerState.tableEditMode = false;
  const segment = viewerCurrentSegment();
  const currentPage = viewerState.page;
  const targetPage = jumpPage ? viewerResolvedSegmentPageNumber(segment) : null;
  const didPageChange = jumpPage && targetPage !== null && targetPage !== currentPage;
  if (jumpPage && targetPage !== null) {
    viewerState.page = targetPage;
    if (didPageChange) viewerResetPdfScrollPosition();
  }
  if (segment && jumpPage) {
    if (targetPage === null) {
      viewerSetStatus('Selected segment has no resolved page metadata, so navigation is unavailable.');
    } else if (!segment.bbox) {
      viewerSetStatus(`Selected segment on page ${targetPage}. Highlight uses inferred text-flow coordinates.`);
    }
  }
  viewerSetInspectorTab('overlays');
  viewerToggleInspector(true);
  viewerRenderStructuredData();
  viewerRenderOverlayList();
  viewerRenderTableGrid();
  viewerRenderAnnotations();
  viewerRenderOverlay();
  if (jumpPage && didPageChange) {
    if (viewerState.pdfDoc) viewerRenderCurrentPdfPage();
    else viewerSyncFallbackPdfView();
  }
  if (jumpPage && targetPage === null && viewerState.pdfDoc && viewerState.contentKind === 'pdf') {
    viewerSetStatus('Resolving selected segment page from PDF text layout...');
    viewerEnsureSyntheticPageOffsetRanges().then(() => {
      if (viewerState.selectedSegmentId !== selectedId) return;
      const activeSegment = viewerCurrentSegment();
      const resolved = viewerResolvedSegmentPageNumber(activeSegment);
      if (resolved === null) {
        viewerSetStatus('Selected segment still has no resolved page metadata.');
        viewerRenderStructuredData();
        viewerRenderOverlayList();
        viewerRenderOverlay();
        return;
      }
      const current = viewerState.page;
      viewerState.page = resolved;
      const changed = viewerState.page !== current;
      if (changed) viewerResetPdfScrollPosition();
      viewerSetStatus(!activeSegment?.bbox
        ? `Selected segment on page ${resolved}. Highlight uses inferred text-flow coordinates.`
        : `Selected segment on page ${resolved}.`);
      viewerRenderStructuredData();
      viewerRenderOverlayList();
      viewerRenderOverlay();
      if (changed) viewerRenderCurrentPdfPage();
    });
  }
}

function viewerFindSegmentForAnnotation(annotation) {
  if (!annotation) return null;
  const spans = Array.isArray(annotation.spans) ? annotation.spans : [];
  if (!spans.length) return null;
  const segments = Array.isArray(viewerState.payload?.segments) ? viewerState.payload.segments : [];
  for (const span of spans) {
    const start = Number(span?.start);
    const end = Number(span?.end);
    if (!Number.isFinite(start) || !Number.isFinite(end)) continue;
    const match = segments.find((segment) => {
      const segStart = Number(segment?.start_offset);
      const segEnd = Number(segment?.end_offset);
      if (!Number.isFinite(segStart) || !Number.isFinite(segEnd)) return false;
      return segEnd > start && segStart < end;
    });
    if (match) return match;
  }
  return null;
}

function viewerSelectAnnotation(annotationId, options = {}) {
  const { jumpPage = true } = options;
  viewerState.selectedKind = 'annotation';
  viewerState.selectedImageId = '';
  viewerState.selectedAnnotationId = String(annotationId || '');
  viewerState.selectedTableId = '';
  viewerState.selectedCellRow = null;
  viewerState.selectedCellCol = null;
  viewerState.tableEditMode = false;
  const annotation = viewerCurrentAnnotation();
  const linkedSegment = viewerFindSegmentForAnnotation(annotation);
  viewerState.selectedSegmentId = linkedSegment?.id || '';
  let didPageChange = false;
  if (jumpPage && linkedSegment) {
    const currentPage = viewerState.page;
    const targetPage = viewerResolvedSegmentPageNumber(linkedSegment);
    if (targetPage !== null) {
      viewerState.page = targetPage;
      didPageChange = viewerState.page !== currentPage;
      if (didPageChange) viewerResetPdfScrollPosition();
    }
  }
  viewerSetInspectorTab('annotations');
  viewerToggleInspector(true);
  viewerRenderStructuredData();
  viewerRenderOverlayList();
  viewerRenderTableGrid();
  viewerRenderAnnotations();
  viewerRenderOverlay();
  if (jumpPage && didPageChange) {
    if (viewerState.pdfDoc) viewerRenderCurrentPdfPage();
    else viewerSyncFallbackPdfView();
  }
}

function viewerMarkSelection(mark) {
  const table = viewerCurrentTable();
  if (!table || viewerState.selectedKind !== 'table') {
    viewerSetStatus('Select a table before setting review status.');
    return;
  }
  const key = viewerSelectionKey('table', table.id);
  if (!key) return;
  viewerState.reviewByKey[key] = String(mark || 'unreviewed');
  viewerRenderSelectionSummary();
  viewerFlashToast(`Table marked: ${String(mark || 'unreviewed').replace('_', ' ')}`);
}

function viewerToggleTableEditMode() {
  const table = viewerCurrentTable();
  if (!table || viewerState.selectedKind !== 'table') {
    viewerSetStatus('Select a table before editing.');
    return;
  }
  viewerState.tableEditMode = !viewerState.tableEditMode;
  viewerRenderTableGrid();
  viewerSetStatus(viewerState.tableEditMode
    ? 'Table edit mode enabled (local only).'
    : 'Table edit mode disabled.');
}

function viewerInitIndexControls() {
  const search = document.getElementById('viewer-index-search');
  const kind = document.getElementById('viewer-index-type');
  const prev = document.getElementById('viewer-index-table-prev');
  const next = document.getElementById('viewer-index-table-next');

  if (search) {
    search.addEventListener('input', () => {
      viewerState.indexFilterText = String(search.value || '').trim();
      viewerState.indexTablePage = 1;
      viewerRenderExtractionIndex();
    });
  }
  if (kind) {
    kind.addEventListener('change', () => {
      viewerState.indexFilterType = String(kind.value || 'all');
      viewerState.indexTablePage = 1;
      viewerRenderExtractionIndex();
    });
  }
  if (prev) {
    prev.addEventListener('click', () => {
      viewerState.indexTablePage = Math.max(1, viewerState.indexTablePage - 1);
      viewerRenderExtractionIndex();
    });
  }
  if (next) {
    next.addEventListener('click', () => {
      viewerState.indexTablePage += 1;
      viewerRenderExtractionIndex();
    });
  }
}

function viewerRenderOverlayList() {
  const container = document.getElementById('viewer-overlay-list');
  if (!container) return;
  const payload = viewerState.payload;
  const pageIndex = viewerState.page - 1;
  const tables = Array.isArray(payload?.tables) ? payload.tables : [];
  const segments = Array.isArray(payload?.segments) ? payload.segments : [];

  const tablesHere = tables.filter((table) => (
    table && (
      viewerToPageIndex(table.page_index) === null
      || viewerToPageIndex(table.page_index) === pageIndex
      || viewerState.contentKind !== 'pdf'
    )
  ));
  const segmentsHere = segments.filter((segment) => (
    segment && (
      viewerResolvedSegmentPageIndex(segment) === null
      || viewerResolvedSegmentPageIndex(segment) === pageIndex
      || viewerState.contentKind !== 'pdf'
    )
  ));

  if (!tablesHere.length && !segmentsHere.length) {
    container.innerHTML = '<p class="small">No overlay objects for this page.</p>';
    return;
  }

  const tableHtml = tablesHere.slice(0, 200).map((table) => {
    const active = table.id === viewerState.selectedTableId ? 'active' : '';
    const bbox = table?.bbox ? 'bbox' : 'no bbox';
    const rows = Array.isArray(table.row_headers) ? table.row_headers.length : 0;
    const cols = Array.isArray(table.col_headers) ? table.col_headers.length : 0;
    return `
      <article class="viewer-overlay-item ${active}" data-viewer-table-id="${dbEscapeHtml(String(table.id || ''))}">
        <h4>Table ${dbEscapeHtml(String(table.page_number || 'n/a'))}  ${dbEscapeHtml(String(table.caption || table.table_id || 'table'))}</h4>
        <p>${dbEscapeHtml(rows)} rows  ${dbEscapeHtml(cols)} cols  ${dbEscapeHtml(bbox)}</p>
      </article>
    `;
  }).join('');

  const segmentHtml = segmentsHere.slice(0, 220).map((segment) => {
    const active = segment.id === viewerState.selectedSegmentId && viewerState.selectedKind === 'segment' ? 'active' : '';
    return `
      <article class="viewer-overlay-item ${active}" data-viewer-segment-id="${dbEscapeHtml(String(segment.id || ''))}">
        <h4>${dbEscapeHtml(String(segment.segment_type || 'segment'))}</h4>
        <p>page ${dbEscapeHtml(String(viewerResolvedSegmentPageNumber(segment) || 'n/a'))}  ${dbEscapeHtml(String(segment.start_offset || 0))}-${dbEscapeHtml(String(segment.end_offset || 0))}  bbox ${segment?.bbox ? 'yes' : 'no'}</p>
      </article>
    `;
  }).join('');

  container.innerHTML = `${tableHtml}${segmentHtml}`;
  container.querySelectorAll('[data-viewer-table-id]').forEach((node) => {
    node.addEventListener('click', () => {
      viewerOpenOverlayTable(node.getAttribute('data-viewer-table-id') || '');
    });
  });
  container.querySelectorAll('[data-viewer-segment-id]').forEach((node) => {
    node.addEventListener('click', () => {
      viewerSelectSegment(node.getAttribute('data-viewer-segment-id') || '', { jumpPage: true, source: 'overlay-list' });
    });
  });
}

function viewerExtractBBox(bbox) {
  if (!bbox || typeof bbox !== 'object') return null;
  const obj = bbox;
  const pick = (...keys) => {
    for (const key of keys) {
      const value = obj[key];
      const n = Number(value);
      if (Number.isFinite(n)) return n;
    }
    return null;
  };
  let x0 = pick('x0', 'left', 'l', 'x_min', 'min_x', 'x');
  let y0 = pick('y0', 'top', 't', 'y_min', 'min_y', 'y');
  let x1 = pick('x1', 'right', 'r', 'x_max', 'max_x');
  let y1 = pick('y1', 'bottom', 'b', 'y_max', 'max_y');
  if ((x0 === null || y0 === null || x1 === null || y1 === null) && Array.isArray(obj.points) && obj.points.length >= 4) {
    const values = obj.points.map((v) => Number(v));
    if (values.every((v) => Number.isFinite(v))) {
      [x0, y0, x1, y1] = values;
    }
  }
  if (x0 === null || y0 === null || x1 === null || y1 === null) return null;
  if (x1 < x0) [x0, x1] = [x1, x0];
  if (y1 < y0) [y0, y1] = [y1, y0];
  return { x0, y0, x1, y1 };
}

function viewerBBoxUsesBottomLeft(bbox) {
  if (!bbox || typeof bbox !== 'object') return false;
  const originRaw = bbox.coord_origin || bbox.coordinate_origin || bbox.origin || bbox.y_axis_origin;
  const origin = String(originRaw || '').trim().toLowerCase().replace(/[^a-z]/g, '');
  if (!origin) return false;
  return origin.includes('bottomleft') || origin.includes('bottomorigin') || origin.includes('pdf');
}

function viewerRectForCanvas(bbox, canvasWidth, canvasHeight) {
  const b = viewerExtractBBox(bbox);
  if (!b) return null;
  const maxValue = Math.max(Math.abs(b.x0), Math.abs(b.y0), Math.abs(b.x1), Math.abs(b.y1));
  const isNormalized = maxValue <= 1.5;
  const baseW = viewerState.pageBaseWidth || canvasWidth || 1;
  const baseH = viewerState.pageBaseHeight || canvasHeight || 1;

  let x0 = b.x0;
  let y0 = b.y0;
  let x1 = b.x1;
  let y1 = b.y1;
  if (isNormalized) {
    x0 *= canvasWidth;
    x1 *= canvasWidth;
    y0 *= canvasHeight;
    y1 *= canvasHeight;
  } else {
    const scaleX = canvasWidth / baseW;
    const scaleY = canvasHeight / baseH;
    x0 *= scaleX;
    x1 *= scaleX;
    y0 *= scaleY;
    y1 *= scaleY;
  }
  if (viewerBBoxUsesBottomLeft(bbox)) {
    const nextY0 = canvasHeight - y1;
    const nextY1 = canvasHeight - y0;
    y0 = nextY0;
    y1 = nextY1;
  }
  const w = Math.max(1, x1 - x0);
  const h = Math.max(1, y1 - y0);
  return { x: x0, y: y0, w, h };
}

function viewerCollectAnnotationRects(pageIndex) {
  if (!viewerOverlayToggleValue('viewer-toggle-annotations', true)) return [];
  const payload = viewerState.payload;
  const annotations = Array.isArray(payload?.annotations) ? payload.annotations : [];
  const segments = Array.isArray(payload?.segments)
    ? payload.segments.filter((segment) => segment && segment.bbox && viewerResolvedSegmentPageIndex(segment) === pageIndex)
    : [];
  if (!annotations.length || !segments.length) return [];
  const rects = [];
  const maxAnnotations = Math.min(350, annotations.length);
  for (let i = 0; i < maxAnnotations; i += 1) {
    const annotation = annotations[i];
    const spans = Array.isArray(annotation?.spans) ? annotation.spans : [];
    for (const span of spans) {
      const spanStart = Number(span?.start);
      const spanEnd = Number(span?.end);
      if (!Number.isFinite(spanStart) || !Number.isFinite(spanEnd)) continue;
      for (const segment of segments) {
        const segStart = Number(segment?.start_offset);
        const segEnd = Number(segment?.end_offset);
        if (!Number.isFinite(segStart) || !Number.isFinite(segEnd)) continue;
        if (segEnd <= spanStart || segStart >= spanEnd) continue;
        rects.push(segment.bbox);
      }
      if (rects.length > 800) return rects;
    }
  }
  return rects;
}

function viewerEstimateSegmentRect(segment, canvasWidth, canvasHeight) {
  if (!segment) return null;
  const pageIndex = viewerResolvedSegmentPageIndex(segment);
  if (pageIndex === null) return null;
  const segments = Array.isArray(viewerState.payload?.segments) ? viewerState.payload.segments : [];
  const onPage = segments
    .filter((row) => row && viewerResolvedSegmentPageIndex(row) === pageIndex)
    .sort((a, b) => Number(a?.start_offset || 0) - Number(b?.start_offset || 0));
  const total = Math.max(1, onPage.length);
  let ordinal = onPage.findIndex((row) => String(row?.id || '') === String(segment.id || ''));
  if (ordinal < 0) ordinal = 0;
  const marginX = Math.max(10, Math.round(canvasWidth * 0.08));
  const width = Math.max(24, canvasWidth - (marginX * 2));
  const topPad = Math.max(10, Math.round(canvasHeight * 0.06));
  const bottomPad = Math.max(10, Math.round(canvasHeight * 0.06));
  const minBand = 18;
  const maxBand = 42;
  const bandHeight = Math.max(minBand, Math.min(maxBand, Math.round((canvasHeight - topPad - bottomPad) / Math.max(total, 14))));
  const travel = Math.max(0, canvasHeight - topPad - bottomPad - bandHeight);
  const y = topPad + Math.round((ordinal / Math.max(1, total - 1)) * travel);
  return { x: marginX, y, w: width, h: bandHeight };
}

async function viewerEnsurePageTextLayout(pageNumber) {
  if (!viewerState.pdfDoc || !window.pdfjsLib) return null;
  const safePage = Math.max(1, Math.floor(Number(pageNumber) || 1));
  const cacheKey = String(safePage);
  if (viewerState.pageTextLayoutCache[cacheKey]) return viewerState.pageTextLayoutCache[cacheKey];
  if (viewerState.pageTextLayoutPromises[cacheKey]) return viewerState.pageTextLayoutPromises[cacheKey];

  const promise = (async () => {
    const page = await viewerState.pdfDoc.getPage(safePage);
    const viewport = page.getViewport({ scale: 1.0 });
    const content = await page.getTextContent({ disableCombineTextItems: false });
    const items = Array.isArray(content?.items) ? content.items : [];

    let cursor = 0;
    const boxes = [];
    for (const item of items) {
      if (!item || typeof item !== 'object') continue;
      const text = String(item.str || '');
      const chars = Math.max(1, text.length || 0);
      const tx = window.pdfjsLib.Util.transform(viewport.transform, item.transform || [1, 0, 0, 1, 0, 0]);
      const x = Number(tx[4]);
      const baselineY = Number(tx[5]);
      let width = Number(item.width);
      let height = Number(item.height);
      if (!Number.isFinite(width) || width <= 0) width = Math.abs(Number(tx[0]) || 0) * chars;
      if (!Number.isFinite(height) || height <= 0) height = Math.max(8, Math.abs(Number(tx[3]) || 0));
      const x0 = x;
      const x1 = x + Math.max(1, width);
      const y1 = baselineY;
      const y0 = y1 - Math.max(1, height);
      if (![x0, y0, x1, y1].every((value) => Number.isFinite(value))) {
        cursor += chars + 1;
        continue;
      }
      const charStart = cursor;
      const charEnd = cursor + chars;
      cursor = charEnd + 1;
      boxes.push({ x0, y0, x1, y1, charStart, charEnd });
    }
    const layout = {
      boxes,
      totalChars: Math.max(1, cursor),
      pageWidth: viewport.width,
      pageHeight: viewport.height,
    };
    viewerState.pageTextLayoutCache[cacheKey] = layout;
    return layout;
  })();

  viewerState.pageTextLayoutPromises[cacheKey] = promise;
  try {
    return await promise;
  } catch {
    return null;
  } finally {
    delete viewerState.pageTextLayoutPromises[cacheKey];
  }
}

function viewerSegmentEstimatedBBox(segment, pageIndex) {
  if (!segment || typeof segment !== 'object') return null;
  const safePageIndex = Number.isFinite(Number(pageIndex)) ? Math.floor(Number(pageIndex)) : null;
  if (safePageIndex === null || safePageIndex < 0) return null;
  const pageLayout = viewerState.pageTextLayoutCache[String(safePageIndex + 1)];
  if (!pageLayout || !Array.isArray(pageLayout.boxes) || !pageLayout.boxes.length) return null;

  const pageRange = viewerGetPageOffsetRange(safePageIndex);
  if (!pageRange) return null;
  const pageStart = viewerNumericOffset(pageRange.start);
  const pageEnd = viewerNumericOffset(pageRange.end);
  const segStart = viewerNumericOffset(segment.start_offset);
  const segEnd = viewerNumericOffset(segment.end_offset);
  if ([pageStart, pageEnd, segStart, segEnd].some((value) => value === null)) return null;

  const span = Math.max(1, Number(pageEnd) - Number(pageStart));
  const relStart = Math.max(0, Math.min(1, (Math.min(Number(segStart), Number(segEnd)) - Number(pageStart)) / span));
  const relEndRaw = Math.max(0, Math.min(1, (Math.max(Number(segStart), Number(segEnd)) - Number(pageStart)) / span));
  const relEnd = Math.max(relStart + 0.001, relEndRaw);
  const totalChars = Math.max(1, Number(pageLayout.totalChars) || 1);
  const targetStart = relStart * totalChars;
  const targetEnd = Math.max(targetStart + 1, relEnd * totalChars);

  const overlaps = [];
  for (const box of pageLayout.boxes) {
    if (!box || typeof box !== 'object') continue;
    const boxStart = Number(box.charStart);
    const boxEnd = Number(box.charEnd);
    if (!Number.isFinite(boxStart) || !Number.isFinite(boxEnd)) continue;
    if (boxEnd <= targetStart || boxStart >= targetEnd) continue;
    overlaps.push(box);
  }

  const selected = overlaps.length ? overlaps : (() => {
    let best = null;
    let bestDist = Number.POSITIVE_INFINITY;
    for (const box of pageLayout.boxes) {
      if (!box || typeof box !== 'object') continue;
      const center = (Number(box.charStart) + Number(box.charEnd)) / 2;
      if (!Number.isFinite(center)) continue;
      const dist = Math.abs(center - ((targetStart + targetEnd) / 2));
      if (dist < bestDist) {
        bestDist = dist;
        best = box;
      }
    }
    return best ? [best] : [];
  })();

  if (!selected.length) return null;
  let x0 = Number.POSITIVE_INFINITY;
  let y0 = Number.POSITIVE_INFINITY;
  let x1 = Number.NEGATIVE_INFINITY;
  let y1 = Number.NEGATIVE_INFINITY;
  selected.forEach((box) => {
    x0 = Math.min(x0, Number(box.x0));
    y0 = Math.min(y0, Number(box.y0));
    x1 = Math.max(x1, Number(box.x1));
    y1 = Math.max(y1, Number(box.y1));
  });
  if (![x0, y0, x1, y1].every((value) => Number.isFinite(value))) return null;
  if (x1 <= x0 || y1 <= y0) return null;
  return { x0, y0, x1, y1 };
}

function viewerSegmentRectForCanvas(segment, canvasWidth, canvasHeight, pageIndex) {
  if (!segment) return null;
  if (segment.bbox) return viewerRectForCanvas(segment.bbox, canvasWidth, canvasHeight);
  const estimated = viewerSegmentEstimatedBBox(segment, pageIndex);
  if (!estimated) return null;
  return viewerRectForCanvas(estimated, canvasWidth, canvasHeight);
}

function viewerSegmentPalette(segmentType, selected = false) {
  if (selected) {
    return {
      stroke: 'rgba(250,204,21,0.98)',
      fill: 'rgba(250,204,21,0.22)',
      lineWidth: 2.2,
    };
  }
  const kind = String(segmentType || '').toLowerCase();
  if (kind.includes('table')) {
    return { stroke: 'rgba(34,211,238,0.86)', fill: 'rgba(34,211,238,0.10)', lineWidth: 1.0 };
  }
  if (kind.includes('paragraph')) {
    return { stroke: 'rgba(74,222,128,0.78)', fill: 'rgba(74,222,128,0.08)', lineWidth: 1.0 };
  }
  if (kind.includes('sentence')) {
    return { stroke: 'rgba(251,191,36,0.72)', fill: 'rgba(251,191,36,0.06)', lineWidth: 0.9 };
  }
  if (kind.includes('document') || kind.includes('root')) {
    return { stroke: 'rgba(148,163,184,0.66)', fill: 'rgba(148,163,184,0.06)', lineWidth: 1.0 };
  }
  if (kind.includes('heading') || kind.includes('title')) {
    return { stroke: 'rgba(167,139,250,0.78)', fill: 'rgba(167,139,250,0.08)', lineWidth: 1.0 };
  }
  return { stroke: 'rgba(96,165,250,0.70)', fill: 'rgba(96,165,250,0.08)', lineWidth: 1.0 };
}

function viewerHitTestTableAtPoint(x, y, canvasWidth, canvasHeight) {
  const tables = Array.isArray(viewerState.payload?.tables) ? viewerState.payload.tables : [];
  const pageIndex = viewerState.page - 1;
  let best = null;
  let bestArea = Number.POSITIVE_INFINITY;
  for (const table of tables) {
    if (!table || !table.bbox) continue;
    const tPage = viewerToPageIndex(table.page_index);
    if (tPage !== null && tPage !== pageIndex) continue;
    const rect = viewerRectForCanvas(table.bbox, canvasWidth, canvasHeight);
    if (!rect) continue;
    const inside = x >= rect.x && x <= (rect.x + rect.w) && y >= rect.y && y <= (rect.y + rect.h);
    if (!inside) continue;
    const area = rect.w * rect.h;
    if (area < bestArea) {
      bestArea = area;
      best = table;
    }
  }
  return best;
}

function viewerHitTestSegmentAtPoint(x, y, canvasWidth, canvasHeight) {
  const segments = Array.isArray(viewerState.payload?.segments) ? viewerState.payload.segments : [];
  const pageIndex = viewerState.page - 1;
  let best = null;
  let bestArea = Number.POSITIVE_INFINITY;
  for (const segment of segments) {
    if (!segment) continue;
    const sPage = viewerResolvedSegmentPageIndex(segment);
    if (sPage === null || sPage !== pageIndex) continue;
    const rect = viewerSegmentRectForCanvas(segment, canvasWidth, canvasHeight, pageIndex);
    if (!rect) continue;
    const inside = x >= rect.x && x <= (rect.x + rect.w) && y >= rect.y && y <= (rect.y + rect.h);
    if (!inside) continue;
    const area = rect.w * rect.h;
    if (area < bestArea) {
      bestArea = area;
      best = segment;
    }
  }
  return best;
}

function viewerHandleOverlayClick(event) {
  if (!viewerState.pdfDoc || viewerState.contentKind !== 'pdf') return;
  if (viewerState.panDragging) return;
  const overlayCanvas = document.getElementById('viewer-overlay-canvas');
  if (!overlayCanvas || overlayCanvas.width <= 0 || overlayCanvas.height <= 0) return;
  const bounds = overlayCanvas.getBoundingClientRect();
  if (!bounds.width || !bounds.height) return;
  const x = ((event.clientX - bounds.left) / bounds.width) * overlayCanvas.width;
  const y = ((event.clientY - bounds.top) / bounds.height) * overlayCanvas.height;

  const showTables = viewerOverlayToggleValue('viewer-toggle-tables', true);
  const showSegments = viewerOverlayToggleValue('viewer-toggle-segments', true);
  if (showTables) {
    const table = viewerHitTestTableAtPoint(x, y, overlayCanvas.width, overlayCanvas.height);
    if (table?.id) {
      viewerSelectTable(table.id, { jumpPage: false, source: 'pdf-click' });
      return;
    }
  }
  if (showSegments) {
    const segment = viewerHitTestSegmentAtPoint(x, y, overlayCanvas.width, overlayCanvas.height);
    if (segment?.id) {
      viewerSelectSegment(segment.id, { jumpPage: false, source: 'pdf-click' });
    }
  }
}

function viewerInitOverlayHandlers() {
  const overlayCanvas = document.getElementById('viewer-overlay-canvas');
  if (!overlayCanvas) return;
  if (overlayCanvas.dataset.viewerOverlayInit === '1') return;
  overlayCanvas.dataset.viewerOverlayInit = '1';
  overlayCanvas.addEventListener('click', viewerHandleOverlayClick);
}

function viewerRenderOverlay() {
  const overlayCanvas = document.getElementById('viewer-overlay-canvas');
  const baseCanvas = document.getElementById('viewer-pdf-canvas');
  if (!overlayCanvas || !baseCanvas || viewerState.contentKind !== 'pdf' || !viewerState.pdfDoc) return;
  const ctx = overlayCanvas.getContext('2d');
  if (!ctx) return;
  ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

  const payload = viewerState.payload;
  const pageIndex = viewerState.page - 1;
  const showTables = viewerOverlayToggleValue('viewer-toggle-tables', true);
  const showSegments = viewerOverlayToggleValue('viewer-toggle-segments', true);

  if (showTables) {
    const tables = Array.isArray(payload?.tables) ? payload.tables : [];
    tables.forEach((table) => {
      if (!table || !table.bbox) return;
      if (viewerToPageIndex(table.page_index) !== null && viewerToPageIndex(table.page_index) !== pageIndex) return;
      const rect = viewerRectForCanvas(table.bbox, overlayCanvas.width, overlayCanvas.height);
      if (!rect) return;
      const selected = table.id === viewerState.selectedTableId;
      ctx.strokeStyle = selected ? '#0ea5e9' : '#22d3ee';
      ctx.lineWidth = selected ? 2.4 : 1.7;
      ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
      if (selected) {
        ctx.fillStyle = 'rgba(14,165,233,0.16)';
        ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
        const shape = viewerTableShape(table);
        const rows = Math.max(0, Number(shape.rows) || 0);
        const cols = Math.max(0, Number(shape.cols) || 0);
        if (rows > 1 || cols > 1) {
          ctx.save();
          ctx.strokeStyle = 'rgba(14,165,233,0.52)';
          ctx.lineWidth = 1;
          if (rows > 1 && rows <= 140) {
            for (let rowIdx = 1; rowIdx < rows; rowIdx += 1) {
              const y = rect.y + (rect.h * (rowIdx / rows));
              ctx.beginPath();
              ctx.moveTo(rect.x, y);
              ctx.lineTo(rect.x + rect.w, y);
              ctx.stroke();
            }
          }
          if (cols > 1 && cols <= 140) {
            for (let colIdx = 1; colIdx < cols; colIdx += 1) {
              const x = rect.x + (rect.w * (colIdx / cols));
              ctx.beginPath();
              ctx.moveTo(x, rect.y);
              ctx.lineTo(x, rect.y + rect.h);
              ctx.stroke();
            }
          }
          ctx.restore();
        }
      }
    });
  }

  if (showSegments) {
    const segments = Array.isArray(payload?.segments) ? payload.segments : [];
    const pageSegments = segments.filter((segment) => (
      segment && viewerResolvedSegmentPageIndex(segment) === pageIndex
    ));
    const needsEstimated = pageSegments.some((segment) => segment && !segment.bbox);
    const layoutKey = String(pageIndex + 1);
    if (
      needsEstimated
      && !viewerState.pageTextLayoutCache[layoutKey]
      && !viewerState.pageTextLayoutPromises[layoutKey]
      && viewerState.pdfDoc
    ) {
      viewerEnsurePageTextLayout(pageIndex + 1).then(() => {
        if (viewerState.page === (pageIndex + 1)) viewerRenderOverlay();
      });
    }

    let drawn = 0;
    for (const segment of pageSegments) {
      const rect = viewerSegmentRectForCanvas(segment, overlayCanvas.width, overlayCanvas.height, pageIndex);
      if (!rect) continue;
      const selected = segment.id === viewerState.selectedSegmentId;
      const palette = viewerSegmentPalette(segment.segment_type, selected);
      ctx.strokeStyle = palette.stroke;
      ctx.lineWidth = palette.lineWidth;
      ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
      if (selected) {
        ctx.fillStyle = palette.fill;
        ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
      }
      drawn += 1;
      if (drawn > 1600) break;
    }
  }

  const annotationRects = viewerCollectAnnotationRects(pageIndex);
  if (annotationRects.length) {
    ctx.strokeStyle = 'rgba(217,70,239,0.7)';
    ctx.lineWidth = 1.1;
    annotationRects.forEach((bbox) => {
      const rect = viewerRectForCanvas(bbox, overlayCanvas.width, overlayCanvas.height);
      if (!rect) return;
      ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
    });
  }
}

async function viewerEnsurePdfJs() {
  if (window.pdfjsLib) {
    window.pdfjsLib.GlobalWorkerOptions.workerSrc = VIEWER_PDFJS_WORKER_SRC;
    return window.pdfjsLib;
  }
  if (viewerState.pdfJsPromise) return viewerState.pdfJsPromise;
  viewerState.pdfJsPromise = new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = VIEWER_PDFJS_SRC;
    script.async = true;
    script.onload = () => {
      if (!window.pdfjsLib) {
        reject(new Error('PDF.js loaded but pdfjsLib is unavailable.'));
        return;
      }
      window.pdfjsLib.GlobalWorkerOptions.workerSrc = VIEWER_PDFJS_WORKER_SRC;
      resolve(window.pdfjsLib);
    };
    script.onerror = () => reject(new Error('Failed to load PDF.js runtime.'));
    document.head.appendChild(script);
  });
  return viewerState.pdfJsPromise;
}

function viewerFitCanvases(viewport, scrollEl) {
  const baseCanvas = document.getElementById('viewer-pdf-canvas');
  const overlayCanvas = document.getElementById('viewer-overlay-canvas');
  if (!baseCanvas || !overlayCanvas || !viewport || !scrollEl) return;

  const width = Math.max(1, Math.floor(viewport.width));
  const height = Math.max(1, Math.floor(viewport.height));
  baseCanvas.width = width;
  baseCanvas.height = height;
  baseCanvas.style.width = `${width}px`;
  baseCanvas.style.height = `${height}px`;
  baseCanvas.style.display = 'block';

  overlayCanvas.width = width;
  overlayCanvas.height = height;
  overlayCanvas.style.width = `${width}px`;
  overlayCanvas.style.height = `${height}px`;
  overlayCanvas.style.left = `${Math.max(0, Math.floor((scrollEl.clientWidth - width) / 2))}px`;
  overlayCanvas.style.top = '0px';
  overlayCanvas.style.display = 'block';
}

async function viewerRenderCurrentPdfPage() {
  if (!viewerState.pdfDoc) return;
  const fallback = document.getElementById('viewer-fallback');
  if (fallback) fallback.innerHTML = '';
  const scrollEl = document.getElementById('viewer-scroll');
  if (!scrollEl) return;

  try {
    const renderToken = ++viewerState.renderToken;
    const page = await viewerState.pdfDoc.getPage(viewerState.page);
    if (renderToken !== viewerState.renderToken) return;

    const baseViewport = page.getViewport({ scale: 1.0 });
    viewerState.pageBaseWidth = baseViewport.width;
    viewerState.pageBaseHeight = baseViewport.height;

    const viewport = page.getViewport({ scale: viewerState.zoom });
    viewerFitCanvases(viewport, scrollEl);

    const baseCanvas = document.getElementById('viewer-pdf-canvas');
    if (!baseCanvas) return;
    const context = baseCanvas.getContext('2d');
    if (!context) return;
    await page.render({ canvasContext: context, viewport }).promise;
    if (renderToken !== viewerState.renderToken) return;
    viewerSetRenderMode('interactive');
    viewerUpdatePageZoomLabels();
    viewerRenderOverlay();
    viewerRenderOverlayList();
  } catch (error) {
    viewerState.pdfDoc = null;
    viewerState.renderError = String(error || 'PDF render failure');
    const url = viewerCurrentContentUrl(false);
    viewerShowFallback(viewerBuildPdfFallbackState(url, viewerState.renderError));
    viewerSetRenderMode('fallback', viewerBuildDiagnosticPayload(viewerState.renderError));
    viewerSetStatus('Interactive rendering failed. Fallback mode is active.');
  }
}

async function viewerLoadPdfSource(url) {
  viewerResetStage();
  const token = ++viewerState.pdfLoadToken;
  viewerState.contentKind = 'pdf';
  const fallback = document.getElementById('viewer-fallback');
  if (fallback) {
    fallback.innerHTML = `
      <section class="viewer-empty-state">
        <h3>Loading PDF source...</h3>
        <p class="small">Preparing interactive rendering and overlay data.</p>
      </section>
    `;
  }
  try {
    const pdfjs = await viewerEnsurePdfJs();
    const loadingTask = pdfjs.getDocument(url);
    const doc = await loadingTask.promise;
    if (token !== viewerState.pdfLoadToken) return;
    viewerState.pdfDoc = doc;
    viewerState.pageCount = Math.max(1, Number(doc.numPages || 1));
    if (viewerState.page > viewerState.pageCount) viewerState.page = viewerState.pageCount;
    viewerState.renderError = '';
    viewerSetRenderMode('interactive');
    viewerSetStatus(`Loaded PDF (${viewerState.pageCount} pages). Interactive overlays are available.`);
    await viewerRenderCurrentPdfPage();
    viewerPrimeSyntheticPageRanges();
  } catch (error) {
    viewerState.pdfDoc = null;
    viewerState.pageCount = viewerDerivePageCount(viewerState.payload);
    viewerState.renderError = String(error || 'PDF load error');
    viewerUpdatePageZoomLabels();
    viewerShowFallback(viewerBuildPdfFallbackState(url, viewerState.renderError));
    viewerSetRenderMode('fallback', viewerBuildDiagnosticPayload(viewerState.renderError));
    viewerSetStatus('Interactive PDF rendering is unavailable. Fallback mode is active and overlays are disabled.');
  }
}

function viewerSelectedSnippetHtml() {
  const text = String(viewerState.nonPdfTextContent || '');
  if (!text) {
    return '<p class="viewer-structured-selection">Select a segment, table, or annotation to inspect details.</p>';
  }
  const segment = viewerCurrentSegment();
  if (!segment || !Number.isFinite(Number(segment.start_offset)) || !Number.isFinite(Number(segment.end_offset))) {
    return '<p class="viewer-structured-selection">Select a segment, table, or annotation to inspect details.</p>';
  }
  const start = Math.max(0, Math.floor(Math.min(Number(segment.start_offset), Number(segment.end_offset))));
  const end = Math.max(start, Math.floor(Math.max(Number(segment.start_offset), Number(segment.end_offset))));
  const left = Math.max(0, start - 260);
  const right = Math.min(text.length, end + 260);
  const pre = dbEscapeHtml(text.slice(left, start));
  const hit = dbEscapeHtml(text.slice(start, end));
  const post = dbEscapeHtml(text.slice(end, right));
  const prefix = left > 0 ? '...' : '';
  const suffix = right < text.length ? '...' : '';
  return `<p class="viewer-structured-selection">${prefix}${pre}<mark>${hit || '[empty selection]'}</mark>${post}${suffix}</p>`;
}

function viewerStructuredTablePreview(table) {
  const headers = Array.isArray(table?.col_headers) ? table.col_headers : [];
  const cells = Array.isArray(table?.cells) ? table.cells : [];
  const active = table?.id && table.id === viewerState.selectedTableId && viewerState.selectedKind === 'table'
    ? ' active'
    : '';
  const shape = viewerTableShape(table);
  const maxRows = Math.min(8, Math.max(1, Number(shape.rows) || 1));
  const maxCols = Math.min(8, Math.max(1, Number(shape.cols) || headers.length || 1));
  const cellByPos = new Map();
  cells.forEach((cell) => {
    const r = Number(cell?.row_index);
    const c = Number(cell?.col_index);
    if (!Number.isFinite(r) || !Number.isFinite(c)) return;
    cellByPos.set(`${Math.floor(r)}:${Math.floor(c)}`, String(cell?.value || ''));
  });
  const headCells = Array.from({ length: maxCols }, (_, idx) => {
    const label = headers[idx] || `C${idx + 1}`;
    return `<th>${dbEscapeHtml(String(label))}</th>`;
  }).join('');
  const bodyRows = Array.from({ length: maxRows }, (_, rowIdx) => {
    const rowCells = Array.from({ length: maxCols }, (_, colIdx) => {
      const key = `${rowIdx}:${colIdx}`;
      return `<td>${dbEscapeHtml(String(cellByPos.get(key) || ''))}</td>`;
    }).join('');
    return `<tr>${rowCells}</tr>`;
  }).join('');
  return `
    <article class="viewer-structured-card${active}" data-viewer-structured-table-id="${dbEscapeHtml(String(table?.id || ''))}">
      <p><strong>Table:</strong> ${dbEscapeHtml(String(table?.caption || table?.table_id || table?.id || 'table'))}</p>
      <p class="small">Page ${dbEscapeHtml(String(table?.page_number || 'n/a'))}  ${dbEscapeHtml(String(shape.rows || 0))} rows  ${dbEscapeHtml(String(shape.cols || 0))} cols</p>
      <div class="viewer-structured-table-wrap">
        <table>
          <thead><tr>${headCells}</tr></thead>
          <tbody>${bodyRows}</tbody>
        </table>
      </div>
    </article>
  `;
}

function viewerStructuredSegmentCards(segments) {
  return segments.slice(0, 120).map((segment) => {
    const active = segment.id && segment.id === viewerState.selectedSegmentId && viewerState.selectedKind === 'segment'
      ? ' active'
      : '';
    const page = viewerResolvedSegmentPageNumber(segment);
    const span = `${String(segment.start_offset || 0)}-${String(segment.end_offset || 0)}`;
    return `
      <article class="viewer-structured-card${active}" data-viewer-structured-segment-id="${dbEscapeHtml(String(segment.id || ''))}">
        <p><strong>${dbEscapeHtml(String(segment.segment_type || 'segment'))}</strong></p>
        <p class="small">Page ${dbEscapeHtml(String(page || 'n/a'))}  ${dbEscapeHtml(span)}</p>
      </article>
    `;
  }).join('');
}

function viewerStructuredAnnotationCards(annotations) {
  return annotations.slice(0, 80).map((annotation) => {
    const active = annotation.id && annotation.id === viewerState.selectedAnnotationId && viewerState.selectedKind === 'annotation'
      ? ' active'
      : '';
    return `
      <article class="viewer-structured-card${active}" data-viewer-structured-annotation-id="${dbEscapeHtml(String(annotation.id || ''))}">
        <p><strong>${dbEscapeHtml(String(annotation.category || 'annotation'))}</strong> <span class="small">${dbEscapeHtml(String(annotation.layer || ''))}</span></p>
        <p>${dbEscapeHtml(String(annotation.label || annotation.source || annotation.snippet || ''))}</p>
      </article>
    `;
  }).join('');
}

function viewerUpdateStructuredSelection() {
  if (viewerState.renderMode !== 'nonpdf') return;
  const selection = document.getElementById('viewer-structured-selection');
  if (selection) selection.innerHTML = viewerSelectedSnippetHtml();
  document.querySelectorAll('[data-viewer-structured-table-id]').forEach((node) => {
    const tableId = node.getAttribute('data-viewer-structured-table-id') || '';
    const active = tableId && tableId === viewerState.selectedTableId && viewerState.selectedKind === 'table';
    node.classList.toggle('active', Boolean(active));
  });
  document.querySelectorAll('[data-viewer-structured-segment-id]').forEach((node) => {
    const segmentId = node.getAttribute('data-viewer-structured-segment-id') || '';
    const active = segmentId && segmentId === viewerState.selectedSegmentId && viewerState.selectedKind === 'segment';
    node.classList.toggle('active', Boolean(active));
  });
  document.querySelectorAll('[data-viewer-structured-annotation-id]').forEach((node) => {
    const annotationId = node.getAttribute('data-viewer-structured-annotation-id') || '';
    const active = annotationId && annotationId === viewerState.selectedAnnotationId && viewerState.selectedKind === 'annotation';
    node.classList.toggle('active', Boolean(active));
  });
}

async function viewerLoadNonPdfFullText(resourceId) {
  if (!resourceId || viewerState.nonPdfTextLoading) return;
  if (viewerState.nonPdfTextResourceId === resourceId && viewerState.nonPdfTextContent) return;
  const textNode = document.getElementById('viewer-structured-fulltext');
  viewerState.nonPdfTextLoading = true;
  viewerState.nonPdfTextToken += 1;
  const token = viewerState.nonPdfTextToken;
  if (textNode) {
    textNode.classList.add('loading');
    textNode.textContent = 'Loading full extracted text...';
  }
  try {
    const payload = await callApi(
      'GET',
      `/api/extract/text?resource_id=${encodeURIComponent(resourceId)}`,
      null,
      null
    );
    if (token !== viewerState.nonPdfTextToken) return;
    const text = String(payload?.document_text?.text_content || '');
    if (text) {
      viewerState.nonPdfTextContent = text;
      viewerState.nonPdfTextResourceId = resourceId;
    }
  } catch {
  } finally {
    if (token !== viewerState.nonPdfTextToken) return;
    viewerState.nonPdfTextLoading = false;
    const node = document.getElementById('viewer-structured-fulltext');
    if (node) {
      node.classList.remove('loading');
      node.textContent = viewerState.nonPdfTextContent || 'No extracted text available for this file.';
    }
    viewerUpdateStructuredSelection();
  }
}

function viewerRenderNonPdfSource(payload) {
  viewerResetStage();
  const kind = String(payload?.content?.kind || 'binary');
  const url = String(payload?.content?.url || '');
  viewerState.contentKind = kind;
  viewerSetRenderMode('nonpdf');
  const extraction = payload?.extraction || {};
  const hasExtractedContent = Boolean(
    (Array.isArray(payload?.tables) && payload.tables.length)
    || (Array.isArray(payload?.segments) && payload.segments.length)
    || (Array.isArray(payload?.annotations) && payload.annotations.length)
    || extraction?.document_text
  );
  viewerState.nonPdfTextContent = String(payload?.document_text_excerpt || '');
  viewerState.nonPdfTextResourceId = '';
  viewerState.nonPdfTextLoading = false;

  if (!url && !hasExtractedContent) {
    viewerShowFallback(`
      <section class="viewer-empty-state">
        <h3>Source unavailable</h3>
        <p class="small">No source URL is available for this document.</p>
      </section>
    `);
    viewerSetStatus('Source URL unavailable.');
    return;
  }

  if (hasExtractedContent) {
    const tables = Array.isArray(payload?.tables) ? payload.tables : [];
    const segments = Array.isArray(payload?.segments) ? payload.segments : [];
    const annotations = Array.isArray(payload?.annotations) ? payload.annotations : [];
    const sourceButtons = url
      ? `
        <div class="viewer-empty-actions">
          <a href="${dbEscapeHtml(url)}" target="_blank" rel="noopener">Open original source</a>
          <a href="${dbEscapeHtml(url)}${url.includes('?') ? '&' : '?'}download=true" target="_blank" rel="noopener">Download original</a>
        </div>
      `
      : '';
    viewerShowFallback(`
      <section class="viewer-empty-state viewer-structured-view">
        <h3>Structured document rendering</h3>
        <p class="small">Interactive PDF canvas is unavailable for this file type. This view renders extracted text, tables, and annotations for review and highlighting.</p>
        ${sourceButtons}
        <div class="viewer-structured-grid">
          <section class="viewer-structured-block">
            <h4>Selected Fragment</h4>
            <div id="viewer-structured-selection">${viewerSelectedSnippetHtml()}</div>
            <h4>Full Extracted Text</h4>
            <pre id="viewer-structured-fulltext" class="viewer-structured-text">${dbEscapeHtml(viewerState.nonPdfTextContent || 'No extracted text available for this file.')}</pre>
          </section>
          <section class="viewer-structured-block">
            <h4>Structured Items</h4>
            <div class="viewer-structured-card-list">
              ${tables.map((table) => viewerStructuredTablePreview(table)).join('')}
              ${viewerStructuredSegmentCards(segments)}
              ${viewerStructuredAnnotationCards(annotations)}
            </div>
          </section>
        </div>
      </section>
    `);
    document.querySelectorAll('[data-viewer-structured-table-id]').forEach((node) => {
      node.addEventListener('click', () => {
        viewerSelectTable(node.getAttribute('data-viewer-structured-table-id') || '', { jumpPage: false, source: 'structured' });
      });
    });
    document.querySelectorAll('[data-viewer-structured-segment-id]').forEach((node) => {
      node.addEventListener('click', () => {
        viewerSelectSegment(node.getAttribute('data-viewer-structured-segment-id') || '', { jumpPage: false, source: 'structured' });
      });
    });
    document.querySelectorAll('[data-viewer-structured-annotation-id]').forEach((node) => {
      node.addEventListener('click', () => {
        viewerSelectAnnotation(node.getAttribute('data-viewer-structured-annotation-id') || '', { jumpPage: false, source: 'structured' });
      });
    });
    viewerUpdateStructuredSelection();
    const resourceId = String(payload?.resource?.id || '');
    if (resourceId) viewerLoadNonPdfFullText(resourceId);
    viewerSetStatus('Structured source rendering loaded for non-PDF media.');
    return;
  }

  if (kind === 'image') {
    viewerShowFallback(`
      <section class="viewer-empty-state">
        <h3>Image source</h3>
        <p class="small">This document is stored as an image. Overlay drawing is unavailable for this format.</p>
        <div class="viewer-empty-actions">
          <a href="${dbEscapeHtml(url)}" target="_blank" rel="noopener">Open externally</a>
          <a href="${dbEscapeHtml(url)}${url.includes('?') ? '&' : '?'}download=true" target="_blank" rel="noopener">Download original</a>
        </div>
        <img src="${dbEscapeHtml(url)}" alt="resource source image" />
      </section>
    `);
    viewerSetStatus('Image source loaded.');
    return;
  }
  viewerShowFallback(`
    <section class="viewer-empty-state">
      <h3>Fallback source view</h3>
      <p class="small">Open the document externally or download the original file.</p>
      <div class="viewer-empty-actions">
        <a href="${dbEscapeHtml(url)}" target="_blank" rel="noopener">Open original source</a>
        <a href="${dbEscapeHtml(url)}${url.includes('?') ? '&' : '?'}download=true" target="_blank" rel="noopener">Download original</a>
      </div>
      ${url ? `<div class="viewer-fallback-embed"><iframe src="${dbEscapeHtml(url)}" title="Document source frame"></iframe></div>` : ''}
    </section>
  `);
  viewerSetStatus('Fallback source rendering loaded.');
}

function viewerDerivePageCount(payload) {
  const extraction = payload?.extraction || {};
  const pagesFromExtraction = []
    .concat(Array.isArray(extraction.pages_with_tables) ? extraction.pages_with_tables : [])
    .concat(Array.isArray(extraction.pages_with_geometry) ? extraction.pages_with_geometry : []);
  const pagesFromImages = Array.isArray(payload?.images)
    ? payload.images.map((img) => img?.page_number ?? img?.page_index)
    : [];
  const values = pagesFromExtraction
    .concat(pagesFromImages)
    .map((p) => Number(p))
    .filter((n) => Number.isFinite(n) && n >= 0)
    .map((n) => Math.floor(n));
  if (!values.length) return 1;
  const oneBased = Math.min(...values) >= 1;
  let count = 1;
  values.forEach((n) => {
    const candidate = oneBased ? n : (n + 1);
    count = Math.max(count, candidate);
  });
  return Math.max(1, count);
}

function viewerResolveContentUrl(url) {
  const target = String(url || '');
  if (!target) return '';
  const candidates = candidateApiUrls(target);
  return candidates.length ? candidates[candidates.length - 1] : target;
}

async function viewerOpenPayload(payload) {
  if (payload?.content?.url) {
    payload.content.url = viewerResolveContentUrl(payload.content.url);
  }
  viewerState.payload = payload;
  viewerState.displayTitle = viewerEffectiveTitle(payload);
  viewerState.sourceLabel = viewerDeriveSourceLabel(payload);
  viewerState.pageTextLayoutCache = {};
  viewerState.pageTextLayoutPromises = {};
  viewerState.syntheticPageOffsetRangeByIndex = {};
  viewerState.syntheticPageOffsetPromise = null;
  viewerState.zoom = 1;
  viewerState.page = 1;
  viewerState.nonPdfTextContent = '';
  viewerState.nonPdfTextLoading = false;
  viewerState.nonPdfTextResourceId = '';
  viewerState.nonPdfTextToken += 1;
  viewerState.pageIndexBase = viewerInferPageIndexBase(payload);
  viewerState.pageOffsetRangeByIndex = viewerBuildPageOffsetRanges(payload?.segments || []);
  viewerState.selectedCellRow = null;
  viewerState.selectedCellCol = null;
  viewerState.renderError = '';
  viewerState.tableEditMode = false;
  viewerState.indexTablePage = 1;
  viewerState.indexFilterText = '';
  viewerState.indexFilterType = 'all';
  const indexSearch = document.getElementById('viewer-index-search');
  const indexType = document.getElementById('viewer-index-type');
  if (indexSearch) indexSearch.value = '';
  if (indexType) indexType.value = 'all';
  const firstTable = Array.isArray(payload?.tables) && payload.tables.length ? payload.tables[0] : null;
  const firstImage = Array.isArray(payload?.images) && payload.images.length ? payload.images[0] : null;
  viewerState.selectedTableId = firstTable?.id || '';
  viewerState.selectedImageId = firstImage?.id || '';
  viewerState.selectedSegmentId = '';
  viewerState.selectedAnnotationId = '';
  viewerState.selectedKind = firstTable?.id ? 'table' : (firstImage?.id ? 'image' : '');
  viewerSetActiveResource(payload?.resource?.id || '');
  viewerRenderHeader();
  viewerRenderMetadata();
  viewerRenderAnnotations();
  viewerRenderOverlayList();
  viewerRenderTableGrid();
  viewerRenderStructuredData();
  const hasTables = Array.isArray(payload?.tables) && payload.tables.length > 0;
  const hasImages = Array.isArray(payload?.images) && payload.images.length > 0;
  const hasAnnotations = Array.isArray(payload?.annotations) && payload.annotations.length > 0;
  if (hasTables) viewerSetInspectorTab('tables');
  else if (hasImages) viewerSetInspectorTab('overlays');
  else if (hasAnnotations) viewerSetInspectorTab('annotations');
  else viewerSetInspectorTab('overlays');
  viewerToggleInspector(true);
  viewerState.pageCount = viewerDerivePageCount(payload);
  viewerUpdatePageZoomLabels();
  if (String(payload?.content?.kind || '') === 'pdf') {
    await viewerLoadPdfSource(String(payload?.content?.url || ''));
  } else {
    viewerRenderNonPdfSource(payload);
  }
}

function viewerLoadQueryFromInput(rawValue) {
  const raw = String(rawValue || '').trim();
  if (!raw) return null;
  const isDigest = /^[a-f0-9]{64}$/i.test(raw);
  return isDigest
    ? `resource_digest=${encodeURIComponent(raw)}`
    : `resource_id=${encodeURIComponent(raw)}`;
}

async function viewerOpenWithQuery(query) {
  if (!query) return;
  viewerSetStatus('Loading document source and extraction overlays...');
  viewerSetRenderMode('empty');
  const payload = await callApi('GET', `/api/viewer/document?${query}`, null, 'out-viewer');
  if (!payload || payload.ok !== true) {
    viewerSetStatus(payload?.detail || payload?.error || 'Document viewer load failed.');
    return;
  }
  await viewerOpenPayload(payload);
}

async function viewerOpenSelected() {
  const select = document.getElementById('viewer-resource-select');
  const selectedId = String(select?.value || '').trim();
  if (!selectedId) {
    viewerSetStatus('Select a resource first.');
    return;
  }
  await viewerOpenWithQuery(`resource_id=${encodeURIComponent(selectedId)}`);
}

async function viewerOpenFromInput() {
  const input = document.getElementById('viewer-resource-id');
  const query = viewerLoadQueryFromInput(input?.value || '');
  if (!query) {
    viewerSetStatus('Provide a resource ID or 64-char digest.');
    return;
  }
  await viewerOpenWithQuery(query);
}

async function viewerOpenFromImport(resourceId) {
  if (!resourceId) return;
  setActivePane('viewer');
  await viewerRefreshResources();
  await viewerOpenWithQuery(`resource_id=${encodeURIComponent(String(resourceId))}`);
}

function viewerPrevPage() {
  if (viewerState.page <= 1) return;
  viewerState.page -= 1;
  viewerUpdatePageZoomLabels();
  if (viewerState.pdfDoc) viewerRenderCurrentPdfPage();
  else viewerSyncFallbackPdfView();
  viewerRenderOverlayList();
}

function viewerNextPage() {
  if (viewerState.page >= viewerState.pageCount) return;
  viewerState.page += 1;
  viewerUpdatePageZoomLabels();
  if (viewerState.pdfDoc) viewerRenderCurrentPdfPage();
  else viewerSyncFallbackPdfView();
  viewerRenderOverlayList();
}

function viewerZoomOut() {
  viewerState.zoom = Math.max(viewerState.minZoom, Number((viewerState.zoom - 0.1).toFixed(2)));
  viewerUpdatePageZoomLabels();
  if (viewerState.pdfDoc) viewerRenderCurrentPdfPage();
  else viewerSyncFallbackPdfView();
}

function viewerZoomIn() {
  viewerState.zoom = Math.min(viewerState.maxZoom, Number((viewerState.zoom + 0.1).toFixed(2)));
  viewerUpdatePageZoomLabels();
  if (viewerState.pdfDoc) viewerRenderCurrentPdfPage();
  else viewerSyncFallbackPdfView();
}

function viewerFitWidth() {
  if (!viewerState.pdfDoc) {
    viewerSetStatus('Fit width is available only in interactive PDF mode.');
    return;
  }
  const scrollEl = document.getElementById('viewer-scroll');
  if (!scrollEl) return;
  const base = viewerState.pageBaseWidth;
  if (!base || base <= 0) {
    viewerSetStatus('Rendering current page before fitting to width...');
    viewerRenderCurrentPdfPage();
    return;
  }
  const nextZoom = (scrollEl.clientWidth - 24) / base;
  const clamped = Math.max(viewerState.minZoom, Math.min(viewerState.maxZoom, Number(nextZoom.toFixed(2))));
  viewerState.zoom = clamped;
  viewerUpdatePageZoomLabels();
  viewerRenderCurrentPdfPage();
}

function viewerTogglePan(enabled) {
  const allow = Boolean(enabled) && viewerState.renderMode === 'interactive';
  viewerState.panEnabled = allow;
  const scroll = document.getElementById('viewer-scroll');
  if (!scroll) return;
  scroll.classList.toggle('pan-enabled', viewerState.panEnabled);
}

function viewerInitPanHandlers() {
  const scroll = document.getElementById('viewer-scroll');
  if (!scroll) return;
  const beginPan = (event) => {
    if (!viewerState.panEnabled || !viewerState.pdfDoc) return;
    viewerState.panDragging = true;
    viewerState.panStartX = event.clientX;
    viewerState.panStartY = event.clientY;
    viewerState.panScrollLeft = scroll.scrollLeft;
    viewerState.panScrollTop = scroll.scrollTop;
    scroll.classList.add('panning');
    event.preventDefault();
  };
  const movePan = (event) => {
    if (!viewerState.panDragging) return;
    const dx = event.clientX - viewerState.panStartX;
    const dy = event.clientY - viewerState.panStartY;
    scroll.scrollLeft = viewerState.panScrollLeft - dx;
    scroll.scrollTop = viewerState.panScrollTop - dy;
  };
  const endPan = () => {
    viewerState.panDragging = false;
    scroll.classList.remove('panning');
  };
  scroll.addEventListener('mousedown', beginPan);
  window.addEventListener('mousemove', movePan);
  window.addEventListener('mouseup', endPan);
  scroll.addEventListener('mouseleave', () => {
    if (!viewerState.panDragging) return;
    viewerState.panDragging = false;
    scroll.classList.remove('panning');
  });
}

function initDocumentViewer() {
  viewerInitPanHandlers();
  viewerInitOverlayHandlers();
  viewerInitIndexControls();
  viewerRenderHeader();
  viewerSetInspectorTab('overlays');
  viewerToggleInspector(true);
  viewerSetRenderMode('empty');
  viewerRefreshResources();
  viewerRenderStructuredData();
}

const IMPORT_STEPS = [
  { id: 'archive', label: 'Archive & Dedupe' },
  { id: 'extract', label: 'Text Extraction' },
  { id: 'tables', label: 'Tables & Annotations' },
  { id: 'vector', label: 'Vector Index Update' },
];

let importProgressTimer = null;
let importCounterTimer = null;
let importProgressValue = 0;
let importPreviewUrl = null;
let importPreviewObjectKey = '';
let importPreviewMetaKey = '';
let importPreviewKind = 'generic';
let importPreviewPageCurrent = 1;
let importPreviewPageTotal = null;
let importPreviewProcessing = false;
let importPreviewTicker = null;
let importPreviewPdfDoc = null;
let importPreviewPdfSourceUrl = '';
let importPreviewPdfLoadToken = 0;
let importPreviewPdfRenderToken = 0;
let importPreviewPdfRenderTask = null;
let importPreviewLastRenderedPage = null;
let importPreviewPageBaseWidth = 0;
let importPreviewPageBaseHeight = 0;
let importPreviewSignalHistory = [];
let importPreviewLastSignalKey = '';
let importPreviewTextLoadToken = 0;
let importPreviewTextLoadedKey = '';
let importPreviewTextContent = '';
let importPreviewTextError = '';
let importPreviewTextSummary = '';
let importPreviewTextLoading = false;
let importHistoryItems = [];
let importDropQueue = [];
let importDropQueueRunning = false;
let importDropQueueSeq = 0;
let importDropQueueActiveId = null;
let importActiveEta = null;
let importActiveStepMap = null;
let importDurationSamples = [];
let importActiveStreamAbortController = null;
let importDeferRequestedItemId = null;
let importQueuePollTimer = null;
let importQueuePollInFlight = false;
let importQueueControlInFlight = new Set();
let importQueueEtaJobId = null;
let importDropScanClearTimer = null;
let importDebugMode = 'idle';
let importDebugMeta = null;
let importDebugStartedAt = null;
let importDebugUpdatedAt = null;
let importDebugEvents = [];
let importDebugStatusLine = '';
let importDebugCountersLine = '';
let importDebugStepMap = null;
let importDebugQueueJobId = null;
let importDebugQueueEventCursor = 0;

const IMPORT_STREAM_STAGE_WEIGHTS = { archive: 0.2, extract: 0.35, tables: 0.2, vector: 0.25 };
const IMPORT_ETA_HISTORY_MAX = 400;
const IMPORT_ETA_SAMPLE_MAX = 180;
const IMPORT_ETA_STALL_WARN_MS = 45000;
const IMPORT_ETA_STALL_CRITICAL_MS = 180000;
const IMPORT_DEBUG_MAX_EVENTS = 5000;
const IMPORT_PREVIEW_IMAGE_EXTENSIONS = new Set([
  '.png', '.jpg', '.jpeg', '.gif', '.bmp', '.webp', '.svg', '.tif', '.tiff', '.avif',
]);
const IMPORT_PREVIEW_TEXT_EXTENSIONS = new Set([
  '.txt', '.md', '.csv', '.rst', '.adoc', '.tex', '.html', '.htm', '.xhtml', '.xml',
  '.svg', '.fb2', '.dita', '.dbk', '.json', '.yaml', '.yml',
]);
const IMPORT_PREVIEW_TEXT_MEDIA = new Set([
  'text/plain', 'text/markdown', 'text/csv', 'text/html', 'application/xhtml+xml',
  'application/xml', 'text/xml', 'image/svg+xml', 'application/json',
]);
const IMPORT_DROP_ALLOWED_EXTENSIONS = new Set([
  '.pdf',
  '.doc',
  '.docx',
  '.xls',
  '.xlsx',
  '.csv',
  '.txt',
  '.rst',
  '.adoc',
  '.tex',
  '.html',
  '.htm',
  '.xml',
  '.xhtml',
  '.svg',
  '.fb2',
  '.dita',
  '.dbk',
  '.pptx',
  '.odt',
  '.ods',
  '.odp',
  '.odg',
  '.epub',
  '.oxps',
  '.3mf',
  '.md',
]);
const IMPORT_DROP_ALLOWED_MIME_TYPES = new Set([
  'application/pdf',
  'application/msword',
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  'application/vnd.openxmlformats-officedocument.presentationml.presentation',
  'application/vnd.oasis.opendocument.text',
  'application/vnd.oasis.opendocument.spreadsheet',
  'application/vnd.oasis.opendocument.presentation',
  'application/vnd.oasis.opendocument.graphics',
  'application/epub+zip',
  'application/oxps',
  'model/3mf',
  'text/plain',
  'text/markdown',
  'text/csv',
  'text/html',
  'application/xhtml+xml',
  'application/xml',
  'text/xml',
  'image/svg+xml',
]);

function importDebugNormalizePayload(payload) {
  try {
    return JSON.parse(
      JSON.stringify(payload, (key, value) => {
        if (typeof value === 'string' && value.length > 4000) {
          return `${value.slice(0, 3999)}`;
        }
        return value;
      })
    );
  } catch {
    return { detail: String(payload) };
  }
}

function importDebugReset(meta, mode = 'stream') {
  importDebugMode = String(mode || 'stream');
  importDebugMeta = importDebugNormalizePayload(meta || {});
  importDebugStartedAt = new Date().toISOString();
  importDebugUpdatedAt = importDebugStartedAt;
  importDebugEvents = [];
  importDebugStatusLine = '';
  importDebugCountersLine = '';
  importDebugStepMap = null;
  importDebugQueueJobId = null;
  importDebugQueueEventCursor = 0;
}

function importDebugPush(eventName, payload = {}, opts = {}) {
  const event = {
    at: new Date().toISOString(),
    event: String(eventName || 'event'),
    payload: importDebugNormalizePayload(payload || {}),
  };
  if (opts && opts.source) event.source = String(opts.source);
  importDebugEvents.push(event);
  if (importDebugEvents.length > IMPORT_DEBUG_MAX_EVENTS) {
    importDebugEvents = importDebugEvents.slice(importDebugEvents.length - IMPORT_DEBUG_MAX_EVENTS);
  }
  importDebugUpdatedAt = event.at;
}

function importDebugSetLiveSnapshot(statusLine, countersLine, stepMap) {
  importDebugStatusLine = String(statusLine || importDebugStatusLine || '');
  importDebugCountersLine = String(countersLine || importDebugCountersLine || '');
  importDebugStepMap = importDebugNormalizePayload(stepMap || importDebugStepMap || {});
  importDebugUpdatedAt = new Date().toISOString();
}

function importDebugRender(extra = {}) {
  const output = document.getElementById('out-ingest');
  if (!output) return;
  const payload = {
    mode: importDebugMode,
    started_at: importDebugStartedAt,
    updated_at: importDebugUpdatedAt || new Date().toISOString(),
    meta: importDebugMeta,
    status_line: importDebugStatusLine,
    counters_line: importDebugCountersLine,
    step_map: importDebugStepMap,
    events: importDebugEvents,
    ...importDebugNormalizePayload(extra || {}),
  };
  output.textContent = JSON.stringify(payload, null, 2);
}

function importClamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}

function importMedian(values) {
  if (!Array.isArray(values) || !values.length) return null;
  const ordered = values
    .map((v) => Number(v))
    .filter((v) => Number.isFinite(v))
    .sort((a, b) => a - b);
  if (!ordered.length) return null;
  const mid = Math.floor(ordered.length / 2);
  if (ordered.length % 2) return ordered[mid];
  return (ordered[mid - 1] + ordered[mid]) / 2;
}

function importTrimmedMean(values, trimFraction = 0.15) {
  if (!Array.isArray(values) || !values.length) return null;
  const ordered = values
    .map((v) => Number(v))
    .filter((v) => Number.isFinite(v))
    .sort((a, b) => a - b);
  if (!ordered.length) return null;
  const trimCount = Math.floor(ordered.length * importClamp(trimFraction, 0, 0.45));
  const slice = ordered.slice(trimCount, Math.max(trimCount + 1, ordered.length - trimCount));
  if (!slice.length) return null;
  return slice.reduce((sum, v) => sum + v, 0) / slice.length;
}

function importFileExtension(name) {
  const value = String(name || '').toLowerCase();
  const match = /\.([a-z0-9]+)$/.exec(value);
  return match ? match[1] : '';
}

function importEtaFeatures(meta) {
  const file = meta?.file || null;
  const name = String(meta?.name || file?.name || '');
  const sizeBytesRaw = meta?.sizeBytes ?? file?.size ?? 0;
  const sizeBytes = Number.isFinite(Number(sizeBytesRaw)) ? Math.max(0, Number(sizeBytesRaw)) : 0;
  return {
    name,
    ext: importFileExtension(name),
    sizeBytes,
  };
}

function importGuessDurationMs(meta) {
  const { ext, sizeBytes } = importEtaFeatures(meta);
  const sizeMb = sizeBytes / (1024 * 1024);
  let guess = 12000 + (sizeMb * 2500);
  if (ext === 'pdf') guess += 14000;
  if (ext === 'docx' || ext === 'doc') guess += 18000;
  if (ext === 'pptx' || ext === 'ppt') guess += 22000;
  return importClamp(Math.round(guess), 12000, 3 * 60 * 60 * 1000);
}

function importPredictDurationMs(meta) {
  const { ext, sizeBytes } = importEtaFeatures(meta);
  if (!importDurationSamples.length) return importGuessDurationMs(meta);

  const allDurations = importDurationSamples.map((s) => Number(s.durationMs)).filter((v) => Number.isFinite(v) && v > 0);
  const globalMedian = importMedian(allDurations);
  const extPool = importDurationSamples.filter((s) => s.ext === ext && Number.isFinite(Number(s.durationMs)) && Number(s.durationMs) > 0);
  const extMedian = extPool.length >= 3 ? importMedian(extPool.map((s) => Number(s.durationMs))) : null;

  const neighborPool = (extPool.length >= 3 ? extPool : importDurationSamples)
    .filter((s) => Number.isFinite(Number(s.sizeBytes)) && Number.isFinite(Number(s.durationMs)) && Number(s.durationMs) > 0);
  let neighborEstimate = null;
  if (neighborPool.length) {
    const ranked = neighborPool
      .map((s) => {
        const a = Math.log1p(Math.max(0, Number(s.sizeBytes)));
        const b = Math.log1p(Math.max(0, sizeBytes));
        const score = Math.abs(a - b);
        return { durationMs: Number(s.durationMs), score };
      })
      .sort((a, b) => a.score - b.score)
      .slice(0, 7)
      .map((s) => s.durationMs);
    neighborEstimate = importTrimmedMean(ranked, 0.2);
  }

  const parts = [];
  if (globalMedian) parts.push({ w: 0.22, v: globalMedian });
  if (extMedian) parts.push({ w: 0.43, v: extMedian });
  if (neighborEstimate) parts.push({ w: 0.35, v: neighborEstimate });
  if (!parts.length) return importGuessDurationMs(meta);

  const weightSum = parts.reduce((sum, p) => sum + p.w, 0);
  const blended = parts.reduce((sum, p) => sum + (p.v * p.w), 0) / weightSum;
  return importClamp(Math.round(blended), 8000, 3 * 60 * 60 * 1000);
}

function importRecordDurationSample(meta, durationMs, ok = true) {
  const duration = Number(durationMs);
  if (!Number.isFinite(duration) || duration <= 0) return;
  const features = importEtaFeatures(meta);
  importDurationSamples.push({
    ext: features.ext,
    sizeBytes: features.sizeBytes,
    durationMs: duration,
    ok: Boolean(ok),
    ts: Date.now(),
  });
  if (importDurationSamples.length > IMPORT_ETA_HISTORY_MAX) {
    importDurationSamples = importDurationSamples.slice(importDurationSamples.length - IMPORT_ETA_HISTORY_MAX);
  }
}

function importFormatEtaDuration(ms) {
  if (!Number.isFinite(ms) || ms < 0) return 'calculating...';
  if (ms < 1000) return '<1s';
  const totalSec = Math.ceil(ms / 1000);
  const sec = totalSec % 60;
  const min = Math.floor(totalSec / 60) % 60;
  const hr = Math.floor(totalSec / 3600);
  if (hr > 0) return `${hr}h ${String(min).padStart(2, '0')}m`;
  if (min > 0) return `${min}m ${String(sec).padStart(2, '0')}s`;
  return `${sec}s`;
}

function importEtaStart(meta) {
  const now = Date.now();
  return {
    meta,
    startedAtMs: now,
    lastHeartbeatMs: now,
    predictedTotalMs: importPredictDurationMs(meta),
    samples: [{ t: now, p: 0 }],
    lastProgress: 0,
  };
}

function importEtaTrackProgress(eta, progress01, nowMs) {
  if (!eta) return;
  const progress = importClamp(Number(progress01) || 0, 0, 1);
  const now = Number(nowMs) || Date.now();
  const prev = eta.samples.length ? eta.samples[eta.samples.length - 1] : null;
  const shouldPush = !prev
    || (progress - prev.p) >= 0.004
    || (now - prev.t) >= 5000;
  if (!shouldPush) return;
  eta.samples.push({ t: now, p: progress });
  if (eta.samples.length > IMPORT_ETA_SAMPLE_MAX) {
    eta.samples = eta.samples.slice(eta.samples.length - IMPORT_ETA_SAMPLE_MAX);
  }
  eta.lastProgress = Math.max(eta.lastProgress || 0, progress);
}

function importEtaRobustRate(eta) {
  if (!eta || !Array.isArray(eta.samples) || eta.samples.length < 3) return null;
  const recent = eta.samples.filter((s) => (eta.samples[eta.samples.length - 1].t - s.t) <= 180000);
  if (recent.length < 3) return null;
  const slopes = [];
  for (let i = 1; i < recent.length; i += 1) {
    const upper = recent[i];
    const start = Math.max(0, i - 7);
    for (let j = start; j < i; j += 1) {
      const lower = recent[j];
      const dt = (upper.t - lower.t) / 1000;
      if (dt < 1.0) continue;
      const dp = upper.p - lower.p;
      if (dp <= 0) continue;
      slopes.push(dp / dt);
    }
  }
  if (!slopes.length) return null;
  return importTrimmedMean(slopes, 0.15);
}

function importEtaEstimate(stepMap) {
  if (!importActiveEta) return null;
  const now = Date.now();
  const elapsedMs = Math.max(0, now - importActiveEta.startedAtMs);
  const progress01 = importClamp(importStreamOverallProgress(stepMap) / 100, 0, 1);
  importEtaTrackProgress(importActiveEta, progress01, now);

  const rate = importEtaRobustRate(importActiveEta);
  const priorRemainingMs = Math.max(0, importActiveEta.predictedTotalMs - elapsedMs);
  const etaFromRateMs = (rate && rate > 0.00001)
    ? Math.max(0, ((1 - progress01) / rate) * 1000)
    : null;

  let etaMs = null;
  if (etaFromRateMs === null) {
    etaMs = priorRemainingMs;
  } else {
    const wRate = importClamp(0.22 + (progress01 * 0.66) + (importActiveEta.samples.length >= 8 ? 0.08 : 0), 0.2, 0.92);
    etaMs = (wRate * etaFromRateMs) + ((1 - wRate) * priorRemainingMs);
  }

  const stallMs = Math.max(0, now - (importActiveEta.lastHeartbeatMs || importActiveEta.startedAtMs));
  if (stallMs >= IMPORT_ETA_STALL_WARN_MS) {
    const multiplier = stallMs >= IMPORT_ETA_STALL_CRITICAL_MS ? 1.6 : 1.25;
    etaMs = Math.max(etaMs, priorRemainingMs * multiplier);
  }

  return {
    elapsedMs,
    progress01,
    etaMs: Number.isFinite(etaMs) ? Math.max(0, etaMs) : null,
    stallMs,
  };
}

function importCounterLineWithEta(baseCountersLine, eta) {
  const raw = String(baseCountersLine || '').trim();
  const segments = raw ? raw.split('  ').filter((part) => part && !/^ETA\b/i.test(part)) : [];
  const elapsedToken = `Elapsed ${(eta?.elapsedMs ? (eta.elapsedMs / 1000).toFixed(1) : '0.0')}s`;
  if (!segments.some((part) => /^Elapsed\b/i.test(part))) {
    segments.unshift(elapsedToken);
  }
  const etaToken = `ETA ${importFormatEtaDuration(eta?.etaMs)}`;
  segments.push(etaToken);
  if (eta?.stallMs >= IMPORT_ETA_STALL_WARN_MS) {
    const stallLabel = eta.stallMs >= IMPORT_ETA_STALL_CRITICAL_MS ? 'stalled' : 'heartbeat delayed';
    segments.push(`${stallLabel} ${importFormatEtaDuration(eta.stallMs)}`);
  }
  return segments.join('  ');
}

function importStatusLineWithHeartbeat(baseStatusLine, eta) {
  const raw = String(baseStatusLine || '').replace(/\s*\s*waiting for stage heartbeat.*$/i, '').trim();
  if (!eta || eta.stallMs < IMPORT_ETA_STALL_WARN_MS) return raw;
  return `${raw}  waiting for stage heartbeat ${importFormatEtaDuration(eta.stallMs)}`;
}

function importQueueRemainingEtaMs() {
  if (!importDropQueue.length) return 0;
  const now = Date.now();
  return importDropQueue.reduce((sum, item) => {
    if (item.status === 'done' || item.status === 'failed') return sum;
    if (item.status === 'processing') {
      let processingRemaining = null;
      if (importDropQueueActiveId === item.id && importActiveEta && importActiveStepMap) {
        const eta = importEtaEstimate(importActiveStepMap);
        if (eta && Number.isFinite(eta.etaMs)) processingRemaining = eta.etaMs;
      }
      if (processingRemaining === null) {
        const predictedTotal = importPredictDurationMs(item);
        const elapsed = item.startedAtMs ? Math.max(0, now - item.startedAtMs) : 0;
        processingRemaining = Math.max(0, predictedTotal - elapsed);
      }
      return sum + processingRemaining;
    }
    return sum + importPredictDurationMs(item);
  }, 0);
}

function importCanDeferCurrentQueueItem() {
  if (!importActiveStreamAbortController) return false;
  if (!importDropQueueRunning || !importDropQueueActiveId) return false;
  return importDropQueue.some((item) => item.id !== importDropQueueActiveId && item.status === 'pending');
}

function importDeferCurrentQueueItem() {
  if (!importCanDeferCurrentQueueItem()) return;
  importDeferRequestedItemId = importDropQueueActiveId;
  if (importActiveStreamAbortController) {
    try {
      importActiveStreamAbortController.abort();
    } catch {
    }
  }
}

function importLiveQueueActionsHtml() {
  if (!importActiveStreamAbortController) return '';
  if (!importDropQueueRunning || !importDropQueueActiveId) return '';
  const canDefer = importCanDeferCurrentQueueItem();
  const hint = canDefer
    ? 'Move this document to the back of the queue and continue with the next pending file.'
    : 'No other pending files are available right now.';
  return `
    <div class="row">
      <button type="button" class="secondary" onclick="importDeferCurrentQueueItem()" ${canDefer ? '' : 'disabled'}>
        Put Document To Back Of Queue
      </button>
      <span class="small">${dbEscapeHtml(hint)}</span>
    </div>
  `;
}

function importFileSizeText(bytes) {
  const n = Number(bytes);
  if (!Number.isFinite(n) || n < 0) return 'unknown size';
  if (n < 1024) return `${Math.floor(n)} B`;
  if (n < 1024 * 1024) return `${(n / 1024).toFixed(1)} KB`;
  if (n < 1024 * 1024 * 1024) return `${(n / (1024 * 1024)).toFixed(1)} MB`;
  if (n < 1024 * 1024 * 1024 * 1024) return `${(n / (1024 * 1024 * 1024)).toFixed(2)} GB`;
  return `${(n / (1024 * 1024 * 1024 * 1024)).toFixed(2)} TB`;
}

function importPathBasename(path) {
  if (!path) return 'document';
  const clean = String(path).replace(/\\/g, '/');
  const parts = clean.split('/');
  return parts[parts.length - 1] || clean;
}

function importClearPreviewUrl() {
  importCancelPdfRenderTask();
  if (importPreviewUrl) {
    URL.revokeObjectURL(importPreviewUrl);
    importPreviewUrl = null;
  }
  importPreviewObjectKey = '';
  importPreviewPdfSourceUrl = '';
  importPreviewLastRenderedPage = null;
  importPreviewPageBaseWidth = 0;
  importPreviewPageBaseHeight = 0;
  importPreviewPdfLoadToken += 1;
  if (importPreviewPdfDoc && typeof importPreviewPdfDoc.destroy === 'function') {
    try {
      importPreviewPdfDoc.destroy();
    } catch {
    }
  }
  importPreviewPdfDoc = null;
  importPreviewSignalHistory = [];
  importPreviewLastSignalKey = '';
  importPreviewTextLoadToken += 1;
  importPreviewTextLoadedKey = '';
  importPreviewTextContent = '';
  importPreviewTextError = '';
  importPreviewTextSummary = '';
  importPreviewTextLoading = false;
}

function importCancelPdfRenderTask() {
  if (importPreviewPdfRenderTask && typeof importPreviewPdfRenderTask.cancel === 'function') {
    try {
      importPreviewPdfRenderTask.cancel();
    } catch {
    }
  }
  importPreviewPdfRenderTask = null;
}

function importStopPreviewTicker() {
  if (importPreviewTicker) {
    clearInterval(importPreviewTicker);
    importPreviewTicker = null;
  }
}

function importPreviewSyncDom() {
  if (importPreviewPageTotal) {
    const safeTotal = Math.max(1, Math.floor(importPreviewPageTotal));
    importPreviewPageTotal = safeTotal;
    if (importPreviewPageCurrent > safeTotal) {
      importPreviewPageCurrent = safeTotal;
    }
  }
  const current = document.getElementById('import-preview-page-current');
  if (current) current.textContent = String(Math.max(1, importPreviewPageCurrent));
  const total = document.getElementById('import-preview-page-total');
  if (total) total.textContent = importPreviewPageTotal ? String(importPreviewPageTotal) : '...';
}

function importEnsurePreviewObjectUrl(meta) {
  if (!meta || !meta.file) return null;
  const key = importPreviewKey(meta);
  if (!importPreviewUrl || importPreviewObjectKey !== key) {
    importClearPreviewUrl();
    importPreviewUrl = URL.createObjectURL(meta.file);
    importPreviewObjectKey = key;
  }
  return importPreviewUrl;
}

function importResolvePreviewSourceUrl(meta) {
  const objectUrl = importEnsurePreviewObjectUrl(meta);
  if (objectUrl) return objectUrl;
  if (meta && typeof meta.previewUrl === 'string' && meta.previewUrl.trim()) {
    return meta.previewUrl.trim();
  }
  return null;
}

function importPreviewName(meta) {
  if (meta && typeof meta.name === 'string' && meta.name.trim()) return meta.name.trim();
  if (meta && meta.file && typeof meta.file.name === 'string' && meta.file.name.trim()) return meta.file.name.trim();
  return 'document';
}

function importPreviewExtension(meta) {
  return importDropFileExt(importPreviewName(meta));
}

function importPreviewMime(meta) {
  return String(meta?.file?.type || '').trim().toLowerCase();
}

function importPreviewLooksImage(meta) {
  const mime = importPreviewMime(meta);
  if (mime.startsWith('image/')) return true;
  return IMPORT_PREVIEW_IMAGE_EXTENSIONS.has(importPreviewExtension(meta));
}

function importPreviewKey(meta) {
  if (!meta || typeof meta !== 'object') return 'none';
  const file = meta.file;
  if (file) {
    return `file:${file.name || ''}:${file.size || 0}:${file.lastModified || 0}:${file.type || ''}`;
  }
  return `meta:${meta.name || ''}:${meta.path || ''}:${meta.sourceLabel || ''}:${meta.queueJobId || ''}:${meta.previewUrl || ''}`;
}

function importPreviewLooksPdf(meta) {
  const name = importPreviewName(meta);
  return Boolean(
    (meta && meta.file && meta.file.type === 'application/pdf')
    || name.toLowerCase().endsWith('.pdf')
  );
}

function importPreviewLooksText(meta) {
  const mime = importPreviewMime(meta);
  if (mime && (mime.startsWith('text/') || IMPORT_PREVIEW_TEXT_MEDIA.has(mime))) return true;
  return IMPORT_PREVIEW_TEXT_EXTENSIONS.has(importPreviewExtension(meta));
}

function importPreviewKindForMeta(meta) {
  if (importPreviewLooksPdf(meta)) return 'pdf';
  if (importPreviewLooksImage(meta)) return 'image';
  if (importPreviewLooksText(meta)) return 'text';
  return 'binary';
}

function importPreviewTypeLabel(meta) {
  const ext = importPreviewExtension(meta);
  if (ext) return ext.toUpperCase().replace(/^\./, '') + ' file';
  const mime = importPreviewMime(meta);
  if (mime) return mime;
  return 'binary file';
}

function importPreviewAnalyzeText(rawText, opts = {}) {
  const maxChars = Math.max(1000, Number(opts.maxChars || 16000));
  const maxLines = Math.max(20, Number(opts.maxLines || 260));
  const normalized = String(rawText || '').replace(/\u0000/g, ' ').replace(/\r\n?/g, '\n');
  const lines = normalized.split('\n');
  const clippedLines = lines.slice(0, maxLines);
  let clipped = clippedLines.join('\n');
  let truncated = lines.length > maxLines;
  if (clipped.length > maxChars) {
    clipped = clipped.slice(0, maxChars);
    truncated = true;
  }
  const replacementCount = (clipped.match(/\uFFFD/g) || []).length;
  const controlNoise = (clipped.match(/[\u0001-\u0008\u000B\u000C\u000E-\u001F]/g) || []).length;
  const noiseRatio = clipped.length > 0 ? (replacementCount + controlNoise) / clipped.length : 0;
  return {
    text: clipped,
    chars: clipped.length,
    lines: clipped ? clipped.split('\n').length : 0,
    truncated,
    noisy: noiseRatio > 0.045,
  };
}

async function importPreviewReadText(meta, maxBytes = 320000) {
  if (meta?.file && typeof meta.file.slice === 'function') {
    const totalBytes = Number(meta.file.size || 0);
    const blob = meta.file.slice(0, maxBytes);
    const text = await blob.text();
    return {
      text,
      totalBytes,
      loadedBytes: blob.size || text.length,
      source: 'local',
      truncatedByBytes: totalBytes > maxBytes,
    };
  }
  const sourceUrl = importResolvePreviewSourceUrl(meta);
  if (!sourceUrl) {
    throw new Error('No preview source is available for this file.');
  }
  const response = await fetch(sourceUrl, { method: 'GET' });
  if (!response.ok) {
    throw new Error(`HTTP ${response.status} while loading preview.`);
  }
  const blob = await response.blob();
  const totalBytes = Number(blob.size || 0);
  const clipped = blob.slice(0, maxBytes);
  const text = await clipped.text();
  return {
    text,
    totalBytes,
    loadedBytes: clipped.size || text.length,
    source: 'remote',
    truncatedByBytes: totalBytes > maxBytes,
  };
}

function importPreviewRenderTextDom() {
  const body = document.getElementById('import-preview-text-content');
  const summary = document.getElementById('import-preview-text-summary');
  if (!body || !summary) return;
  if (importPreviewTextLoading) {
    summary.textContent = 'Loading text preview...';
    body.textContent = 'Loading text preview...';
    return;
  }
  if (importPreviewTextError) {
    summary.textContent = importPreviewTextSummary || 'Text preview unavailable.';
    body.textContent = importPreviewTextError;
    return;
  }
  summary.textContent = importPreviewTextSummary || 'Text preview';
  body.textContent = importPreviewTextContent || 'No readable text content detected.';
}

async function importEnsureTextPreview(meta) {
  if (importPreviewKind !== 'text') return;
  const key = importPreviewKey(meta);
  if (importPreviewTextLoading && importPreviewTextLoadedKey === key) return;
  if (!importPreviewTextLoading && importPreviewTextLoadedKey === key && (importPreviewTextContent || importPreviewTextError)) {
    importPreviewRenderTextDom();
    return;
  }

  importPreviewTextLoadedKey = key;
  importPreviewTextContent = '';
  importPreviewTextError = '';
  importPreviewTextSummary = '';
  importPreviewTextLoading = true;
  importPreviewRenderTextDom();

  const token = ++importPreviewTextLoadToken;
  try {
    const loaded = await importPreviewReadText(meta);
    const analyzed = importPreviewAnalyzeText(loaded.text, { maxChars: 16000, maxLines: 260 });
    if (analyzed.noisy && !analyzed.text.trim()) {
      throw new Error('This appears to be binary data; inline text preview is unavailable.');
    }
    const sizeText = importFileSizeText(loaded.totalBytes || loaded.loadedBytes || 0);
    const truncText = (analyzed.truncated || loaded.truncatedByBytes) ? '  truncated' : '';
    importPreviewTextSummary = `${sizeText}  ${analyzed.lines} lines${truncText}`;
    importPreviewTextContent = analyzed.text || '';
  } catch (error) {
    importPreviewTextSummary = `Unable to load text for ${importPreviewTypeLabel(meta)}.`;
    importPreviewTextError = String(error || 'Text preview failed.');
  } finally {
    if (token !== importPreviewTextLoadToken) return;
    if (importPreviewTextLoadedKey !== key) return;
    importPreviewTextLoading = false;
    importPreviewRenderTextDom();
  }
}

function importPreviewPageHintFromText(text) {
  if (!text) return null;
  const raw = String(text);
  const candidates = [
    /\bpages?\s*(?:~|=|:)?\s*(\d+)\b/i,
    /\b(\d+)\s*page(?:\(s\)|s)?\b/i,
  ];
  for (const pattern of candidates) {
    const match = pattern.exec(raw);
    if (!match) continue;
    const value = Number(match[1]);
    if (Number.isFinite(value) && value > 0) return Math.floor(value);
  }
  return null;
}

function importPreviewCurrentPageHintFromText(text) {
  if (!text) return null;
  const raw = String(text);
  const patterns = [
    /\bpage\s+(\d+)\s*\/\s*(\d+)\b/i,
    /\bp(?:age)?\s*(\d+)\s+of\s+(\d+)\b/i,
  ];
  for (const pattern of patterns) {
    const match = pattern.exec(raw);
    if (!match) continue;
    const current = Number(match[1]);
    if (Number.isFinite(current) && current > 0) return Math.floor(current);
  }
  return null;
}

function importSafePositiveInt(value) {
  const parsed = Number(value);
  if (!Number.isFinite(parsed) || parsed <= 0) return null;
  return Math.floor(parsed);
}

function importClampCurrentPage(pageCurrent, pageCount = null) {
  const current = importSafePositiveInt(pageCurrent);
  if (!current) return null;
  const total = importSafePositiveInt(pageCount);
  if (total) return Math.max(1, Math.min(current, total));
  return current;
}

function importResolvePageHint(opts = {}) {
  if (Array.isArray(opts.steps)) {
    const preferred = ['extract', 'tables', 'vector', 'archive'];
    for (const id of preferred) {
      const step = opts.steps.find((item) => String(item?.id || '').toLowerCase() === id);
      const preferredCount = importSafePositiveInt(step?.page_count);
      if (preferredCount) return preferredCount;
    }
    let fallbackBest = 0;
    opts.steps.forEach((step) => {
      const value = importSafePositiveInt(step?.page_count);
      if (!value) return;
      fallbackBest = Math.max(fallbackBest, value);
    });
    if (fallbackBest > 0) return fallbackBest;
  }
  const texts = [];
  if (opts.statusLine) texts.push(String(opts.statusLine));
  if (opts.countersLine) texts.push(String(opts.countersLine));
  if (Array.isArray(opts.steps)) {
    const extractStep = opts.steps.find((step) => String(step.id || '').toLowerCase() === 'extract')
      || opts.steps.find((step) => String(step.label || '').toLowerCase().includes('text'));
    if (extractStep) {
      if (extractStep.detail) texts.push(String(extractStep.detail));
      if (extractStep.stats) texts.push(String(extractStep.stats));
    }
  }
  let best = 0;
  texts.forEach((text) => {
    const hint = importPreviewPageHintFromText(text);
    if (hint && hint > best) best = hint;
  });
  return best > 0 ? best : null;
}

function importResolveCurrentPageHint(opts = {}) {
  if (Array.isArray(opts.steps)) {
    const preferred = ['extract', 'tables', 'vector', 'archive'];
    for (const id of preferred) {
      const step = opts.steps.find((item) => String(item?.id || '').toLowerCase() === id);
      const current = importClampCurrentPage(
        step?.page_current ?? step?.current_page,
        step?.page_count,
      );
      if (current) return current;
    }
    let fallbackBest = 0;
    opts.steps.forEach((step) => {
      const current = importClampCurrentPage(
        step?.page_current ?? step?.current_page,
        step?.page_count,
      );
      if (!current) return;
      fallbackBest = Math.max(fallbackBest, current);
    });
    if (fallbackBest > 0) return fallbackBest;
  }
  const texts = [];
  if (opts.statusLine) texts.push(String(opts.statusLine));
  if (opts.countersLine) texts.push(String(opts.countersLine));
  if (Array.isArray(opts.steps)) {
    const extractStep = opts.steps.find((step) => String(step.id || '').toLowerCase() === 'extract')
      || opts.steps.find((step) => String(step.label || '').toLowerCase().includes('text'));
    if (extractStep) {
      if (extractStep.detail) texts.push(String(extractStep.detail));
      if (extractStep.stats) texts.push(String(extractStep.stats));
    }
  }
  let best = 0;
  texts.forEach((text) => {
    const hint = importPreviewCurrentPageHintFromText(text);
    if (hint && hint > best) best = hint;
  });
  return best > 0 ? best : null;
}

function importNormalizePreviewSignal(raw) {
  if (!raw || typeof raw !== 'object') return null;
  const signal = {};
  const kind = String(raw.kind || '').trim().toLowerCase();
  if (kind) signal.kind = kind;
  const label = String(raw.label || '').trim();
  if (label) signal.label = label.slice(0, 160);
  const text = String(raw.text || '').trim();
  if (text) signal.text = text.slice(0, 420);

  const pageCount = importSafePositiveInt(raw.page_count);
  if (pageCount) signal.page_count = pageCount;
  const pageCurrent = importClampCurrentPage(raw.page_current ?? raw.current_page, pageCount);
  if (pageCurrent) signal.page_current = pageCurrent;

  const bboxRaw = raw.bbox;
  if (bboxRaw && typeof bboxRaw === 'object') {
    const x0 = Number(bboxRaw.x0);
    const y0 = Number(bboxRaw.y0);
    const x1 = Number(bboxRaw.x1);
    const y1 = Number(bboxRaw.y1);
    if ([x0, y0, x1, y1].every((v) => Number.isFinite(v))) {
      signal.bbox = {
        x0: Math.min(x0, x1),
        y0: Math.min(y0, y1),
        x1: Math.max(x0, x1),
        y1: Math.max(y0, y1),
      };
    }
  }
  return Object.keys(signal).length ? signal : null;
}

function importSignalHistoryKey(signal) {
  if (!signal) return '';
  const kind = String(signal.kind || '');
  const label = String(signal.label || '');
  const page = String(signal.page_current || '');
  const text = String(signal.text || '');
  const bbox = signal.bbox
    ? `${signal.bbox.x0},${signal.bbox.y0},${signal.bbox.x1},${signal.bbox.y1}`
    : '';
  return `${kind}|${label}|${page}|${text}|${bbox}`;
}

function importResolveLivePreviewSignal(opts = {}) {
  if (!Array.isArray(opts.steps)) return null;
  const preferred = ['extract', 'tables', 'vector', 'archive'];
  for (const id of preferred) {
    const step = opts.steps.find((item) => String(item?.id || '').toLowerCase() === id);
    const normalized = importNormalizePreviewSignal(step?.preview);
    if (normalized) return normalized;
  }
  for (const step of opts.steps) {
    const normalized = importNormalizePreviewSignal(step?.preview);
    if (normalized) return normalized;
  }
  return null;
}

function importPreviewRenderSignalDom() {
  const container = document.getElementById('import-preview-live-signal');
  if (!container) return;
  if (!importPreviewSignalHistory.length) {
    container.innerHTML = `
      <p class="import-preview-live-signal-head">Live Parser Signal</p>
      <p class="small">Waiting for structured extraction details...</p>
    `;
    return;
  }
  const rows = importPreviewSignalHistory
    .slice(0, 4)
    .map((signal) => {
      const kind = String(signal.kind || 'signal');
      const label = String(signal.label || '');
      const pageCount = importSafePositiveInt(signal.page_count);
      const pageCurrent = importClampCurrentPage(signal.page_current, pageCount);
      const pageText = pageCurrent
        ? `Page ${pageCurrent}${pageCount ? `/${pageCount}` : ''}`
        : '';
      const metaBits = [kind, label, pageText].filter((part) => part && String(part).trim());
      const text = String(signal.text || '');
      const meta = metaBits.length ? `<span class="muted">${dbEscapeHtml(metaBits.join('  '))}</span>` : '';
      const body = text ? `<br />${dbEscapeHtml(text)}` : '';
      return `<p class="import-preview-live-signal-item">${meta}${body}</p>`;
    })
    .join('');
  container.innerHTML = `
    <p class="import-preview-live-signal-head">Live Parser Signal</p>
    <div class="import-preview-live-signal-list">${rows}</div>
  `;
}

function importRectForCanvas(bbox, canvasWidth, canvasHeight) {
  const b = viewerExtractBBox(bbox);
  if (!b) return null;
  const maxValue = Math.max(Math.abs(b.x0), Math.abs(b.y0), Math.abs(b.x1), Math.abs(b.y1));
  const isNormalized = maxValue <= 1.5;
  let x0 = b.x0;
  let y0 = b.y0;
  let x1 = b.x1;
  let y1 = b.y1;
  if (isNormalized) {
    x0 *= canvasWidth;
    x1 *= canvasWidth;
    y0 *= canvasHeight;
    y1 *= canvasHeight;
  } else {
    const baseW = importPreviewPageBaseWidth || canvasWidth || 1;
    const baseH = importPreviewPageBaseHeight || canvasHeight || 1;
    const scaleX = canvasWidth / baseW;
    const scaleY = canvasHeight / baseH;
    x0 *= scaleX;
    x1 *= scaleX;
    y0 *= scaleY;
    y1 *= scaleY;
  }
  if (viewerBBoxUsesBottomLeft(bbox)) {
    const nextY0 = canvasHeight - y1;
    const nextY1 = canvasHeight - y0;
    y0 = nextY0;
    y1 = nextY1;
  }
  return {
    x: Math.min(x0, x1),
    y: Math.min(y0, y1),
    width: Math.max(1, Math.abs(x1 - x0)),
    height: Math.max(1, Math.abs(y1 - y0)),
  };
}

function importPreviewRenderOverlay() {
  const baseCanvas = document.getElementById('import-preview-pdf-canvas');
  const overlay = document.getElementById('import-preview-pdf-overlay');
  if (!baseCanvas || !overlay) return;
  const ctx = overlay.getContext('2d');
  if (!ctx) return;
  if (overlay.width !== baseCanvas.width || overlay.height !== baseCanvas.height) {
    overlay.width = baseCanvas.width;
    overlay.height = baseCanvas.height;
    overlay.style.width = baseCanvas.style.width;
    overlay.style.height = baseCanvas.style.height;
  }
  ctx.clearRect(0, 0, overlay.width, overlay.height);

  if (!importPreviewSignalHistory.length) return;
  const signal = importPreviewSignalHistory[0];
  if (!signal || !signal.bbox) return;
  const signalPage = importClampCurrentPage(
    signal.page_current,
    signal.page_count || importPreviewPageTotal,
  );
  if (signalPage && signalPage !== Math.floor(importPreviewPageCurrent)) {
    return;
  }
  const rect = importRectForCanvas(signal.bbox, overlay.width, overlay.height);
  if (!rect) return;

  const palette = String(signal.kind || '').toLowerCase() === 'table'
    ? { stroke: '#22c55e', fill: 'rgba(34, 197, 94, 0.16)' }
    : (String(signal.kind || '').toLowerCase() === 'annotation'
      ? { stroke: '#f59e0b', fill: 'rgba(245, 158, 11, 0.16)' }
      : { stroke: '#60a5fa', fill: 'rgba(96, 165, 250, 0.16)' });
  ctx.strokeStyle = palette.stroke;
  ctx.fillStyle = palette.fill;
  ctx.lineWidth = 2;
  ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
  ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
}

function importResolveProgressEstimatedPage(opts = {}) {
  if (!importPreviewPageTotal || !Array.isArray(opts.steps)) return null;
  const extractStep = opts.steps.find((step) => String(step.id || '').toLowerCase() === 'extract')
    || opts.steps.find((step) => String(step.label || '').toLowerCase().includes('text'));
  if (!extractStep) return null;
  const raw = Number(extractStep.progress);
  if (!Number.isFinite(raw)) return null;
  // Parse heartbeat emits extract progress in ~[4..55] while parsing pages;
  // map that band to [0..1] so preview page does not plateau at ~94%.
  const normalized = Math.max(0, Math.min(1, (raw - 4) / 51));
  const projected = Math.floor(importPreviewPageTotal * normalized);
  return Math.max(1, Math.min(importPreviewPageTotal, projected || 1));
}

async function importPreviewRenderCurrentPage(force = false) {
  if (importPreviewKind !== 'pdf') return;
  if (!importPreviewPdfDoc) return;
  const canvas = document.getElementById('import-preview-pdf-canvas');
  const placeholder = document.getElementById('import-preview-pdf-placeholder');
  if (!canvas) return;
  const totalPages = Math.max(1, Number(importPreviewPdfDoc.numPages || importPreviewPageTotal || 1));
  const targetPage = Math.max(1, Math.min(totalPages, Math.floor(importPreviewPageCurrent || 1)));
  if (!force && importPreviewLastRenderedPage === targetPage) {
    importPreviewRenderOverlay();
    return;
  }
  const renderToken = ++importPreviewPdfRenderToken;
  importCancelPdfRenderTask();
  try {
    const page = await importPreviewPdfDoc.getPage(targetPage);
    if (renderToken !== importPreviewPdfRenderToken) return;
    const baseViewport = page.getViewport({ scale: 1.0 });
    importPreviewPageBaseWidth = Math.max(1, Number(baseViewport.width || 1));
    importPreviewPageBaseHeight = Math.max(1, Number(baseViewport.height || 1));
    const maxWidth = 286;
    const maxHeight = 320;
    const scale = Math.max(0.12, Math.min(2.2, Math.min(maxWidth / baseViewport.width, maxHeight / baseViewport.height)));
    const viewport = page.getViewport({ scale });
    const scratch = document.createElement('canvas');
    scratch.width = Math.max(1, Math.floor(viewport.width));
    scratch.height = Math.max(1, Math.floor(viewport.height));
    const scratchCtx = scratch.getContext('2d', { alpha: false });
    if (!scratchCtx) return;
    const renderTask = page.render({ canvasContext: scratchCtx, viewport });
    importPreviewPdfRenderTask = renderTask;
    await renderTask.promise;
    if (importPreviewPdfRenderTask === renderTask) {
      importPreviewPdfRenderTask = null;
    }
    if (renderToken !== importPreviewPdfRenderToken) return;
    const ctx = canvas.getContext('2d', { alpha: false });
    if (!ctx) return;
    if (canvas.width !== scratch.width || canvas.height !== scratch.height) {
      canvas.width = scratch.width;
      canvas.height = scratch.height;
      canvas.style.width = `${scratch.width}px`;
      canvas.style.height = `${scratch.height}px`;
      const overlay = document.getElementById('import-preview-pdf-overlay');
      if (overlay) {
        overlay.width = scratch.width;
        overlay.height = scratch.height;
        overlay.style.width = `${scratch.width}px`;
        overlay.style.height = `${scratch.height}px`;
      }
    }
    ctx.drawImage(scratch, 0, 0);
    importPreviewLastRenderedPage = targetPage;
    importPreviewRenderOverlay();
    if (placeholder) placeholder.style.display = 'none';
  } catch (error) {
    const message = String(error || '');
    const cancelled = (
      String(error?.name || '').toLowerCase() === 'renderingcancelledexception'
      || /cancel/i.test(message)
      || /same canvas/i.test(message)
    );
    if (cancelled) return;
    if (placeholder) {
      placeholder.style.display = 'block';
      placeholder.textContent = `Preview unavailable (${message})`;
    }
  } finally {
    if (importPreviewPdfRenderTask && renderToken !== importPreviewPdfRenderToken) {
      importCancelPdfRenderTask();
    }
  }
}

async function importEnsurePdfPreviewDocument(meta) {
  if (importPreviewKind !== 'pdf') return null;
  const sourceUrl = importResolvePreviewSourceUrl(meta);
  if (!sourceUrl) return null;
  if (importPreviewPdfDoc && importPreviewPdfSourceUrl === sourceUrl) {
    if (importPreviewPageTotal) importPreviewSyncDom();
    return importPreviewPdfDoc;
  }
  importPreviewPdfSourceUrl = sourceUrl;
  importPreviewLastRenderedPage = null;
  importCancelPdfRenderTask();
  const loadToken = ++importPreviewPdfLoadToken;
  const placeholder = document.getElementById('import-preview-pdf-placeholder');
  if (placeholder) {
    placeholder.style.display = 'block';
    placeholder.textContent = 'Loading PDF preview...';
  }
  try {
    const pdfjs = await viewerEnsurePdfJs();
    const loadingTask = pdfjs.getDocument(sourceUrl);
    const doc = await loadingTask.promise;
    if (loadToken !== importPreviewPdfLoadToken) {
      if (typeof doc.destroy === 'function') {
        try {
          doc.destroy();
        } catch {
        }
      }
      return null;
    }
    if (importPreviewPdfDoc && typeof importPreviewPdfDoc.destroy === 'function') {
      try {
        importPreviewPdfDoc.destroy();
      } catch {
      }
    }
    importPreviewPdfDoc = doc;
    const totalPages = Math.max(1, Number(doc.numPages || 1));
    importPreviewPageTotal = Math.max(importPreviewPageTotal || 0, totalPages);
    if (importPreviewPageCurrent > importPreviewPageTotal) {
      importPreviewPageCurrent = importPreviewPageTotal;
    }
    importPreviewSyncDom();
    await importPreviewRenderCurrentPage(true);
    return doc;
  } catch (error) {
    importPreviewPdfDoc = null;
    if (placeholder) {
      placeholder.style.display = 'block';
      placeholder.textContent = `Preview unavailable (${String(error)})`;
    }
    return null;
  }
}

function importEnsurePreviewTicker() {
  if (importPreviewTicker) return;
  importPreviewTicker = setInterval(() => {
    if (!importPreviewProcessing || importPreviewKind !== 'pdf') return;
    const cap = importPreviewPageTotal || 999;
    if (importPreviewPageCurrent < cap) {
      importPreviewPageCurrent += 1;
      importPreviewSyncDom();
      importPreviewRenderCurrentPage();
    }
  }, 760);
}

function importPreparePreview(meta, opts = {}) {
  const key = importPreviewKey(meta);
  const nextKind = importPreviewKindForMeta(meta);

  if (key !== importPreviewMetaKey) {
    importPreviewMetaKey = key;
    importPreviewPageCurrent = 1;
    importPreviewPageTotal = null;
    importPreviewKind = nextKind;
    importPreviewProcessing = false;
    importPreviewSignalHistory = [];
    importPreviewLastSignalKey = '';
    importStopPreviewTicker();
    const hasLocalFile = Boolean(meta && meta.file);
    if (!hasLocalFile) {
      importClearPreviewUrl();
    }
    if (hasLocalFile && (nextKind === 'image' || nextKind === 'pdf' || nextKind === 'text')) {
      importEnsurePreviewObjectUrl(meta);
    }
  } else {
    importPreviewKind = nextKind;
  }

  const pageHint = importResolvePageHint(opts);
  if (pageHint) {
    importPreviewPageTotal = Math.max(importPreviewPageTotal || 0, pageHint);
  }
  const currentHint = importResolveCurrentPageHint(opts);
  const normalizedCurrentHint = importClampCurrentPage(currentHint, importPreviewPageTotal);
  if (normalizedCurrentHint) {
    importPreviewPageCurrent = normalizedCurrentHint;
  }

  const liveSignal = importResolveLivePreviewSignal(opts);
  if (liveSignal) {
    const livePageCount = importSafePositiveInt(liveSignal.page_count);
    if (livePageCount) {
      importPreviewPageTotal = Math.max(importPreviewPageTotal || 0, livePageCount);
    }
    const livePageCurrent = importClampCurrentPage(
      liveSignal.page_current,
      importPreviewPageTotal || livePageCount,
    );
    if (livePageCurrent) {
      importPreviewPageCurrent = livePageCurrent;
    }
    const signalKey = importSignalHistoryKey(liveSignal);
    if (signalKey && signalKey !== importPreviewLastSignalKey) {
      importPreviewSignalHistory.unshift(liveSignal);
      if (importPreviewSignalHistory.length > 8) importPreviewSignalHistory.length = 8;
      importPreviewLastSignalKey = signalKey;
    }
  }
  importPreviewRenderSignalDom();

  importPreviewProcessing = Boolean(opts.progressActive);
  if (importPreviewKind === 'pdf') {
    const hasPreviewSource = Boolean(importResolvePreviewSourceUrl(meta));
    const projected = importResolveProgressEstimatedPage(opts);
    if (projected) {
      importPreviewPageCurrent = Math.max(importPreviewPageCurrent, projected);
    }
    if (importPreviewProcessing) {
      if (projected || !hasPreviewSource || !importPreviewPageTotal) {
        importStopPreviewTicker();
      } else {
        importEnsurePreviewTicker();
      }
    } else {
      importStopPreviewTicker();
      if (importPreviewPageTotal) importPreviewPageCurrent = importPreviewPageTotal;
    }
    importPreviewSyncDom();
    importEnsurePdfPreviewDocument(meta).then(() => {
      importPreviewRenderCurrentPage();
      importPreviewRenderOverlay();
    });
  } else {
    importStopPreviewTicker();
    if (importPreviewKind === 'image' || importPreviewKind === 'text') {
      importEnsurePreviewObjectUrl(meta);
    }
    if (importPreviewKind === 'text') {
      importEnsureTextPreview(meta);
    }
    importPreviewRenderOverlay();
  }
}

function importPreviewFileMetaMarkup(meta) {
  const name = dbEscapeHtml(importPreviewName(meta));
  const typeLabel = dbEscapeHtml(importPreviewTypeLabel(meta));
  const mime = dbEscapeHtml(importPreviewMime(meta) || 'unknown');
  const sizeBytes = Number(meta?.file?.size || meta?.sizeBytes || 0);
  const sizeLabel = dbEscapeHtml(importFileSizeText(sizeBytes));
  return `
    <div class="import-preview-file-meta">
      <p><strong>${name}</strong></p>
      <p>Type: ${typeLabel}</p>
      <p>MIME: ${mime}</p>
      <p>Size: ${sizeLabel}</p>
    </div>
  `;
}

function importPreviewMarkup(meta, opts = {}) {
  if (importPreviewKind === 'image') {
    importEnsurePreviewObjectUrl(meta);
    return `<img src="${importPreviewUrl}" alt="${dbEscapeHtml(importPreviewName(meta) || 'import file')}" />`;
  }

  if (importPreviewKind === 'pdf') {
    const title = dbEscapeHtml(importPreviewName(meta) || 'Document');
    const hasPdfSource = Boolean(importResolvePreviewSourceUrl(meta));
    if (!hasPdfSource) {
      return `
        <div class="import-preview-pdf">
          <div class="import-preview-pdf-canvas-wrap">
            <div class="import-preview-pdf-placeholder" style="position: static; background: transparent;">Live page preview source is unavailable for this item.</div>
          </div>
          <p class="import-preview-pdf-title">${title}</p>
          <p class="import-preview-caption">Page <span id="import-preview-page-current">${Math.max(1, importPreviewPageCurrent)}</span> / <span id="import-preview-page-total">${importPreviewPageTotal ? String(importPreviewPageTotal) : '...'}</span></p>
          <div id="import-preview-live-signal" class="import-preview-live-signal">
            <p class="import-preview-live-signal-head">Live Parser Signal</p>
            <p class="small">Waiting for structured extraction details...</p>
          </div>
        </div>
      `;
    }
    const state = importPreviewProcessing ? 'processing' : 'idle';
    return `
      <div class="import-preview-pdf ${state}">
        <div class="import-preview-pdf-canvas-wrap">
          <canvas id="import-preview-pdf-canvas" class="import-preview-pdf-canvas" role="img" aria-label="Current PDF page preview"></canvas>
          <canvas id="import-preview-pdf-overlay" class="import-preview-pdf-overlay" aria-hidden="true"></canvas>
          <div id="import-preview-pdf-placeholder" class="import-preview-pdf-placeholder">Loading PDF preview...</div>
        </div>
        <p class="import-preview-pdf-title">${title}</p>
        <p class="import-preview-caption">Page <span id="import-preview-page-current">${Math.max(1, importPreviewPageCurrent)}</span> / <span id="import-preview-page-total">${importPreviewPageTotal ? String(importPreviewPageTotal) : '...'}</span></p>
        <div id="import-preview-live-signal" class="import-preview-live-signal">
          <p class="import-preview-live-signal-head">Live Parser Signal</p>
          <p class="small">Waiting for structured extraction details...</p>
        </div>
      </div>
    `;
  }

  if (importPreviewKind === 'text') {
    return `
      <div class="import-preview-text">
        ${importPreviewFileMetaMarkup(meta)}
        <p id="import-preview-text-summary" class="import-preview-caption">Loading text preview...</p>
        <pre id="import-preview-text-content" class="import-preview-text-content">Loading text preview...</pre>
        <div id="import-preview-live-signal" class="import-preview-live-signal">
          <p class="import-preview-live-signal-head">Live Parser Signal</p>
          <p class="small">Waiting for structured extraction details...</p>
        </div>
      </div>
    `;
  }

  const sourceUrl = importResolvePreviewSourceUrl(meta);
  const openLink = sourceUrl
    ? `<p class="small"><a href="${dbEscapeHtml(sourceUrl)}" target="_blank" rel="noopener">Open file in new tab</a></p>`
    : '<p class="small muted">No preview source is available for this file.</p>';
  return `
    <div class="import-preview-generic">
      ${importPreviewFileMetaMarkup(meta)}
      <p class="import-preview-caption">Inline preview is unavailable for this file type.</p>
      <div class="import-preview-generic-embed">
        <div class="import-preview-generic-empty">To prevent browser download errors, this file is not auto-loaded during import.</div>
      </div>
      ${openLink}
      <div id="import-preview-live-signal" class="import-preview-live-signal">
        <p class="import-preview-live-signal-head">Live Parser Signal</p>
        <p class="small">Waiting for structured extraction details...</p>
      </div>
    </div>
  `;
}

function importStepHtml(stepState) {
  const state = stepState.state || 'pending';
  const detail = stepState.detail ? dbEscapeHtml(stepState.detail) : '';
  const stats = stepState.stats ? `  ${dbEscapeHtml(stepState.stats)}` : '';
  const progressRaw = Number(stepState.progress);
  const progress = Number.isFinite(progressRaw)
    ? Math.max(0, Math.min(100, progressRaw))
    : (state === 'pending' ? 0 : 100);
  return `
    <div class="import-step ${state}">
      <div class="import-step-head">
        <strong>${dbEscapeHtml(stepState.label)}</strong>
        <span class="step-badge">${dbEscapeHtml(state)}</span>
      </div>
      <div class="step-progress-track">
        <div class="step-progress-bar ${state === 'active' ? 'active' : ''}" style="width:${progress}%"></div>
      </div>
      <p class="import-step-detail">${detail}${stats}</p>
    </div>
  `;
}

function importQueueStatusLabel(status) {
  const normalized = String(status || '').toLowerCase();
  if (normalized === 'processing') return 'processing';
  if (normalized === 'done') return 'done';
  if (normalized === 'failed') return 'failed';
  if (normalized === 'skipped') return 'skipped';
  if (normalized === 'cancelled') return 'cancelled';
  return 'pending';
}

function importQueueStatusTone(status) {
  const normalized = String(status || '').toLowerCase();
  if (normalized === 'processing') return 'warning';
  if (normalized === 'done') return 'ok';
  if (normalized === 'failed') return 'error';
  if (normalized === 'skipped') return 'warning';
  if (normalized === 'cancelled') return 'neutral';
  return 'neutral';
}

function importCanControlQueueItem(item, action) {
  if (!item || !item.id) return false;
  const normalizedAction = String(action || '').toLowerCase();
  if (normalizedAction !== 'skip' && normalizedAction !== 'kill') return false;
  const status = importQueueStatusLabel(item.status);
  if (status !== 'pending' && status !== 'processing') return false;
  const requested = Boolean(item.cancelRequested);
  const requestedAction = String(item.cancelAction || '').toLowerCase();
  if (requested && requestedAction === normalizedAction) return false;
  if (requested && requestedAction === 'kill') return false;
  const key = `${item.id}:${normalizedAction}`;
  return !importQueueControlInFlight.has(key);
}

async function importQueueControlAction(jobId, action) {
  const safeJobId = String(jobId || '').trim();
  const safeAction = String(action || '').trim().toLowerCase();
  if (!safeJobId || (safeAction !== 'skip' && safeAction !== 'kill')) return;
  const key = `${safeJobId}:${safeAction}`;
  if (importQueueControlInFlight.has(key)) return;
  importQueueControlInFlight.add(key);
  importRenderDropQueue();
  try {
    const payload = await callApi(
      'POST',
      `/api/import/queue/jobs/${encodeURIComponent(safeJobId)}/control`,
      { action: safeAction },
      null
    );
    if (!payload?.ok) {
      const summary = String(payload?.detail || payload?.error || `Unable to ${safeAction} import job.`);
      importAddHistory({
        statusTone: 'error',
        statusLabel: 'failed',
        name: safeJobId.slice(0, 8),
        summary,
      });
    }
  } catch (err) {
    importAddHistory({
      statusTone: 'error',
      statusLabel: 'failed',
      name: safeJobId.slice(0, 8),
      summary: String(err || `Unable to ${safeAction} import job.`),
    });
  } finally {
    importQueueControlInFlight.delete(key);
    await importRefreshServerQueue(true);
  }
}

function importRenderDropQueue() {
  const el = document.getElementById('import-drop-queue');
  if (!el) return;
  if (!importDropQueue.length) {
    el.innerHTML = '<p class="small">No files queued.</p>';
    return;
  }

  const pendingCount = importDropQueue.filter((item) => item.status === 'pending').length;
  const processingCount = importDropQueue.filter((item) => item.status === 'processing').length;
  const doneCount = importDropQueue.filter((item) => item.status === 'done').length;
  const failedCount = importDropQueue.filter((item) => item.status === 'failed').length;
  const skippedCount = importDropQueue.filter((item) => item.status === 'skipped').length;
  const cancelledCount = importDropQueue.filter((item) => item.status === 'cancelled').length;
  const queueEtaMs = importQueueRemainingEtaMs();
  const queueEtaText = (pendingCount + processingCount) > 0
    ? `  ETA ${importFormatEtaDuration(queueEtaMs)} remaining`
    : '';

  const itemsHtml = importDropQueue
    .map((item, idx) => {
      const status = importQueueStatusLabel(item.status);
      const tone = importQueueStatusTone(status);
      const position = idx + 1;
      const currentBadge = status === 'processing' ? '  current' : '';
      const canSkip = importCanControlQueueItem(item, 'skip');
      const canKill = importCanControlQueueItem(item, 'kill');
      const controlHtml = (status === 'pending' || status === 'processing')
        ? `
          <div class="import-queue-actions">
            <button
              type="button"
              class="import-queue-action-btn"
              onclick="importQueueControlAction(${JSON.stringify(String(item.id || ''))}, 'skip')"
              ${canSkip ? '' : 'disabled'}
            >Skip</button>
            <button
              type="button"
              class="import-queue-action-btn"
              onclick="importQueueControlAction(${JSON.stringify(String(item.id || ''))}, 'kill')"
              ${canKill ? '' : 'disabled'}
            >Kill</button>
          </div>
        `
        : '';
      return `
        <article class="import-queue-item ${status}">
          <h4 class="import-queue-item-head">
            <span>${position}. ${dbEscapeHtml(item.name || 'document')}</span>
            <span class="status-pill ${statusClass(tone)}">${dbEscapeHtml(titleCase(status))}${dbEscapeHtml(currentBadge)}</span>
          </h4>
          <p class="import-queue-item-meta">${dbEscapeHtml(importFileSizeText(item.sizeBytes ?? 0))}</p>
          <p class="import-queue-item-detail">${dbEscapeHtml(item.detail || '')}</p>
          ${controlHtml}
        </article>
      `;
    })
    .join('');

  el.innerHTML = `
    <p class="import-queue-head">Queue: ${importDropQueue.length} total  ${pendingCount} pending  ${processingCount} processing  ${doneCount} done  ${failedCount} failed  ${skippedCount} skipped  ${cancelledCount} cancelled${queueEtaText}</p>
    ${itemsHtml}
  `;
}

function importRenderHistory() {
  const el = document.getElementById('import-history');
  if (!el) return;
  if (!importHistoryItems.length) {
    el.innerHTML = '<p class="small">No imports yet.</p>';
    return;
  }
  el.innerHTML = importHistoryItems
    .map((item) => `
      <article class="import-history-item">
        <h4><span class="status-pill ${statusClass(item.statusTone || 'neutral')}">${dbEscapeHtml(item.statusLabel || 'unknown')}</span>${dbEscapeHtml(item.name || 'document')}</h4>
        <p>${dbEscapeHtml(item.summary || '')}</p>
      </article>
    `)
    .join('');
}

function importAddHistory(item) {
  importHistoryItems.unshift(item);
  if (importHistoryItems.length > 12) importHistoryItems.length = 12;
  importRenderHistory();
}

function importStopTimers() {
  if (importProgressTimer) {
    clearInterval(importProgressTimer);
    importProgressTimer = null;
  }
  if (importCounterTimer) {
    clearInterval(importCounterTimer);
    importCounterTimer = null;
  }
  importPreviewProcessing = false;
  importStopPreviewTicker();
}

function importSetProgress(value, active = false) {
  const bar = document.getElementById('import-progress-bar');
  if (!bar) return;
  bar.style.width = `${Math.max(0, Math.min(100, value))}%`;
  bar.classList.toggle('active', active);
}

function importRenderLive(meta, opts = {}) {
  const live = document.getElementById('import-live');
  if (!live) return;
  live.classList.remove('empty');
  importPreparePreview(meta, opts);
  const previewKey = importPreviewKey(meta);
  const previewKind = importPreviewKind;
  const canReusePreview = (
    live.getAttribute('data-preview-key') === previewKey
    && live.getAttribute('data-preview-kind') === previewKind
    && Boolean(live.querySelector('[data-import-preview-host]'))
  );

  const stepHtml = Array.isArray(opts.steps) ? opts.steps.map(importStepHtml).join('') : '';
  const metricHtml = Array.isArray(opts.metrics)
    ? opts.metrics
        .map((m) => `
          <div class="import-metric">
            <p class="k">${dbEscapeHtml(m.k || '')}</p>
            <p class="v">${dbEscapeHtml(String(m.v ?? ''))}</p>
          </div>
        `)
        .join('')
    : '';
  const actionsHtml = opts.actionsHtml || '';

  const bodyHtml = `
    <h4 class="import-title">${dbEscapeHtml(opts.title || meta.name || 'Import Job')}</h4>
    <p class="import-meta">${dbEscapeHtml(opts.meta || '')}</p>
    <div class="import-progress-track">
      <div id="import-progress-bar" class="import-progress-bar"></div>
    </div>
    <p id="import-status-line" class="import-status-line">${dbEscapeHtml(opts.statusLine || '')}</p>
    <p id="import-counters" class="import-counters">${dbEscapeHtml(opts.countersLine || '')}</p>
    <div class="import-steps">${stepHtml}</div>
    <div class="import-metrics">${metricHtml}</div>
    ${actionsHtml}
  `;

  if (!canReusePreview) {
    live.innerHTML = `
      <div class="import-preview" data-import-preview-host>${importPreviewMarkup(meta, opts)}</div>
      <div data-import-live-body>${bodyHtml}</div>
    `;
  } else {
    const body = live.querySelector('[data-import-live-body]');
    if (body) body.innerHTML = bodyHtml;
  }
  live.setAttribute('data-preview-key', previewKey);
  live.setAttribute('data-preview-kind', previewKind);
  importSetProgress(opts.progress ?? 0, Boolean(opts.progressActive));
  importPreviewSyncDom();
  importPreviewRenderSignalDom();
  if (importPreviewKind === 'pdf') {
    importPreviewRenderCurrentPage();
    importPreviewRenderOverlay();
  } else if (importPreviewKind === 'text') {
    importPreviewRenderTextDom();
  }
}

function importStartAnimatedJob(meta) {
  importStopTimers();
  importProgressValue = 5;
  navSetPaneActivity('ingest', {
    active: true,
    percent: importProgressValue,
    indeterminate: false,
    title: `Import ${Math.round(importProgressValue)}%`,
  });
  const est = {
    pages: 0,
    words: 0,
    sentences: 0,
    paragraphs: 0,
    tables: 0,
    rows: 0,
    chunks: 0,
  };
  const stepProgress = {
    archive: 6,
    extract: 2,
    tables: 1,
    vector: 1,
  };
  const startMs = Date.now();
  const startedAt = new Date().toLocaleTimeString();
  importRenderLive(meta, {
    title: meta.name || 'Import Job',
    meta: `${meta.sourceLabel || 'Import'}  started ${startedAt}`,
    statusLine: 'Uploading and deduplicating document...',
    countersLine: 'Initializing parser and extraction pipeline...',
    steps: IMPORT_STEPS.map((s, idx) => ({ ...s, state: idx === 0 ? 'active' : 'pending', progress: idx === 0 ? 8 : 0 })),
    progress: importProgressValue,
    progressActive: true,
  });

  importProgressTimer = setInterval(() => {
    stepProgress.archive = Math.min(98, stepProgress.archive + (Math.random() * 5.8 + 2.4));
    stepProgress.extract = Math.min(96, stepProgress.extract + (Math.random() * 4.9 + 1.6));
    stepProgress.tables = Math.min(95, stepProgress.tables + (Math.random() * 3.8 + 1.2));
    if (stepProgress.extract > 18 || stepProgress.tables > 14) {
      stepProgress.vector = Math.min(94, stepProgress.vector + (Math.random() * 3.9 + 1.1));
    } else {
      stepProgress.vector = Math.min(20, stepProgress.vector + (Math.random() * 1.1));
    }

    importProgressValue = Math.min(
      92,
      (stepProgress.archive * 0.18)
      + (stepProgress.extract * 0.34)
      + (stepProgress.tables * 0.22)
      + (stepProgress.vector * 0.26)
    );

    const stageLabel = `Archive ${Math.floor(stepProgress.archive)}%  Text ${Math.floor(stepProgress.extract)}%  Tables ${Math.floor(stepProgress.tables)}%  Vectors ${Math.floor(stepProgress.vector)}%`;
    const stepStates = IMPORT_STEPS.map((s, idx) => ({
      ...s,
      state: (idx === 0 ? stepProgress.archive : (idx === 1 ? stepProgress.extract : (idx === 2 ? stepProgress.tables : stepProgress.vector))) >= 94
        ? 'done'
        : 'active',
      progress: idx === 0
        ? stepProgress.archive
        : (idx === 1 ? stepProgress.extract : (idx === 2 ? stepProgress.tables : stepProgress.vector)),
      detail: idx === 0
        ? 'Hashing, dedupe check, immutable archive write.'
        : (idx === 1
          ? 'Reading pages and parsing canonical text.'
          : (idx === 2
            ? 'Building table structures and annotations.'
            : 'Embedding chunks and updating vector store.')),
      stats: idx === 1
        ? `~${est.pages} pages  ~${est.words} words  ~${est.sentences} sentences  ~${est.paragraphs} paragraphs`
        : (idx === 2
          ? `~${est.tables} tables  ~${est.rows} rows`
          : (idx === 3 ? `~${est.chunks} chunks` : '')),
    }));
    const status = document.getElementById('import-status-line');
    if (status) status.textContent = `Running extraction, Docling structure parsing, and vector indexing by default. ${stageLabel}`;
    const counters = document.getElementById('import-counters');
    if (counters) {
      const elapsed = ((Date.now() - startMs) / 1000).toFixed(1);
      counters.textContent = `Elapsed ${elapsed}s  Pages ~${est.pages}  Words ~${est.words}  Sentences ~${est.sentences}  Paragraphs ~${est.paragraphs}  Tables ~${est.tables}  Rows ~${est.rows}  Vector chunks ~${est.chunks}`;
    }
    const steps = document.querySelector('#import-live .import-steps');
    if (steps) steps.innerHTML = stepStates.map(importStepHtml).join('');
    importSetProgress(importProgressValue, true);
    navSetPaneActivity('ingest', {
      active: true,
      percent: importProgressValue,
      indeterminate: false,
      title: `Import ${Math.round(importProgressValue)}%`,
    });
  }, 220);

  importCounterTimer = setInterval(() => {
    est.pages += Math.max(1, Math.floor(Math.random() * 2));
    est.words += Math.max(90, Math.floor(Math.random() * 240));
    est.sentences += Math.max(4, Math.floor(Math.random() * 11));
    est.paragraphs += Math.max(1, Math.floor(Math.random() * 4));
    est.tables += Math.max(0, Math.floor(Math.random() * 2));
    est.rows += Math.max(1, Math.floor(Math.random() * 12));
    est.chunks += Math.max(4, Math.floor(Math.random() * 18));
  }, 700);
}

function importStepsFromPayload(payload, vectorPayload) {
  const extraction = payload?.extraction || {};
  const summary = extraction.summary || {};
  const latestVectorRun = Array.isArray(vectorPayload?.runs) && vectorPayload.runs.length
    ? vectorPayload.runs[0]
    : null;

  const steps = [];
  if (payload && payload.ok) {
    const archiveDetail = payload.status === 'duplicate'
      ? 'Duplicate detected; existing archive reused.'
      : 'Document archived and resource record created.';
    steps.push({
      ...IMPORT_STEPS[0],
      state: 'done',
      progress: 100,
      detail: archiveDetail,
      stats: payload?.resource?.digest_sha256 ? `digest ${String(payload.resource.digest_sha256).slice(0, 10)}...` : '',
    });
  } else {
    steps.push({
      ...IMPORT_STEPS[0],
      state: 'error',
      progress: 100,
      detail: payload?.detail || payload?.error || 'Import failed.',
    });
  }

  if (extraction.status === 'extracted') {
    const pageCount = summary.page_count;
    const textWords = summary.text_words ?? 0;
    const textSentences = summary.text_sentences ?? 0;
    const textParagraphs = summary.text_paragraphs ?? 0;
    const tableRows = summary.table_rows_total ?? 0;
    const tableCols = summary.table_cols_total ?? 0;
    const tableCells = summary.table_cells_total ?? 0;
    steps.push({
      ...IMPORT_STEPS[1],
      state: 'done',
      progress: 100,
      detail: pageCount ? `${pageCount} page(s) scanned.` : 'Text extraction completed.',
      stats: `${textWords} words, ${textSentences} sentences, ${textParagraphs} paragraphs`,
    });
    steps.push({
      ...IMPORT_STEPS[2],
      state: 'done',
      progress: 100,
      detail: `${summary.tables_found ?? 0} tables, ${summary.annotations_persisted ?? 0} annotations.`,
      stats: `${tableRows} rows, ${tableCols} cols, ${tableCells} cells`,
    });
    const vectorState = String(
      summary.vector_status
      || extraction?.vector?.status
      || latestVectorRun?.status
      || 'skipped'
    ).toLowerCase();
    const vectorChunksIndexed = summary.vector_chunks_indexed
      ?? extraction?.vector?.chunks_indexed
      ?? latestVectorRun?.chunks_indexed
      ?? 0;
    const vectorChunksTotal = summary.vector_chunks_total
      ?? extraction?.vector?.chunks_total
      ?? latestVectorRun?.chunks_total
      ?? 0;
    const vectorError = summary.vector_error || extraction?.vector?.error || latestVectorRun?.error_message || null;
    if (vectorState === 'failed') {
      steps.push({
        ...IMPORT_STEPS[3],
        state: 'error',
        progress: 100,
        detail: vectorError || 'Vector indexing failed.',
      });
    } else if (vectorState === 'success' || vectorState === 'running') {
      steps.push({
        ...IMPORT_STEPS[3],
        state: 'done',
        progress: 100,
        detail: `${vectorChunksIndexed}/${vectorChunksTotal} chunks indexed.`,
        stats: `${vectorPayload?.qdrant_points ?? 0} total vector points`,
      });
    } else {
      steps.push({
        ...IMPORT_STEPS[3],
        state: 'skipped',
        progress: 100,
        detail: 'Vector indexing not executed.',
      });
    }
    return steps;
  }

  if (extraction.status === 'failed') {
    steps.push({
      ...IMPORT_STEPS[1],
      state: 'error',
      progress: 100,
      detail: extraction.error || 'Extraction failed.',
    });
    steps.push({
      ...IMPORT_STEPS[2],
      state: 'skipped',
      progress: 100,
      detail: 'Skipped due to extraction failure.',
    });
    steps.push({
      ...IMPORT_STEPS[3],
      state: 'skipped',
      progress: 100,
      detail: 'Skipped due to extraction failure.',
    });
    return steps;
  }

  if (extraction.reason === 'already_extracted') {
    const vectorSummary = extraction.vector || null;
    const vectorStatus = String(vectorSummary?.status || '').toLowerCase();
    const vectorRuns = Array.isArray(vectorPayload?.runs) ? vectorPayload.runs : [];
    const words = summary.text_words ?? 0;
    const sentences = summary.text_sentences ?? 0;
    const paragraphs = summary.text_paragraphs ?? 0;
    steps.push({
      ...IMPORT_STEPS[1],
      state: 'done',
      progress: 100,
      detail: 'Existing extraction reused.',
      stats: `run ${extraction.extraction_run_id || 'latest'}  ${words} words  ${sentences} sentences  ${paragraphs} paragraphs`,
    });
    steps.push({
      ...IMPORT_STEPS[2],
      state: 'done',
      progress: 100,
      detail: 'Structured data already available.',
      stats: `${summary.tables_found ?? 0} tables  ${summary.table_rows_total ?? 0} rows  ${summary.table_cols_total ?? 0} cols  ${summary.table_cells_total ?? 0} cells`,
    });
    const hasVectorRuns = vectorRuns.length > 0;
    const vectorStepState = vectorStatus === 'failed'
      ? 'error'
      : ((vectorStatus === 'success' || vectorStatus === 'skipped' || hasVectorRuns) ? 'done' : 'skipped');
    const vectorDetail = vectorStatus === 'failed'
      ? (vectorSummary?.error || 'Vector indexing failed while reusing extraction.')
      : (vectorStatus === 'success'
        ? `${vectorSummary?.chunks_indexed ?? 0}/${vectorSummary?.chunks_total ?? 0} chunks indexed.`
        : (vectorStatus === 'skipped'
          ? 'Existing vector index reused for current extraction.'
          : (hasVectorRuns ? 'Existing vector runs detected.' : 'No vector runs found for this resource yet.')));
    steps.push({
      ...IMPORT_STEPS[3],
      state: vectorStepState,
      progress: 100,
      detail: vectorDetail,
      stats: (vectorSummary && Number.isFinite(Number(vectorSummary?.chunks_total)))
        ? `${vectorSummary?.chunks_indexed ?? 0}/${vectorSummary?.chunks_total ?? 0} chunks`
        : (hasVectorRuns ? `${vectorRuns.length} run(s)` : ''),
    });
    return steps;
  }

  if (extraction.reason === 'media_type_not_extractable') {
    steps.push({ ...IMPORT_STEPS[1], state: 'skipped', progress: 100, detail: 'Media type is not extractable.' });
    steps.push({ ...IMPORT_STEPS[2], state: 'skipped', progress: 100, detail: 'No extraction means no table parsing.' });
    steps.push({ ...IMPORT_STEPS[3], state: 'skipped', progress: 100, detail: 'No extraction means no vector indexing.' });
    return steps;
  }

  steps.push({ ...IMPORT_STEPS[1], state: 'skipped', progress: 100, detail: 'Extraction not attempted.' });
  steps.push({ ...IMPORT_STEPS[2], state: 'skipped', progress: 100, detail: 'Not available.' });
  steps.push({ ...IMPORT_STEPS[3], state: 'skipped', progress: 100, detail: 'Not available.' });
  return steps;
}

function importFinalMetrics(payload, vectorPayload) {
  const extraction = payload?.extraction || {};
  const summary = extraction.summary || {};
  const resource = payload?.resource || {};
  const latestVectorRun = Array.isArray(vectorPayload?.runs) && vectorPayload.runs.length
    ? vectorPayload.runs[0]
    : null;
  const vectorStatus = summary.vector_status || extraction?.vector?.status || latestVectorRun?.status || 'n/a';
  const vectorChunksIndexed = summary.vector_chunks_indexed
    ?? extraction?.vector?.chunks_indexed
    ?? latestVectorRun?.chunks_indexed
    ?? 0;
  const vectorChunksTotal = summary.vector_chunks_total
    ?? extraction?.vector?.chunks_total
    ?? latestVectorRun?.chunks_total
    ?? 0;
  const metrics = [
    { k: 'Import Status', v: payload?.status || 'unknown' },
    { k: 'Media Type', v: resource.media_type || 'n/a' },
    { k: 'Pages', v: summary.page_count ?? 0 },
    { k: 'Words', v: summary.text_words ?? 0 },
    { k: 'Sentences', v: summary.text_sentences ?? 0 },
    { k: 'Paragraphs', v: summary.text_paragraphs ?? 0 },
    { k: 'Tables', v: summary.tables_found ?? 0 },
    { k: 'Table Rows', v: summary.table_rows_total ?? 0 },
    { k: 'Table Cols', v: summary.table_cols_total ?? 0 },
    { k: 'Table Cells', v: summary.table_cells_total ?? 0 },
    { k: 'Segments', v: summary.segments_persisted ?? 0 },
    { k: 'Annotations', v: summary.annotations_persisted ?? 0 },
    { k: 'Vector Status', v: vectorStatus },
    { k: 'Vector Chunks', v: `${vectorChunksIndexed}/${vectorChunksTotal}` },
  ];
  if (resource.download_url) {
    metrics.push({ k: 'Download URL', v: resource.download_url });
  }
  if (resource.source_uri) {
    metrics.push({ k: 'Source URI', v: resource.source_uri });
  }
  if (vectorPayload && vectorPayload.ok) {
    metrics.push({ k: 'Vector Runs', v: Array.isArray(vectorPayload.runs) ? vectorPayload.runs.length : 0 });
    metrics.push({ k: 'Qdrant Points', v: vectorPayload.qdrant_points ?? 0 });
  }
  return metrics;
}

async function importOpenInDatabase(resourceId) {
  if (!resourceId) return;
  setActivePane('database');
  await dbListTables();
  const select = document.getElementById('db-table-select');
  if (select) select.value = 'resources';

  const pageSize = 100;
  let targetOffset = 0;
  try {
    const locate = await callApi(
      'GET',
      `/api/db/table/locate?name=resources&column=id&value=${encodeURIComponent(resourceId)}&page_size=${pageSize}`,
      null,
      null
    );
    if (locate?.ok && locate?.found && Number.isFinite(Number(locate.offset))) {
      targetOffset = Math.max(0, Number(locate.offset));
    }
  } catch (e) {
  }

  const limit = document.getElementById('db-limit');
  if (limit) limit.value = String(pageSize);
  const offset = document.getElementById('db-offset');
  if (offset) offset.value = String(targetOffset);
  await dbViewTable();
  const search = document.getElementById('db-search');
  if (search) {
    search.value = resourceId;
    dbGridState.globalSearch = resourceId;
    if (dbOutputMode() === 'spreadsheet') dbRenderGrid();
  }
}

async function importFinalizeJob(payload, meta) {
  importStopTimers();
  importSetProgress(100, false);
  if (!importDropQueueRunning && !importActiveStreamAbortController) {
    navSetPaneActivity('ingest', { active: false });
  }
  const basePayload = (payload && typeof payload === 'object') ? payload : {};
  const resourceId = basePayload?.resource?.id || null;
  const extractionPayload = (basePayload.extraction && typeof basePayload.extraction === 'object')
    ? basePayload.extraction
    : null;
  const extractionStatus = extractionPayload ? String(extractionPayload.status || '') : '';
  const needsFallbackExtraction = Boolean(
    basePayload?.ok
      && resourceId
      && (
        !extractionPayload
        || !extractionStatus
        || (extractionStatus === 'skipped' && !extractionPayload.reason)
      )
  );

  let finalizedPayload = basePayload;
  if (needsFallbackExtraction) {
    const status = document.getElementById('import-status-line');
    if (status) status.textContent = 'Running extraction pipeline (fallback)...';
    try {
      const extractPayload = await callApi(
        'POST',
        '/api/extract/run',
        { resource_id: resourceId, profile: 'default' },
        null
      );
      const extractionSummary = extractPayload?.summary || null;
      finalizedPayload = {
        ...basePayload,
        extraction: extractionSummary
          ? { attempted: true, status: 'extracted', summary: extractionSummary, source: 'client_fallback' }
          : { attempted: true, status: 'failed', error: extractPayload?.detail || 'Extraction failed.' },
      };
      const runId = extractionSummary?.run_id;
      if (runId) {
        const vectorIndex = await callApi(
          'POST',
          '/api/vector/index',
          { resource_id: resourceId, extraction_run_id: runId, force: false },
          null
        );
        if (vectorIndex && vectorIndex.ok && vectorIndex.summary) {
          const summary = finalizedPayload.extraction?.summary || {};
          finalizedPayload.extraction.summary = {
            ...summary,
            vector_status: vectorIndex.summary.status,
            vector_chunks_total: vectorIndex.summary.chunks_total,
            vector_chunks_indexed: vectorIndex.summary.chunks_indexed,
            vector_error: vectorIndex.summary.error,
          };
        }
      }
    } catch (e) {
      finalizedPayload = {
        ...basePayload,
        extraction: { attempted: true, status: 'failed', error: String(e), source: 'client_fallback' },
      };
    }
  }

  function hasValue(v) {
    return v !== undefined && v !== null;
  }

  function computeTextStats(text) {
    const content = String(text || '');
    const words = (content.match(/\b\w+\b/g) || []).length;
    const sentences = (content.match(/[^.!?\n]+(?:[.!?]+|$)/g) || [])
      .map((s) => s.trim())
      .filter((s) => s.length > 0)
      .length;
    const paragraphs = content
      .split(/\n\s*\n+/)
      .map((p) => p.trim())
      .filter((p) => p.length > 0)
      .length;
    return { words, sentences, paragraphs };
  }

  function jsonArrayLength(value) {
    if (Array.isArray(value)) return value.length;
    if (typeof value !== 'string') return 0;
    try {
      const parsed = JSON.parse(value);
      return Array.isArray(parsed) ? parsed.length : 0;
    } catch {
      return 0;
    }
  }

  async function enrichExtractionSummary(resourceIdValue, extractionValue) {
    const mayHaveExtractionSummary = extractionValue?.status === 'extracted' || extractionValue?.reason === 'already_extracted';
    if (!resourceIdValue || !mayHaveExtractionSummary) return extractionValue;
    const summaryIn = (extractionValue.summary && typeof extractionValue.summary === 'object')
      ? extractionValue.summary
      : {};
    const summary = { ...summaryIn };
    const runId = summary.run_id || extractionValue?.extraction_run_id || null;

    const missingTextStats = !hasValue(summary.text_words) || !hasValue(summary.text_sentences) || !hasValue(summary.text_paragraphs);
    if (missingTextStats || !hasValue(summary.text_chars)) {
      try {
        let url = `/api/extract/text?resource_id=${encodeURIComponent(resourceIdValue)}`;
        if (runId) url += `&extraction_run_id=${encodeURIComponent(runId)}`;
        const textPayload = await callApi('GET', url, null, null);
        const doc = textPayload?.document_text || null;
        if (doc) {
          const textContent = String(doc.text_content || '');
          const computed = computeTextStats(textContent);
          if (!hasValue(summary.text_chars)) summary.text_chars = hasValue(doc.char_count) ? doc.char_count : textContent.length;
          if (!hasValue(summary.text_words)) summary.text_words = computed.words;
          if (!hasValue(summary.text_sentences)) summary.text_sentences = computed.sentences;
          if (!hasValue(summary.text_paragraphs)) summary.text_paragraphs = computed.paragraphs;
        }
      } catch (e) {
      }
    }

    const missingTableStats = !hasValue(summary.table_rows_total) || !hasValue(summary.table_cols_total) || !hasValue(summary.table_cells_total);
    if (missingTableStats || !hasValue(summary.tables_found)) {
      try {
        const tablesPayload = await callApi(
          'GET',
          `/api/extract/tables?resource_id=${encodeURIComponent(resourceIdValue)}&limit=100000`,
          null,
          null
        );
        const tables = Array.isArray(tablesPayload?.tables) ? tablesPayload.tables : [];
        if (!hasValue(summary.tables_found)) summary.tables_found = tables.length;
        if (missingTableStats) {
          let rows = 0;
          let cols = 0;
          let cells = 0;
          for (const table of tables) {
            rows += jsonArrayLength(table?.row_headers_json ?? table?.row_headers);
            cols += jsonArrayLength(table?.col_headers_json ?? table?.col_headers);
            cells += jsonArrayLength(table?.cells_json ?? table?.cells);
          }
          if (!hasValue(summary.table_rows_total)) summary.table_rows_total = rows;
          if (!hasValue(summary.table_cols_total)) summary.table_cols_total = cols;
          if (!hasValue(summary.table_cells_total)) summary.table_cells_total = cells;
        }
      } catch (e) {
      }
    }

    return { ...extractionValue, summary };
  }

  if (resourceId && finalizedPayload?.extraction) {
    finalizedPayload = {
      ...finalizedPayload,
      extraction: await enrichExtractionSummary(resourceId, finalizedPayload.extraction),
    };
  }

  importDebugPush('finalized_payload', finalizedPayload || {}, { source: 'client' });
  importDebugRender({ finalized_payload: finalizedPayload || {} });

  let vectorPayload = null;
  if (resourceId) {
    try {
      vectorPayload = await callApi('GET', `/api/vector/status?resource_id=${encodeURIComponent(resourceId)}&limit_runs=10`, null, null);
    } catch (e) {
      vectorPayload = null;
    }
  }

  const steps = importStepsFromPayload(finalizedPayload, vectorPayload);
  const metrics = importFinalMetrics(finalizedPayload, vectorPayload);
  const ok = Boolean(finalizedPayload?.ok);
  const extraction = finalizedPayload?.extraction || {};
  const summary = extraction.summary || {};
  const actions = resourceId
    ? `<div class="row"><button type="button" class="secondary" onclick="importOpenInDatabase('${dbEscapeHtml(resourceId)}')">Open In Database Explorer</button><button type="button" class="secondary" onclick="viewerOpenFromImport('${dbEscapeHtml(resourceId)}')">Open In Document Viewer</button></div>`
    : '';

  const statusLine = ok
    ? `Import complete for ${meta.name || 'document'}.`
    : 'Import failed.';
  const countersParts = [];
  if (summary.page_count !== undefined && summary.page_count !== null) countersParts.push(`Pages ${summary.page_count}`);
  if (summary.text_words !== undefined && summary.text_words !== null) countersParts.push(`Words ${summary.text_words}`);
  if (summary.text_sentences !== undefined && summary.text_sentences !== null) countersParts.push(`Sentences ${summary.text_sentences}`);
  if (summary.text_paragraphs !== undefined && summary.text_paragraphs !== null) countersParts.push(`Paragraphs ${summary.text_paragraphs}`);
  if (summary.tables_found !== undefined && summary.tables_found !== null) countersParts.push(`Tables ${summary.tables_found}`);
  if (summary.table_rows_total !== undefined && summary.table_rows_total !== null) countersParts.push(`Rows ${summary.table_rows_total}`);
  if (summary.table_cols_total !== undefined && summary.table_cols_total !== null) countersParts.push(`Cols ${summary.table_cols_total}`);
  if (summary.table_cells_total !== undefined && summary.table_cells_total !== null) countersParts.push(`Cells ${summary.table_cells_total}`);
  if (summary.vector_chunks_total !== undefined && summary.vector_chunks_total !== null) {
    countersParts.push(`Vector chunks ${summary.vector_chunks_indexed ?? 0}/${summary.vector_chunks_total}`);
  }
  if (!countersParts.length && extraction.reason === 'already_extracted' && extraction?.vector) {
    countersParts.push(`Existing extraction reused`);
    if (extraction.vector.chunks_total !== undefined && extraction.vector.chunks_total !== null) {
      countersParts.push(`Vector chunks ${extraction.vector.chunks_indexed ?? 0}/${extraction.vector.chunks_total}`);
    }
    if (extraction.vector.status) {
      countersParts.push(`Vector status ${extraction.vector.status}`);
    }
  }
  const counters = countersParts.length
    ? countersParts.join('  ')
    : (extraction.reason === 'media_type_not_extractable'
      ? 'No extraction/vectorization for this media type.'
      : 'No extraction summary available.');

  importRenderLive(meta, {
    title: meta.name || 'Import Job',
    meta: `${meta.sourceLabel || 'Import'}  ${finalizedPayload?.resource?.id || 'no resource id'}`,
    statusLine,
    countersLine: counters,
    steps,
    metrics,
    actionsHtml: actions,
    progress: 100,
    progressActive: false,
  });

  const doneTone = ok ? (steps.some((s) => s.state === 'error') ? 'error' : 'ok') : 'error';
  importAddHistory({
    statusTone: doneTone,
    statusLabel: ok ? 'completed' : 'failed',
    name: meta.name || finalizedPayload?.uploaded_filename || finalizedPayload?.resource?.original_filename || 'document',
    summary: resourceId
      ? `resource=${resourceId}  vector=${summary.vector_status || extraction.status || 'n/a'}`
      : (finalizedPayload?.detail || finalizedPayload?.error || 'No resource id'),
  });
  return finalizedPayload;
}

function importStreamInitStepState() {
  const map = {};
  IMPORT_STEPS.forEach((step) => {
    map[step.id] = { state: 'pending', progress: 0, detail: '', stats: '', page_count: null, page_current: null, preview: null };
  });
  return map;
}

function importStreamStepArray(stepMap) {
  return IMPORT_STEPS.map((step) => ({
    ...step,
    ...(stepMap[step.id] || { state: 'pending', progress: 0, detail: '', stats: '' }),
  }));
}

function importStreamOverallProgress(stepMap) {
  let total = 0;
  let used = 0;
  Object.entries(IMPORT_STREAM_STAGE_WEIGHTS).forEach(([stage, weight]) => {
    const step = stepMap[stage];
    if (!step) return;
    const raw = Number(step.progress);
    const value = Number.isFinite(raw) ? Math.max(0, Math.min(100, raw)) : 0;
    total += value * weight;
    used += weight;
  });
  if (!used) return 0;
  return Math.max(0, Math.min(100, Math.round(total / used)));
}

function importRenderStreamLive(meta, stepMap, statusLine, countersLine='', actionsHtml='') {
  importRenderLive(meta, {
    title: meta.name || 'Import Job',
    meta: `${meta.sourceLabel || 'Import'}  streaming backend progress`,
    statusLine: statusLine || 'Import running...',
    countersLine: countersLine || '',
    steps: importStreamStepArray(stepMap),
    metrics: [],
    actionsHtml,
    progress: importStreamOverallProgress(stepMap),
    progressActive: true,
  });
}

function importApplyStreamStage(stepMap, stagePayload) {
  const stage = stagePayload?.stage;
  if (!stage || !stepMap[stage]) return;
  const stagePageCount = importSafePositiveInt(stagePayload?.page_count);
  const priorPageCount = importSafePositiveInt(stepMap[stage]?.page_count);
  const resolvedPageCount = stagePageCount || priorPageCount || null;
  const stagePageCurrent = importClampCurrentPage(
    stagePayload?.page_current ?? stagePayload?.current_page,
    resolvedPageCount,
  );
  const stagePreviewRaw = (stagePayload?.preview && typeof stagePayload.preview === 'object')
    ? { ...stagePayload.preview }
    : null;
  if (stagePreviewRaw && !importSafePositiveInt(stagePreviewRaw.page_count) && resolvedPageCount) {
    stagePreviewRaw.page_count = resolvedPageCount;
  }
  const stagePreview = importNormalizePreviewSignal(stagePreviewRaw);
  stepMap[stage] = {
    ...stepMap[stage],
    state: stagePayload?.state || stepMap[stage].state || 'pending',
    progress: Number.isFinite(Number(stagePayload?.progress))
      ? Number(stagePayload.progress)
      : stepMap[stage].progress,
    detail: stagePayload?.detail || stepMap[stage].detail || '',
    stats: stagePayload?.stats || stepMap[stage].stats || '',
    page_count: resolvedPageCount,
    page_current: stagePageCurrent || importClampCurrentPage(stepMap[stage].page_current, resolvedPageCount),
    preview: stagePreview || stepMap[stage].preview || null,
  };
  if (resolvedPageCount) {
    importPreviewPageTotal = Math.max(importPreviewPageTotal || 0, resolvedPageCount);
  }
  const currentPage = importClampCurrentPage(stagePageCurrent, importPreviewPageTotal || resolvedPageCount);
  if (currentPage) {
    importPreviewPageCurrent = currentPage;
  }
}

function importParseSseFrame(frame) {
  if (!frame || !frame.trim()) return null;
  let event = 'message';
  const dataLines = [];
  frame.split(/\r?\n/).forEach((line) => {
    if (line.startsWith('event:')) {
      event = line.slice(6).trim();
      return;
    }
    if (line.startsWith('data:')) {
      dataLines.push(line.slice(5).trimStart());
    }
  });
  const dataRaw = dataLines.join('\n');
  let data;
  try {
    data = dataRaw ? JSON.parse(dataRaw) : {};
  } catch {
    data = { detail: dataRaw };
  }
  return { event, data };
}

async function importOpenStream(url, opts) {
  const attempts = candidateApiUrls(url);
  let lastPayload = null;
  for (const attemptUrl of attempts) {
    const res = await fetch(attemptUrl, opts);
    if (res.status === 404) {
      const contentType = (res.headers.get('content-type') || '').toLowerCase();
      lastPayload = contentType.includes('application/json') ? await res.json() : { detail: await res.text() };
      continue;
    }
    if (!res.ok) {
      const contentType = (res.headers.get('content-type') || '').toLowerCase();
      const payload = contentType.includes('application/json') ? await res.json() : { detail: await res.text() };
      throw new Error(payload?.detail || `HTTP ${res.status}`);
    }
    return res;
  }
  throw new Error(lastPayload?.detail || `Stream endpoint not found for ${url}`);
}

async function importRunWithStreamVisuals(meta, streamUrl, body, isFormData=false, fallbackRequestFn=null) {
  const stepMap = importStreamInitStepState();
  const abortController = new AbortController();
  importDebugReset(meta, 'stream');
  importDebugPush('stream_start', {
    stream_url: streamUrl,
    is_form_data: Boolean(isFormData),
    body: isFormData ? '[form-data]' : body,
  }, { source: 'client' });
  importDebugSetLiveSnapshot('Starting import...', '', stepMap);
  importDebugRender();
  importActiveStepMap = stepMap;
  importActiveEta = importEtaStart(meta);
  importActiveStreamAbortController = abortController;
  importStopTimers();

  const opts = {
    method: 'POST',
    headers: { Accept: 'text/event-stream' },
    signal: abortController.signal,
  };
  if (body !== null && body !== undefined) {
    if (isFormData) {
      opts.body = body;
    } else {
      opts.headers['Content-Type'] = 'application/json';
      opts.body = JSON.stringify(body);
    }
  }

  let finalPayload = null;
  let statusLine = 'Starting import...';
  let countersLine = '';
  let watchdogTimer = null;
  let lastRenderSignature = '';

  const renderStreamFrame = (force = false) => {
    const eta = importEtaEstimate(stepMap);
    const statusText = importStatusLineWithHeartbeat(statusLine, eta);
    const countersText = importCounterLineWithEta(countersLine, eta);
    const actionsHtml = importLiveQueueActionsHtml();
    const streamProgress = Math.round(importStreamOverallProgress(stepMap));
    const signature = `${streamProgress}|${statusText}|${countersText}`;
    if (!force && signature === lastRenderSignature) return;
    lastRenderSignature = signature;
    navSetPaneActivity('ingest', {
      active: true,
      percent: streamProgress,
      indeterminate: streamProgress <= 0,
      title: `Import ${streamProgress}%`,
    });
    importRenderStreamLive(meta, stepMap, statusText, countersText, actionsHtml);
    importDebugSetLiveSnapshot(statusText, countersText, stepMap);
    importDebugRender({ stream_progress: streamProgress });
    if (importDropQueueRunning) importRenderDropQueue();
  };
  renderStreamFrame(true);

  try {
    watchdogTimer = setInterval(() => {
      renderStreamFrame(false);
    }, 1000);

    const response = await importOpenStream(streamUrl, opts);
    if (!response.body) throw new Error('Streaming response body is unavailable.');
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';
    let done = false;
    while (!done) {
      const read = await reader.read();
      done = Boolean(read.done);
      buffer += decoder.decode(read.value || new Uint8Array(), { stream: !done });

      let split = buffer.indexOf('\n\n');
      while (split >= 0) {
        const frame = buffer.slice(0, split);
        buffer = buffer.slice(split + 2);
        split = buffer.indexOf('\n\n');

        const parsed = importParseSseFrame(frame);
        if (!parsed) continue;
        const { event, data } = parsed;
        if (event === 'stage') {
          importDebugPush('stage', data || {}, { source: 'server' });
          importApplyStreamStage(stepMap, data || {});
          if (importActiveEta) importActiveEta.lastHeartbeatMs = Date.now();
          const stageLabel = (data?.stage || '').replace(/^\w/, (c) => c.toUpperCase());
          statusLine = data?.detail || (stageLabel ? `${stageLabel} in progress...` : statusLine);
          countersLine = data?.stats || countersLine;
          renderStreamFrame(true);
          continue;
        }
        if (event === 'payload') {
          importDebugPush('payload', data || {}, { source: 'server' });
          finalPayload = data || null;
          continue;
        }
        if (event === 'error') {
          importDebugPush('error', data || {}, { source: 'server' });
          throw new Error(data?.error || data?.detail || 'Import stream failed.');
        }
        importDebugPush(event, data || {}, { source: 'server' });
      }
    }
  } catch (e) {
    const isAbortError = Boolean(e) && (
      String(e?.name || '') === 'AbortError'
      || String(e?.code || '') === 'ABORT_ERR'
      || String(e).toLowerCase().includes('abort')
    );
    if (isAbortError && importDropQueueActiveId && importDeferRequestedItemId === importDropQueueActiveId) {
      return {
        ok: false,
        aborted: true,
        deferred: true,
        error: 'Deferred by user.',
      };
    }
    importDebugPush('stream_exception', { error: String(e) }, { source: 'client' });
    importDebugRender({ error: String(e) });
    if (fallbackRequestFn) {
      return importRunWithVisuals(meta, fallbackRequestFn);
    }
    throw e;
  } finally {
    if (watchdogTimer) clearInterval(watchdogTimer);
    watchdogTimer = null;
    if (importActiveStreamAbortController === abortController) {
      importActiveStreamAbortController = null;
    }
    importActiveStepMap = null;
    importActiveEta = null;
    importDebugPush('stream_closed', { final_payload_received: Boolean(finalPayload) }, { source: 'client' });
    importDebugRender({ final_payload_received: Boolean(finalPayload) });
    if (!importDropQueueRunning) {
      navSetPaneActivity('ingest', { active: false });
    }
  }

  if (!finalPayload) {
    if (fallbackRequestFn) {
      return importRunWithVisuals(meta, fallbackRequestFn);
    }
    throw new Error('Import stream finished without a payload.');
  }
  const finalizedPayload = await importFinalizeJob(finalPayload, meta);
  return {
    ok: Boolean(finalizedPayload?.ok),
    payload: finalizedPayload,
  };
}

async function importRunWithVisuals(meta, requestFn) {
  importDebugReset(meta, 'legacy');
  importDebugPush('legacy_start', {}, { source: 'client' });
  importDebugRender();
  importStartAnimatedJob(meta);
  try {
    const payload = await requestFn();
    importDebugPush('legacy_payload', payload || {}, { source: 'server' });
    const finalizedPayload = await importFinalizeJob(payload, meta);
    return {
      ok: Boolean(finalizedPayload?.ok),
      payload: finalizedPayload,
    };
  } catch (e) {
    importStopTimers();
    if (!importDropQueueRunning && !importActiveStreamAbortController) {
      navSetPaneActivity('ingest', { active: false });
    }
    const message = String(e);
    importRenderLive(meta, {
      title: meta.name || 'Import Job',
      meta: `${meta.sourceLabel || 'Import'}  failed`,
      statusLine: 'Import failed before completion.',
      countersLine: '',
      steps: [
        { ...IMPORT_STEPS[0], state: 'error', detail: message },
        { ...IMPORT_STEPS[1], state: 'skipped', detail: 'Skipped' },
        { ...IMPORT_STEPS[2], state: 'skipped', detail: 'Skipped' },
        { ...IMPORT_STEPS[3], state: 'skipped', detail: 'Skipped' },
      ],
      metrics: [],
      progress: 100,
      progressActive: false,
    });
    document.getElementById('out-ingest').textContent = JSON.stringify({ error: message }, null, 2);
    importAddHistory({
      statusTone: 'error',
      statusLabel: 'failed',
      name: meta.name || 'document',
      summary: message,
    });
    importDebugPush('legacy_error', { error: message }, { source: 'client' });
    importDebugRender({ error: message });
    return { ok: false, error: message };
  }
}

async function ingestPath() {
  const path = (document.getElementById('ingest-path').value || '').trim();
  if (!path) {
    document.getElementById('out-ingest').textContent = JSON.stringify({ error: 'Provide an absolute file path.' }, null, 2);
    return;
  }
  await importRunWithStreamVisuals(
    { name: importPathBasename(path), sourceLabel: 'Path Import', path },
    '/api/ingest/path/stream',
    { path },
    false,
    () => callApi('POST', '/api/ingest/path', { path }, null)
  );
}

async function listResources() {
  const limit = encodeURIComponent(document.getElementById('resources-limit').value || '20');
  const payload = await callApi('GET', `/api/resources?limit=${limit}`, null, 'out-ingest');
  if (!payload || payload.ok !== true || !Array.isArray(payload.resources)) return;
  importHistoryItems = payload.resources.slice(0, 12).map((r) => ({
    statusTone: 'neutral',
    statusLabel: 'resource',
    name: r.original_filename || r.id,
    summary: `id=${r.id}  digest=${String(r.digest_sha256 || '').slice(0, 12)}...`,
  }));
  importRenderHistory();
}

async function importBib() {
  await callApi('POST', '/api/refs/import-bib', {
    bib_path: document.getElementById('bib-path').value
  }, 'out-refs');
}

async function linkReference() {
  await callApi('POST', '/api/refs/link-resource', {
    cite_id: document.getElementById('link-cite-id').value,
    resource_digest: document.getElementById('link-digest').value
  }, 'out-refs');
}

async function extractRun() {
  await callApi('POST', '/api/extract/run', {
    resource_id: document.getElementById('extract-resource-id').value || null,
    resource_digest: document.getElementById('extract-digest').value || null,
    profile: 'default'
  }, 'out-extract');
}

async function extractTables() {
  const id = encodeURIComponent(document.getElementById('extract-tables-id').value || '');
  const digest = encodeURIComponent(document.getElementById('extract-tables-digest').value || '');
  const qs = id ? `resource_id=${id}` : `resource_digest=${digest}`;
  await callApi('GET', `/api/extract/tables?${qs}`, null, 'out-extract');
}

function extractionInspectorError(message) {
  document.getElementById('out-extract-inspector').textContent = JSON.stringify({ error: message }, null, 2);
  extractionInspectorSetCardsHtml('<p class="small err">' + dbEscapeHtml(message) + '</p>');
}

let extractionInspectorCopyPayloads = [];

function extractionInspectorSetCardsHtml(html) {
  const container = document.getElementById('extract-inspector-list');
  if (!container) return;
  container.innerHTML = html;
  container.querySelectorAll('[data-copy-idx]').forEach((button) => {
    button.addEventListener('click', async () => {
      const idx = Number(button.getAttribute('data-copy-idx'));
      await extractionInspectorCopyPayloadByIndex(idx);
    });
  });
}

function extractionInspectorSetCopyStatus(message, isError=false) {
  const el = document.getElementById('extract-inspector-copy-status');
  if (!el) return;
  el.textContent = message || '';
  if (isError) {
    el.classList.add('err');
  } else {
    el.classList.remove('err');
  }
}

async function extractionInspectorCopyText(text) {
  if (navigator.clipboard && navigator.clipboard.writeText) {
    await navigator.clipboard.writeText(text);
    return;
  }
  const area = document.createElement('textarea');
  area.value = text;
  area.setAttribute('readonly', 'readonly');
  area.style.position = 'absolute';
  area.style.left = '-9999px';
  document.body.appendChild(area);
  area.select();
  document.execCommand('copy');
  document.body.removeChild(area);
}

async function extractionInspectorCopyPayloadByIndex(index) {
  if (!Number.isInteger(index) || index < 0 || index >= extractionInspectorCopyPayloads.length) {
    extractionInspectorSetCopyStatus('Unable to copy selector JSON: payload missing.', true);
    return;
  }
  const payload = extractionInspectorCopyPayloads[index];
  try {
    await extractionInspectorCopyText(JSON.stringify(payload, null, 2));
    extractionInspectorSetCopyStatus('Copied selector JSON to clipboard.');
  } catch (e) {
    extractionInspectorSetCopyStatus('Failed to copy selector JSON: ' + String(e), true);
  }
}

function extractionInspectorResetCards(message='No inspector items loaded yet.') {
  extractionInspectorCopyPayloads = [];
  extractionInspectorSetCardsHtml('<p class="small">' + dbEscapeHtml(message) + '</p>');
  extractionInspectorSetCopyStatus('');
}

function extractionInspectorSegmentSelector(segment) {
  return {
    type: 'TextPositionSelector',
    start: Number(segment.start_offset),
    end: Number(segment.end_offset),
    segment_type: segment.segment_type || null,
    extraction_run_id: segment.extraction_run_id || null,
  };
}

function extractionInspectorAnnotationSelector(annotation) {
  const spans = Array.isArray(annotation.spans)
    ? annotation.spans.map((s) => ({
        start: Number(s.start),
        end: Number(s.end),
      }))
    : [];
  const selector = {
    type: 'TextAnnotationSelector',
    annotation_id: annotation.id,
    layer: annotation.layer || null,
    category: annotation.category || null,
    label: annotation.label || null,
    spans,
  };
  if (spans.length === 1) {
    selector.start = spans[0].start;
    selector.end = spans[0].end;
  }
  return selector;
}

function extractionInspectorRenderSegments(data) {
  const segments = Array.isArray(data?.segments) ? data.segments : [];
  if (!segments.length) {
    extractionInspectorResetCards('No segments matched the current inspector query.');
    return;
  }
  extractionInspectorCopyPayloads = segments.map((segment) => extractionInspectorSegmentSelector(segment));
  const html = segments
    .map((segment, idx) => {
      const start = Number(segment.start_offset);
      const end = Number(segment.end_offset);
      const length = Number.isFinite(start) && Number.isFinite(end) ? Math.max(0, end - start) : '';
      return `
        <article class="inspector-card">
          <h4>${dbEscapeHtml(segment.segment_type || 'segment')} (#${idx + 1})</h4>
          <p class="inspector-meta">start=${dbEscapeHtml(String(segment.start_offset))}, end=${dbEscapeHtml(String(segment.end_offset))}, len=${dbEscapeHtml(String(length))}, page=${dbEscapeHtml(String(segment.page_index ?? 'n/a'))}</p>
          <div class="inspector-copy-row">
            <button class="secondary" type="button" data-copy-idx="${idx}">Copy Selector JSON</button>
          </div>
        </article>
      `;
    })
    .join('');
  extractionInspectorSetCardsHtml(html);
  extractionInspectorSetCopyStatus('Ready: click "Copy Selector JSON" on any segment.');
}

function extractionInspectorRenderAnnotations(data) {
  const annotations = Array.isArray(data?.annotations) ? data.annotations : [];
  if (!annotations.length) {
    extractionInspectorResetCards('No annotations matched the current inspector query.');
    return;
  }
  extractionInspectorCopyPayloads = annotations.map((annotation) =>
    extractionInspectorAnnotationSelector(annotation)
  );
  const html = annotations
    .map((annotation, idx) => {
      const spans = Array.isArray(annotation.spans) ? annotation.spans.length : 0;
      return `
        <article class="inspector-card">
          <h4>${dbEscapeHtml(annotation.layer || 'annotation')} / ${dbEscapeHtml(annotation.category || 'uncategorized')} (#${idx + 1})</h4>
          <p class="inspector-meta">label=${dbEscapeHtml(String(annotation.label || ''))}, spans=${dbEscapeHtml(String(spans))}, source=${dbEscapeHtml(String(annotation.source || 'n/a'))}</p>
          <div class="inspector-copy-row">
            <button class="secondary" type="button" data-copy-idx="${idx}">Copy Selector JSON</button>
          </div>
        </article>
      `;
    })
    .join('');
  extractionInspectorSetCardsHtml(html);
  extractionInspectorSetCopyStatus('Ready: click "Copy Selector JSON" on any annotation.');
}

function extractionInspectorTargetQuery() {
  const id = (document.getElementById('inspect-resource-id').value || '').trim();
  const digest = (document.getElementById('inspect-resource-digest').value || '').trim();
  const runId = (document.getElementById('inspect-run-id').value || '').trim();

  if (!id && !digest) {
    extractionInspectorError('Provide inspector resource ID or digest.');
    return null;
  }

  let qs = id
    ? `resource_id=${encodeURIComponent(id)}`
    : `resource_digest=${encodeURIComponent(digest)}`;
  if (runId) qs += `&extraction_run_id=${encodeURIComponent(runId)}`;
  return qs;
}

function extractionInspectorLimit(defaultValue='200') {
  const raw = (document.getElementById('inspect-limit').value || defaultValue).trim();
  const parsed = Number(raw);
  if (!Number.isFinite(parsed) || parsed <= 0) return defaultValue;
  return String(Math.floor(parsed));
}

async function extractInspectorText() {
  const qs = extractionInspectorTargetQuery();
  if (!qs) return;
  const data = await callApi('GET', `/api/extract/text?${qs}`, null, 'out-extract-inspector');
  if (!data || data.ok !== true || !data.document_text) {
    extractionInspectorResetCards('No extracted text found for this resource/run.');
    return;
  }
  const meta = data.document_text;
  extractionInspectorResetCards(
    `Loaded text: ${meta.char_count || 0} chars (digest ${meta.text_digest_sha256 || 'n/a'}).`
  );
}

async function extractInspectorSegments() {
  const qs = extractionInspectorTargetQuery();
  if (!qs) return;
  const segmentType = (document.getElementById('inspect-segment-type').value || '').trim();
  const limit = extractionInspectorLimit('200');
  let url = `/api/extract/segments?${qs}&limit=${encodeURIComponent(limit)}`;
  if (segmentType) url += `&segment_type=${encodeURIComponent(segmentType)}`;
  const data = await callApi('GET', url, null, 'out-extract-inspector');
  if (!data || data.ok !== true) {
    extractionInspectorError(data?.detail || 'Failed to load segments.');
    return;
  }
  extractionInspectorRenderSegments(data);
}

async function extractInspectorAnnotations() {
  const qs = extractionInspectorTargetQuery();
  if (!qs) return;
  const layer = (document.getElementById('inspect-layer').value || '').trim();
  const category = (document.getElementById('inspect-category').value || '').trim();
  const limit = extractionInspectorLimit('200');
  let url = `/api/extract/annotations?${qs}&limit=${encodeURIComponent(limit)}`;
  if (layer) url += `&layer=${encodeURIComponent(layer)}`;
  if (category) url += `&category=${encodeURIComponent(category)}`;
  const data = await callApi('GET', url, null, 'out-extract-inspector');
  if (!data || data.ok !== true) {
    extractionInspectorError(data?.detail || 'Failed to load annotations.');
    return;
  }
  extractionInspectorRenderAnnotations(data);
}

function extractionInspectorDumpLimit(id, fallback) {
  const raw = (document.getElementById(id).value || String(fallback)).trim();
  const parsed = Number(raw);
  if (!Number.isFinite(parsed) || parsed <= 0) return String(fallback);
  return String(Math.floor(parsed));
}

async function extractInspectorDump() {
  const qs = extractionInspectorTargetQuery();
  if (!qs) return;
  const segmentLimit = extractionInspectorDumpLimit('inspect-segment-limit', 2000);
  const annotationLimit = extractionInspectorDumpLimit('inspect-annotation-limit', 2000);
  const tableLimit = extractionInspectorDumpLimit('inspect-table-limit', 500);
  const url = `/api/extract/dump?${qs}&segment_limit=${encodeURIComponent(segmentLimit)}&annotation_limit=${encodeURIComponent(annotationLimit)}&table_limit=${encodeURIComponent(tableLimit)}`;
  const data = await callApi('GET', url, null, 'out-extract-inspector');
  if (!data || data.ok !== true || !data.dump) {
    extractionInspectorError(data?.detail || 'Failed to load extraction dump.');
    return;
  }
  const dump = data.dump;
  extractionInspectorResetCards(
    `Dump loaded: tables=${(dump.tables || []).length}, segments=${(dump.segments || []).length}, annotations=${(dump.annotations || []).length}.`
  );
}

async function importClaims() {
  await callApi('POST', '/api/claims/import', {
    file_path: document.getElementById('claims-file').value,
    fmt: document.getElementById('claims-format').value,
    claim_set: document.getElementById('claim-set').value
  }, 'out-claims');
}

async function listClaims() {
  const set = encodeURIComponent(document.getElementById('claims-list-set').value || '');
  const url = set ? `/api/claims?claim_set=${set}` : '/api/claims';
  await callApi('GET', url, null, 'out-claims');
}

async function bindAdd() {
  let selectors;
  try {
    selectors = JSON.parse(document.getElementById('bind-selectors').value);
  } catch (e) {
    document.getElementById('out-bind').textContent = JSON.stringify({error: 'Invalid selectors JSON'}, null, 2);
    return;
  }
  await callApi('POST', '/api/bind/add', {
    claim_id: document.getElementById('bind-claim-id').value,
    resource_id: document.getElementById('bind-resource-id').value || null,
    resource_digest: document.getElementById('bind-digest').value || null,
    role: document.getElementById('bind-role').value,
    selectors
  }, 'out-bind');
}

async function bindValidate() {
  await callApi('POST', '/api/bind/validate', {
    claim_id: document.getElementById('bind-claim-id').value
  }, 'out-bind');
}

async function verifyClaim() {
  await callApi('POST', '/api/verify/claim', {
    claim_id: document.getElementById('verify-claim-id').value,
    policy: 'strict'
  }, 'out-verify');
}

async function verifySet() {
  await callApi('POST', '/api/verify/set', {
    claim_set: document.getElementById('verify-claim-set').value,
    policy: 'strict'
  }, 'out-verify');
}

async function reportVerification() {
  const run = encodeURIComponent(document.getElementById('report-run-id').value);
  const jsonOut = encodeURIComponent(document.getElementById('report-json-out').value || '');
  const mdOut = encodeURIComponent(document.getElementById('report-md-out').value || '');
  let qs = `run_id=${run}`;
  if (jsonOut) qs += `&json_out=${jsonOut}`;
  if (mdOut) qs += `&md_out=${mdOut}`;
  await callApi('GET', `/api/report/verification?${qs}`, null, 'out-verify');
}

async function traceClaim() {
  const claim = encodeURIComponent(document.getElementById('trace-claim-id').value);
  await callApi('GET', `/api/trace/claim?claim_id=${claim}`, null, 'out-trace');
}

async function traceResource() {
  const rid = document.getElementById('trace-resource-id').value;
  const digest = document.getElementById('trace-resource-digest').value;
  const qs = rid ? `resource_id=${encodeURIComponent(rid)}` : `resource_digest=${encodeURIComponent(digest)}`;
  await callApi('GET', `/api/trace/resource?${qs}`, null, 'out-trace');
}

async function traceCitation() {
  const cite = encodeURIComponent(document.getElementById('trace-cite-id').value);
  await callApi('GET', `/api/trace/citation?cite_id=${cite}`, null, 'out-trace');
}

async function addProposition() {
  let proposition;
  try {
    proposition = JSON.parse(document.getElementById('ceapf-prop').value);
  } catch (e) {
    document.getElementById('out-ceapf').textContent = JSON.stringify({error: 'Invalid proposition JSON'}, null, 2);
    return;
  }
  const data = await callApi('POST', '/api/ceapf/proposition', { proposition }, 'out-ceapf');
  if (data.proposition_id) document.getElementById('ceapf-prop-id').value = data.proposition_id;
}

async function addAssertion() {
  const data = await callApi('POST', '/api/ceapf/assertion', {
    proposition_id: document.getElementById('ceapf-prop-id').value,
    asserting_agent: document.getElementById('ceapf-agent').value,
    modality: document.getElementById('ceapf-modality').value,
    evidence_id: null
  }, 'out-ceapf');
  if (data.assertion_id) document.getElementById('ceapf-from-id').value = data.assertion_id;
}

async function addRelation() {
  await callApi('POST', '/api/ceapf/relation', {
    relation_type: document.getElementById('ceapf-rel-type').value,
    from_node_type: document.getElementById('ceapf-from-type').value,
    from_node_id: document.getElementById('ceapf-from-id').value,
    to_node_type: document.getElementById('ceapf-to-type').value,
    to_node_id: document.getElementById('ceapf-to-id').value || document.getElementById('ceapf-prop-id').value
  }, 'out-ceapf');
}

async function listPropositions() {
  await callApi('GET', '/api/ceapf/propositions', null, 'out-ceapf');
}

async function runMassImport() {
  const maxRaw = document.getElementById('pipe-max').value.trim();
  const root = (document.getElementById('pipe-root').value || '').trim();
  if (!root) {
    document.getElementById('out-ingest').textContent = JSON.stringify({ error: 'Provide a root path for mass import.' }, null, 2);
    return;
  }
  importStartAnimatedJob({
    name: importPathBasename(root),
    sourceLabel: 'Mass Import',
  });
  let payload;
  try {
    payload = await callApi('POST', '/api/import/mass', {
      root,
      max_files: maxRaw ? Number(maxRaw) : null,
      skip_extraction: document.getElementById('pipe-skip').value === 'true',
      extract_timeout_seconds: Number(document.getElementById('pipe-timeout').value || '300')
    }, 'out-ingest');
  } catch (e) {
    importStopTimers();
    if (!importDropQueueRunning && !importActiveStreamAbortController) {
      navSetPaneActivity('ingest', { active: false });
    }
    const message = String(e);
    importRenderLive(
      { name: importPathBasename(root), sourceLabel: 'Mass Import' },
      {
        title: `Mass Import: ${importPathBasename(root)}`,
        meta: 'Recursive import run failed.',
        statusLine: 'Mass import failed before completion.',
        countersLine: '',
        steps: [
          { ...IMPORT_STEPS[0], state: 'error', detail: message },
          { ...IMPORT_STEPS[1], state: 'skipped', detail: 'Skipped' },
          { ...IMPORT_STEPS[2], state: 'skipped', detail: 'Skipped' },
          { ...IMPORT_STEPS[3], state: 'skipped', detail: 'Skipped' },
        ],
        metrics: [],
        progress: 100,
        progressActive: false,
      }
    );
    importAddHistory({
      statusTone: 'error',
      statusLabel: 'failed',
      name: importPathBasename(root),
      summary: message,
    });
    return;
  }
  importStopTimers();
  if (!importDropQueueRunning && !importActiveStreamAbortController) {
    navSetPaneActivity('ingest', { active: false });
  }

  const stats = payload?.stats || {};
  importRenderLive(
    { name: importPathBasename(root), sourceLabel: 'Mass Import' },
    {
      title: `Mass Import: ${importPathBasename(root)}`,
      meta: 'Recursive import run complete.',
      statusLine: payload?.ok ? 'Mass import completed.' : 'Mass import failed.',
      countersLine: `Processed ${stats.processed ?? 0} file(s), extracted ${stats.extracted ?? 0}, failures ${stats.failed ?? 0}.`,
      steps: [
        { ...IMPORT_STEPS[0], state: 'done', detail: `${stats.ingested ?? 0} ingested, ${stats.duplicates ?? 0} duplicates.` },
        { ...IMPORT_STEPS[1], state: (stats.extracted ?? 0) > 0 ? 'done' : 'skipped', detail: `${stats.extracted ?? 0} extracted.` },
        { ...IMPORT_STEPS[2], state: 'done', detail: 'Batch summaries written to log/state files.' },
        { ...IMPORT_STEPS[3], state: 'done', detail: 'Vector indexing occurs for extracted resources.' },
      ],
      metrics: [
        { k: 'Candidates', v: stats.candidates ?? 0 },
        { k: 'Processed', v: stats.processed ?? 0 },
        { k: 'Extracted', v: stats.extracted ?? 0 },
        { k: 'Failed', v: stats.failed ?? 0 },
      ],
      progress: 100,
      progressActive: false,
    }
  );
  importAddHistory({
    statusTone: payload?.ok ? ((stats.failed ?? 0) > 0 ? 'warn' : 'ok') : 'error',
    statusLabel: payload?.ok ? 'mass run' : 'failed',
    name: importPathBasename(root),
    summary: `processed=${stats.processed ?? 0} extracted=${stats.extracted ?? 0} failed=${stats.failed ?? 0}`,
  });
}

function importDateMs(value) {
  if (!value) return null;
  const ts = Date.parse(String(value));
  return Number.isFinite(ts) ? ts : null;
}

function importStatusFromServer(status) {
  const normalized = String(status || '').toLowerCase();
  if (normalized === 'queued') return 'pending';
  if (normalized === 'processing') return 'processing';
  if (normalized === 'done') return 'done';
  if (normalized === 'failed') return 'failed';
  if (normalized === 'skipped') return 'skipped';
  if (normalized === 'cancelled') return 'cancelled';
  return 'pending';
}

function importStepMapFromServer(progressObj) {
  const safeProgress = (progressObj && typeof progressObj === 'object') ? progressObj : {};
  const rawMap = (safeProgress.step_map && typeof safeProgress.step_map === 'object') ? safeProgress.step_map : {};
  const stepMap = importStreamInitStepState();
  IMPORT_STEPS.forEach((step) => {
    const raw = (rawMap[step.id] && typeof rawMap[step.id] === 'object') ? rawMap[step.id] : {};
    const pageCount = importSafePositiveInt(raw.page_count);
    const pageCurrent = importClampCurrentPage(raw.page_current ?? raw.current_page, pageCount);
    const previewRaw = (raw.preview && typeof raw.preview === 'object') ? { ...raw.preview } : null;
    if (previewRaw && !importSafePositiveInt(previewRaw.page_count) && pageCount) {
      previewRaw.page_count = pageCount;
    }
    stepMap[step.id] = {
      state: String(raw.state || stepMap[step.id].state || 'pending'),
      progress: Number.isFinite(Number(raw.progress))
        ? Number(raw.progress)
        : stepMap[step.id].progress,
      detail: String(raw.detail || stepMap[step.id].detail || ''),
      stats: String(raw.stats || stepMap[step.id].stats || ''),
      page_count: pageCount,
      page_current: pageCurrent,
      preview: importNormalizePreviewSignal(previewRaw),
    };
  });
  return stepMap;
}

function importDebugSyncFromQueueTarget(target, stepMap, statusText, countersText) {
  if (!target || typeof target !== 'object') return;
  const queueJobId = String(target?.id || '');
  const changedJob = importDebugMode !== 'queue' || importDebugQueueJobId !== queueJobId;
  if (changedJob) {
    importDebugReset(
      {
        name: String(target?.original_filename || 'Background Import'),
        sourceLabel: 'Background Queue',
        queueJobId,
        sizeBytes: Number(target?.size_bytes || 0),
      },
      'queue'
    );
    importDebugQueueJobId = queueJobId;
    importDebugQueueEventCursor = 0;
    importDebugPush(
      'queue_target_selected',
      { queue_job_id: queueJobId, status: String(target?.status || '') },
      { source: 'queue' }
    );
  }

  importDebugSetLiveSnapshot(statusText, countersText, stepMap);

  const progressObj = (target?.progress && typeof target.progress === 'object') ? target.progress : {};
  const queuedEvents = Array.isArray(progressObj?.events) ? progressObj.events : [];
  if (importDebugQueueEventCursor > queuedEvents.length) {
    importDebugQueueEventCursor = 0;
  }
  for (let idx = importDebugQueueEventCursor; idx < queuedEvents.length; idx += 1) {
    importDebugPush('queue_progress_event', queuedEvents[idx], { source: 'queue' });
  }
  importDebugQueueEventCursor = queuedEvents.length;

  importDebugRender({
    queue_job_id: queueJobId,
    queue_status: String(target?.status || ''),
    queue_detail: String(target?.detail || ''),
    queue_updated_at: target?.updated_at || null,
  });
}

function importApplyServerQueueState(payload) {
  const jobs = Array.isArray(payload?.jobs) ? payload.jobs : [];
  importDropQueue = jobs.map((job, idx) => {
    const status = importStatusFromServer(job?.status);
    const startedAtMs = importDateMs(job?.started_at);
    const finishedAtMs = importDateMs(job?.finished_at);
    const elapsedMs = (startedAtMs && finishedAtMs) ? Math.max(0, finishedAtMs - startedAtMs) : null;
    return {
      id: String(job?.id || `job-${idx}`),
      name: String(job?.original_filename || `Queued File ${idx + 1}`),
      sizeBytes: Number(job?.size_bytes || 0),
      status,
      detail: String(job?.detail || ''),
      queuedAtMs: importDateMs(job?.created_at),
      startedAtMs,
      finishedAtMs,
      elapsedMs,
      resourceId: job?.resource_id || null,
      progress: job?.progress && typeof job.progress === 'object' ? job.progress : null,
      cancelRequested: Boolean(job?.cancel_requested),
      cancelAction: job?.cancel_action ? String(job.cancel_action) : null,
      previewUrl: `/api/import/queue/jobs/${encodeURIComponent(String(job?.id || `job-${idx}`))}/content`,
    };
  });

  const queueSummary = payload?.queue && typeof payload.queue === 'object' ? payload.queue : {};
  const queuedCount = Number(queueSummary.queued || 0);
  const processingCount = Number(queueSummary.processing || 0);
  importDropQueueRunning = Number(queueSummary.processing || 0) > 0 || Number(queueSummary.queued || 0) > 0;
  const processingItem = importDropQueue.find((item) => item.status === 'processing') || null;
  importDropQueueActiveId = processingItem ? processingItem.id : null;
  const processingJob = jobs.find((job) => String(job?.status || '').toLowerCase() === 'processing') || null;
  if (processingJob) {
    const stepMap = importStepMapFromServer(processingJob?.progress);
    const progress = importStreamOverallProgress(stepMap);
    navSetPaneActivity('ingest', {
      active: true,
      percent: progress,
      indeterminate: progress <= 0,
      title: `Import ${progress}%`,
    });
  } else if (queuedCount > 0) {
    navSetPaneActivity('ingest', {
      active: true,
      indeterminate: true,
      title: `${queuedCount} import job${queuedCount === 1 ? '' : 's'} queued`,
    });
  } else if (processingCount > 0) {
    navSetPaneActivity('ingest', {
      active: true,
      indeterminate: true,
      title: `${processingCount} import job${processingCount === 1 ? '' : 's'} finishing`,
    });
  } else if (!importActiveStreamAbortController) {
    navSetPaneActivity('ingest', { active: false });
  }
  if (!processingItem && !importActiveStreamAbortController) {
    importQueueEtaJobId = null;
    importActiveEta = null;
    importActiveStepMap = null;
  }
  importDeferRequestedItemId = null;

  importRenderDropQueue();
  importRenderLiveFromServerQueue(payload);
}

function importRenderLiveFromServerQueue(payload) {
  if (importActiveStreamAbortController) return;
  const jobs = Array.isArray(payload?.jobs) ? payload.jobs : [];
  if (!jobs.length) return;
  const processing = jobs.find((job) => String(job?.status || '').toLowerCase() === 'processing') || null;
  const target = processing || jobs[jobs.length - 1];
  if (!target) return;

  const stepMap = importStepMapFromServer(target?.progress);
  const statusLine = String(target?.progress?.status_line || target?.detail || '');
  const countersLine = String(target?.progress?.counters_line || '');
  const queueJobId = String(target?.id || '');
  const meta = {
    name: String(target?.original_filename || 'Background Import'),
    sourceLabel: 'Background Queue',
    sizeBytes: Number(target?.size_bytes || 0),
    queueJobId,
    previewUrl: queueJobId ? `/api/import/queue/jobs/${encodeURIComponent(queueJobId)}/content` : '',
  };
  let statusText = statusLine || (processing ? 'Import running in background...' : 'Import finished in background.');
  let countersText = countersLine;
  if (processing && queueJobId) {
    if (!importActiveEta || importQueueEtaJobId !== queueJobId) {
      importActiveEta = importEtaStart(meta);
      importQueueEtaJobId = queueJobId;
    }
    const startedAtMs = importDateMs(target?.started_at);
    if (startedAtMs) {
      importActiveEta.startedAtMs = startedAtMs;
    }
    const updatedAtMs = importDateMs(target?.updated_at);
    if (updatedAtMs) {
      importActiveEta.lastHeartbeatMs = updatedAtMs;
    }
    importActiveStepMap = stepMap;
    const eta = importEtaEstimate(stepMap);
    statusText = importStatusLineWithHeartbeat(statusText, eta);
    countersText = importCounterLineWithEta(countersLine, eta);
  } else if (!processing && importQueueEtaJobId === queueJobId) {
    importQueueEtaJobId = null;
    importActiveEta = null;
    importActiveStepMap = null;
  }
  importDebugSyncFromQueueTarget(target, stepMap, statusText, countersText);
  importRenderLive(meta, {
    title: meta.name || 'Background Import',
    meta: `Background queue  job ${String(target?.id || '').slice(0, 8)}`,
    statusLine: statusText,
    countersLine: countersText,
    steps: importStreamStepArray(stepMap),
    metrics: [],
    progress: importStreamOverallProgress(stepMap),
    progressActive: Boolean(processing),
  });
}

async function importRefreshServerQueue(force = false) {
  if (importQueuePollInFlight && !force) return;
  importQueuePollInFlight = true;
  try {
    const payload = await callApi('GET', '/api/import/queue/status?limit=10000', null, null);
    if (payload?.ok) importApplyServerQueueState(payload);
  } catch (err) {
    if (force) {
      console.warn('Unable to refresh background import queue state.', err);
    }
  } finally {
    importQueuePollInFlight = false;
  }
}

function importStartServerQueuePolling() {
  if (importQueuePollTimer) return;
  importRefreshServerQueue(true);
  importQueuePollTimer = setInterval(() => {
    importRefreshServerQueue(false);
  }, 2500);
}

function importSetDropScanStatus(message, tone = 'active', autoClearMs = 0) {
  const el = document.getElementById('dropzone-scan-status');
  if (!el) return;
  if (importDropScanClearTimer) {
    clearTimeout(importDropScanClearTimer);
    importDropScanClearTimer = null;
  }
  const text = String(message || '').trim();
  if (!text) {
    el.textContent = '';
    el.className = 'dropzone-scan-status';
    return;
  }
  const safeTone = ['active', 'ok', 'warn', 'error'].includes(String(tone || ''))
    ? String(tone)
    : 'active';
  el.textContent = text;
  el.className = `dropzone-scan-status ${safeTone}`;
  if (Number.isFinite(Number(autoClearMs)) && Number(autoClearMs) > 0) {
    importDropScanClearTimer = setTimeout(() => {
      el.textContent = '';
      el.className = 'dropzone-scan-status';
      importDropScanClearTimer = null;
    }, Number(autoClearMs));
  }
}

function importDropScanSnapshot(stats) {
  const now = Date.now();
  const startedAt = Number(stats?.startedAtMs || now);
  const elapsedMs = Math.max(0, now - startedAt);
  return {
    totalFound: Number(stats?.totalFound || 0),
    directories: Number(stats?.directories || 0),
    entriesVisited: Number(stats?.entriesVisited || 0),
    unsupported: Number(stats?.unsupported || 0),
    duplicates: Number(stats?.duplicates || 0),
    errors: Number(stats?.errors || 0),
    elapsedMs,
  };
}

function importReportDropScanProgress(stats, onProgress, force = false) {
  if (typeof onProgress !== 'function') return;
  const now = Date.now();
  const last = Number(stats?.lastProgressAtMs || 0);
  const visited = Number(stats?.entriesVisited || 0);
  if (!force && visited > 0 && visited % 20 !== 0 && (now - last) < 220) return;
  stats.lastProgressAtMs = now;
  onProgress(importDropScanSnapshot(stats));
}

function importDropFileExt(name) {
  const safe = String(name || '').trim().toLowerCase();
  const idx = safe.lastIndexOf('.');
  if (idx < 0) return '';
  return safe.slice(idx);
}

function importCanQueueDropFile(file) {
  if (!file || typeof file.name !== 'string') return false;
  const ext = importDropFileExt(file.name);
  if (ext && IMPORT_DROP_ALLOWED_EXTENSIONS.has(ext)) return true;
  const media = String(file.type || '').trim().toLowerCase();
  if (!media) return false;
  if (IMPORT_DROP_ALLOWED_MIME_TYPES.has(media)) return true;
  if (media.startsWith('text/')) return true;
  return false;
}

function importReadWebkitDirectoryEntries(dirEntry) {
  return new Promise((resolve, reject) => {
    try {
      const reader = dirEntry.createReader();
      const allEntries = [];
      const readChunk = () => {
        reader.readEntries(
          (entries) => {
            if (!entries || !entries.length) {
              resolve(allEntries);
              return;
            }
            allEntries.push(...entries);
            readChunk();
          },
          (err) => reject(err)
        );
      };
      readChunk();
    } catch (err) {
      reject(err);
    }
  });
}

function importReadWebkitFileEntry(fileEntry) {
  return new Promise((resolve, reject) => {
    try {
      fileEntry.file(
        (file) => resolve(file),
        (err) => reject(err)
      );
    } catch (err) {
      reject(err);
    }
  });
}

async function importCollectDropFilesFromWebkitEntry(entry, files, stats, onProgress = null) {
  if (!entry) return;
  if (entry.isFile) {
    stats.entriesVisited += 1;
    try {
      const file = await importReadWebkitFileEntry(entry);
      if (file) {
        files.push(file);
        stats.totalFound += 1;
      }
    } catch {
      stats.errors += 1;
    }
    importReportDropScanProgress(stats, onProgress, false);
    return;
  }
  if (!entry.isDirectory) return;
  stats.entriesVisited += 1;
  stats.directories += 1;
  importReportDropScanProgress(stats, onProgress, false);
  let children = [];
  try {
    children = await importReadWebkitDirectoryEntries(entry);
  } catch {
    stats.errors += 1;
    importReportDropScanProgress(stats, onProgress, true);
    return;
  }
  for (const child of children) {
    // Keep order deterministic for easier queue progress debugging.
    await importCollectDropFilesFromWebkitEntry(child, files, stats, onProgress);
  }
}

async function importCollectDropFilesFromHandle(handle, files, stats, onProgress = null) {
  if (!handle) return;
  if (handle.kind === 'file') {
    stats.entriesVisited += 1;
    try {
      const file = await handle.getFile();
      if (file) {
        files.push(file);
        stats.totalFound += 1;
      }
    } catch {
      stats.errors += 1;
    }
    importReportDropScanProgress(stats, onProgress, false);
    return;
  }
  if (handle.kind !== 'directory') return;
  stats.entriesVisited += 1;
  stats.directories += 1;
  importReportDropScanProgress(stats, onProgress, false);
  try {
    // FileSystemDirectoryHandle is async-iterable.
    for await (const [, child] of handle.entries()) {
      await importCollectDropFilesFromHandle(child, files, stats, onProgress);
    }
  } catch {
    stats.errors += 1;
    importReportDropScanProgress(stats, onProgress, true);
  }
}

function importDeduplicateDropFiles(files) {
  const out = [];
  const seen = new Set();
  let duplicates = 0;
  for (const file of files) {
    const key = [
      String(file?.name || ''),
      Number(file?.size || 0),
      Number(file?.lastModified || 0),
      String(file?.type || ''),
    ].join('::');
    if (seen.has(key)) {
      duplicates += 1;
      continue;
    }
    seen.add(key);
    out.push(file);
  }
  return { files: out, duplicates };
}

async function importCollectDropFiles(dataTransfer, onProgress = null) {
  const files = [];
  const stats = {
    startedAtMs: Date.now(),
    lastProgressAtMs: 0,
    totalFound: 0,
    directories: 0,
    entriesVisited: 0,
    unsupported: 0,
    duplicates: 0,
    errors: 0,
  };
  importReportDropScanProgress(stats, onProgress, true);
  const items = Array.from(dataTransfer?.items || []).filter(Boolean);

  if (items.length) {
    const supportsHandles = items.some((item) => typeof item?.getAsFileSystemHandle === 'function');
    if (supportsHandles) {
      for (const item of items) {
        if (typeof item?.getAsFileSystemHandle !== 'function') continue;
        let handle = null;
        try {
          handle = await item.getAsFileSystemHandle();
        } catch {
          continue;
        }
        if (!handle) continue;
        await importCollectDropFilesFromHandle(handle, files, stats, onProgress);
      }
    }
  }

  if (!files.length && items.length) {
    const supportsWebkitEntries = items.some((item) => typeof item?.webkitGetAsEntry === 'function');
    if (supportsWebkitEntries) {
      for (const item of items) {
        if (typeof item?.webkitGetAsEntry !== 'function') continue;
        const entry = item.webkitGetAsEntry();
        if (!entry) continue;
        await importCollectDropFilesFromWebkitEntry(entry, files, stats, onProgress);
      }
    }
  }

  if (!files.length) {
    const fallbackFiles = Array.from(dataTransfer?.files || []).filter((file) => file && typeof file.name === 'string');
    stats.totalFound += fallbackFiles.length;
    files.push(...fallbackFiles);
  }

  const deduped = importDeduplicateDropFiles(files);
  stats.duplicates = deduped.duplicates;
  const importable = [];
  for (const file of deduped.files) {
    if (importCanQueueDropFile(file)) importable.push(file);
    else stats.unsupported += 1;
  }
  importReportDropScanProgress(stats, onProgress, true);

  return {
    files: importable,
    totalFound: stats.totalFound,
    directories: stats.directories,
    unsupported: stats.unsupported,
    duplicates: stats.duplicates,
    errors: stats.errors,
  };
}

async function importQueueEnqueueFiles(fileList) {
  const files = Array.from(fileList || []).filter((file) => file && typeof file.name === 'string');
  if (!files.length) return { attempted: 0, queued: 0, failed: 0 };
  let queued = 0;
  let failed = 0;
  for (const file of files) {
    let message = '';
    try {
      const fd = new FormData();
      fd.append('file', file);
      const payload = await callApi('POST', '/api/import/queue/enqueue-upload', fd, null, true);
      if (!payload?.ok) {
        message = String(payload?.detail || payload?.error || 'Failed to enqueue file.');
      }
    } catch (err) {
      message = String(err || 'Failed to enqueue file.');
    }
    if (message) {
      failed += 1;
      importAddHistory({
        statusTone: 'error',
        statusLabel: 'failed',
        name: file.name || 'document',
        summary: message,
      });
    } else {
      queued += 1;
    }
  }
  await importRefreshServerQueue(true);
  return { attempted: files.length, queued, failed };
}

async function importProcessDropQueue() {
  await importRefreshServerQueue(true);
}

const dz = document.getElementById('dropzone');
function prevent(e) { e.preventDefault(); e.stopPropagation(); }
['dragenter','dragover','dragleave','drop'].forEach(evt => dz.addEventListener(evt, prevent));
['dragenter','dragover'].forEach(evt => dz.addEventListener(evt, () => dz.classList.add('drag')));
['dragleave','drop'].forEach(evt => dz.addEventListener(evt, () => dz.classList.remove('drag')));
dz.addEventListener('drop', async (e) => {
  try {
    importSetDropScanStatus('Scan in progress preparing dropped content.', 'active');
    const dropped = await importCollectDropFiles(e.dataTransfer, (snapshot) => {
      const elapsedSec = (Math.max(0, Number(snapshot.elapsedMs || 0)) / 1000).toFixed(1);
      importSetDropScanStatus(
        `Scan in progress ${snapshot.entriesVisited} items checked  ${snapshot.directories} folder(s)  ${snapshot.totalFound} file(s) found  ${elapsedSec}s`,
        'active'
      );
    });
    if (!dropped.files.length) {
      const detail = dropped.totalFound > 0
        ? `No importable files found in drop (${dropped.unsupported} unsupported, ${dropped.duplicates} duplicates skipped).`
        : 'No files found in dropped content.';
      importSetDropScanStatus(detail, 'warn', 5000);
      importAddHistory({
        statusTone: 'warn',
        statusLabel: 'skipped',
        name: 'drag-and-drop batch',
        summary: detail,
      });
      return;
    }

    const result = await importQueueEnqueueFiles(dropped.files);
    const folderNote = dropped.directories > 0 ? ` from ${dropped.directories} folder(s)` : '';
    const skippedBits = [];
    if (dropped.unsupported > 0) skippedBits.push(`${dropped.unsupported} unsupported`);
    if (dropped.duplicates > 0) skippedBits.push(`${dropped.duplicates} duplicate(s)`);
    if (dropped.errors > 0) skippedBits.push(`${dropped.errors} unreadable`);
    const skippedText = skippedBits.length ? ` (${skippedBits.join(', ')} skipped)` : '';
    importSetDropScanStatus(
      `Scan complete. Queued ${result.queued}/${result.attempted} file(s)${folderNote}${skippedText}.`,
      result.failed > 0 && result.queued <= 0 ? 'error' : 'ok',
      6000
    );
    importAddHistory({
      statusTone: result.failed > 0 && result.queued <= 0 ? 'error' : 'ok',
      statusLabel: result.failed > 0 && result.queued <= 0 ? 'failed' : 'queued',
      name: 'drag-and-drop batch',
      summary: `Queued ${result.queued}/${result.attempted} file(s)${folderNote}${skippedText}.`,
    });
  } catch (err) {
    importSetDropScanStatus(
      `Scan failed: ${String(err || 'Unable to enumerate dropped content.')}`,
      'error',
      7000
    );
    importAddHistory({
      statusTone: 'error',
      statusLabel: 'failed',
      name: 'drag-and-drop batch',
      summary: String(err || 'Failed to enqueue dropped files.'),
    });
  }
});

document.getElementById('help-modal').addEventListener('click', (e) => {
  if (e.target.id === 'help-modal') closeHelp();
});
initTheme();
initWorkspaceNav();
installHelpButtons();
initDbExplorer();
initDocumentViewer();
initVectorPane();
initSourcesPane();
initResizableOutputs();
dbListTables();
loadDashboard();
vectorStatus();
importStartServerQueuePolling();
</script>
</body>
</html>
