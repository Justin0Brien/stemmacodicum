<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Stemma Codicum</title>
  <style>
    @import url("https://fonts.googleapis.com/css2?family=Sora:wght@400;600;700;800&family=IBM+Plex+Sans:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;600&display=swap");
    :root {
      --font-display: "Sora", "Avenir Next", "Trebuchet MS", sans-serif;
      --font-sans: "IBM Plex Sans", "Source Sans 3", "Gill Sans", sans-serif;
      --font-mono: "IBM Plex Mono", "SFMono-Regular", Menlo, Consolas, monospace;
      --bg: #f5f7fb;
      --card: #ffffff;
      --text: #1d2736;
      --muted: #5a6475;
      --accent: #0f766e;
      --accent-2: #164e63;
      --border: #d6dee8;
      --error: #b42318;
      --button-secondary-bg: #334155;
      --button-secondary-text: #ffffff;
      --pre-bg: #0b1727;
      --pre-fg: #d7ebff;
      --drop-bg: #f0fdfb;
      --drop-drag-bg: #dcfce7;
      --help-overlay: rgba(7, 16, 28, 0.62);
      --help-panel-bg: #ffffff;
      --help-code-bg: #eef2f7;
      --help-code-fg: #1d2736;
      --help-icon-bg: #e8eef8;
      --help-icon-fg: #1f3555;
      --hero-grad-start: #164e63;
      --hero-grad-end: #1f6f8b;
      --surface-tint: rgba(255, 255, 255, 0.6);
      --surface-shadow: 0 16px 36px rgba(20, 42, 70, 0.14);
      --surface-shadow-soft: 0 8px 22px rgba(20, 42, 70, 0.09);
      --focus-ring: 0 0 0 3px rgba(15, 118, 110, 0.25);
    }
    body[data-theme="harmonious-light"] {
      --bg: #f5f7fb;
      --card: #ffffff;
      --text: #1d2736;
      --muted: #5a6475;
      --accent: #0f766e;
      --accent-2: #164e63;
      --border: #d6dee8;
      --button-secondary-bg: #334155;
      --button-secondary-text: #ffffff;
      --pre-bg: #0b1727;
      --pre-fg: #d7ebff;
      --drop-bg: #f0fdfb;
      --drop-drag-bg: #dcfce7;
      --help-overlay: rgba(7, 16, 28, 0.62);
      --help-panel-bg: #ffffff;
      --help-code-bg: #eef2f7;
      --help-code-fg: #1d2736;
      --help-icon-bg: #e8eef8;
      --help-icon-fg: #1f3555;
      --hero-grad-start: #164e63;
      --hero-grad-end: #1f6f8b;
      --surface-tint: rgba(255, 255, 255, 0.64);
      --surface-shadow: 0 16px 36px rgba(20, 42, 70, 0.14);
      --surface-shadow-soft: 0 8px 22px rgba(20, 42, 70, 0.09);
      --focus-ring: 0 0 0 3px rgba(15, 118, 110, 0.25);
    }
    body[data-theme="restful-dark"] {
      --bg: #10171f;
      --card: #17212d;
      --text: #e9eef7;
      --muted: #a5b3c5;
      --accent: #169a8f;
      --accent-2: #1a405f;
      --border: #2e3d50;
      --button-secondary-bg: #2a3b50;
      --button-secondary-text: #e9eef7;
      --pre-bg: #0a111b;
      --pre-fg: #d7e8ff;
      --drop-bg: #12272b;
      --drop-drag-bg: #15363a;
      --help-overlay: rgba(4, 8, 13, 0.74);
      --help-panel-bg: #17212d;
      --help-code-bg: #243445;
      --help-code-fg: #e9eef7;
      --help-icon-bg: #2c3f56;
      --help-icon-fg: #f6fbff;
      --hero-grad-start: #1a405f;
      --hero-grad-end: #123043;
      --surface-tint: rgba(255, 255, 255, 0.03);
      --surface-shadow: 0 16px 36px rgba(0, 0, 0, 0.35);
      --surface-shadow-soft: 0 8px 22px rgba(0, 0, 0, 0.24);
      --focus-ring: 0 0 0 3px rgba(22, 154, 143, 0.3);
    }
    body[data-theme="sunset-paper"] {
      --bg: #f8f2ea;
      --card: #fffdf9;
      --text: #2e1f22;
      --muted: #6f5a5f;
      --accent: #b4532a;
      --accent-2: #7f3b5e;
      --border: #e8d8cd;
      --button-secondary-bg: #5d4b57;
      --button-secondary-text: #fff9f6;
      --pre-bg: #2a1f2b;
      --pre-fg: #f3e8ff;
      --drop-bg: #fff4ea;
      --drop-drag-bg: #ffe8d6;
      --help-overlay: rgba(35, 18, 24, 0.58);
      --help-panel-bg: #fffdf9;
      --help-code-bg: #f8ece5;
      --help-code-fg: #2e1f22;
      --help-icon-bg: #f4dfd0;
      --help-icon-fg: #4a2c2f;
      --hero-grad-start: #7f3b5e;
      --hero-grad-end: #b4532a;
      --surface-tint: rgba(255, 253, 249, 0.66);
      --surface-shadow: 0 16px 36px rgba(72, 40, 52, 0.18);
      --surface-shadow-soft: 0 8px 22px rgba(72, 40, 52, 0.12);
      --focus-ring: 0 0 0 3px rgba(180, 83, 42, 0.27);
    }
    body[data-theme="forest-mist"] {
      --bg: #eef5f1;
      --card: #fbfffd;
      --text: #1d312a;
      --muted: #4d6a62;
      --accent: #1f8f63;
      --accent-2: #264f4a;
      --border: #cfe0d8;
      --button-secondary-bg: #355a53;
      --button-secondary-text: #f3fffb;
      --pre-bg: #132b26;
      --pre-fg: #c8f2e7;
      --drop-bg: #effaf5;
      --drop-drag-bg: #dcf2e7;
      --help-overlay: rgba(12, 28, 24, 0.58);
      --help-panel-bg: #fbfffd;
      --help-code-bg: #e5f3ed;
      --help-code-fg: #1d312a;
      --help-icon-bg: #d9ebe4;
      --help-icon-fg: #193e36;
      --hero-grad-start: #264f4a;
      --hero-grad-end: #1f8f63;
      --surface-tint: rgba(251, 255, 253, 0.68);
      --surface-shadow: 0 16px 36px rgba(19, 52, 44, 0.16);
      --surface-shadow-soft: 0 8px 22px rgba(19, 52, 44, 0.1);
      --focus-ring: 0 0 0 3px rgba(31, 143, 99, 0.27);
    }
    body[data-theme="midnight-contrast"] {
      --bg: #090e16;
      --card: #131b28;
      --text: #f5f9ff;
      --muted: #b9c5d9;
      --accent: #00b3a4;
      --accent-2: #223756;
      --border: #33465f;
      --button-secondary-bg: #394d68;
      --button-secondary-text: #f5f9ff;
      --pre-bg: #03070f;
      --pre-fg: #ecf5ff;
      --drop-bg: #102228;
      --drop-drag-bg: #16353c;
      --help-overlay: rgba(0, 0, 0, 0.78);
      --help-panel-bg: #131b28;
      --help-code-bg: #2a3f5b;
      --help-code-fg: #f5f9ff;
      --help-icon-bg: #304760;
      --help-icon-fg: #ffffff;
      --hero-grad-start: #223756;
      --hero-grad-end: #00b3a4;
      --surface-tint: rgba(255, 255, 255, 0.03);
      --surface-shadow: 0 16px 36px rgba(0, 0, 0, 0.44);
      --surface-shadow-soft: 0 8px 22px rgba(0, 0, 0, 0.31);
      --focus-ring: 0 0 0 3px rgba(0, 179, 164, 0.29);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: var(--font-sans);
      color: var(--text);
      min-height: 100vh;
      background:
        radial-gradient(1000px 520px at -10% -20%, color-mix(in srgb, var(--accent) 20%, transparent), transparent 60%),
        radial-gradient(820px 480px at 108% 18%, color-mix(in srgb, var(--accent-2) 18%, transparent), transparent 62%),
        linear-gradient(180deg, color-mix(in srgb, var(--bg) 65%, #ffffff) 0%, var(--bg) 100%);
      position: relative;
      overflow-x: hidden;
    }
    body::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      opacity: 0.45;
      background-image:
        linear-gradient(to right, color-mix(in srgb, var(--border) 26%, transparent) 1px, transparent 1px),
        linear-gradient(to bottom, color-mix(in srgb, var(--border) 20%, transparent) 1px, transparent 1px);
      background-size: 42px 42px;
      z-index: -2;
    }
    body::after {
      content: "";
      position: fixed;
      width: 44vw;
      height: 44vw;
      min-width: 320px;
      min-height: 320px;
      border-radius: 999px;
      right: -16vw;
      bottom: -18vw;
      background: radial-gradient(circle at 35% 35%, color-mix(in srgb, var(--accent) 24%, transparent), transparent 70%);
      filter: blur(18px);
      pointer-events: none;
      z-index: -1;
    }
    header {
      padding: 34px 28px 28px;
      background:
        linear-gradient(132deg, var(--hero-grad-start), var(--hero-grad-end)),
        radial-gradient(circle at 10% 10%, rgba(255, 255, 255, 0.2), transparent 46%);
      color: #fff;
      position: relative;
      overflow: hidden;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    }
    header::after {
      content: "";
      position: absolute;
      inset: auto -18% -36% 36%;
      height: 340px;
      background: radial-gradient(circle at center, rgba(255, 255, 255, 0.24), transparent 72%);
      pointer-events: none;
    }
    .header-top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 22px;
      margin-bottom: 10px;
      position: relative;
      z-index: 1;
    }
    .brand-block {
      max-width: 760px;
    }
    header h1 {
      margin: 0;
      font-family: var(--font-display);
      font-size: clamp(28px, 4.8vw, 46px);
      line-height: 1.05;
      letter-spacing: 0.01em;
      text-shadow: 0 6px 20px rgba(4, 18, 40, 0.28);
    }
    .hero-subtitle {
      margin: 10px 0 0;
      opacity: 0.95;
      font-size: 15px;
      line-height: 1.45;
      max-width: 640px;
      color: rgba(255, 255, 255, 0.95);
    }
    .theme-picker {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      color: rgba(255, 255, 255, 0.97);
      font-weight: 600;
      font-size: 13px;
      padding: 8px 10px;
      border-radius: 12px;
      background: rgba(9, 26, 42, 0.22);
      backdrop-filter: blur(6px);
      border: 1px solid rgba(255, 255, 255, 0.24);
      box-shadow: 0 12px 26px rgba(0, 0, 0, 0.18);
    }
    .theme-picker select {
      min-width: 220px;
      border-color: rgba(255, 255, 255, 0.32);
      background: rgba(255, 255, 255, 0.14);
      color: #ffffff;
      padding: 6px 10px;
    }
    .theme-picker select option {
      color: #0f172a;
      background: #ffffff;
    }
    @media (max-width: 720px) {
      header {
        padding: 26px 16px 22px;
      }
      .header-top {
        flex-direction: column;
        align-items: flex-start;
        gap: 14px;
      }
      .theme-picker {
        width: 100%;
      }
      .theme-picker select {
        min-width: 0;
        width: 100%;
      }
    }
    .app-shell {
      max-width: 1380px;
      margin: 0 auto;
      padding: 24px 20px 34px;
      display: grid;
      grid-template-columns: 280px minmax(0, 1fr);
      gap: 16px;
      align-items: start;
      position: relative;
    }
    .nav-column {
      background: linear-gradient(165deg, color-mix(in srgb, var(--card) 92%, var(--surface-tint)) 0%, var(--card) 100%);
      border: 1px solid var(--border);
      border-radius: 18px;
      box-shadow: var(--surface-shadow-soft);
      padding: 14px;
      position: sticky;
      top: 14px;
      max-height: calc(100vh - 28px);
      overflow: auto;
      backdrop-filter: blur(8px);
    }
    .nav-title {
      margin: 0 0 4px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      font-family: var(--font-display);
      color: var(--text);
      opacity: 0.74;
    }
    .nav-copy {
      margin: 0 0 12px;
      line-height: 1.35;
    }
    .nav-list {
      display: grid;
      gap: 8px;
    }
    .nav-btn {
      text-align: left;
      width: 100%;
      border: 1px solid var(--border);
      border-radius: 11px;
      padding: 10px 12px;
      font-weight: 600;
      color: var(--text);
      background: color-mix(in srgb, var(--card) 94%, var(--surface-tint));
      transition: transform 120ms ease, background 170ms ease, border-color 170ms ease, box-shadow 170ms ease;
      animation: navSlideIn 220ms ease both;
    }
    .nav-list .nav-btn:nth-child(1) { animation-delay: 20ms; }
    .nav-list .nav-btn:nth-child(2) { animation-delay: 35ms; }
    .nav-list .nav-btn:nth-child(3) { animation-delay: 50ms; }
    .nav-list .nav-btn:nth-child(4) { animation-delay: 65ms; }
    .nav-list .nav-btn:nth-child(5) { animation-delay: 80ms; }
    .nav-list .nav-btn:nth-child(6) { animation-delay: 95ms; }
    .nav-list .nav-btn:nth-child(7) { animation-delay: 110ms; }
    .nav-list .nav-btn:nth-child(8) { animation-delay: 125ms; }
    .nav-list .nav-btn:nth-child(9) { animation-delay: 140ms; }
    .nav-list .nav-btn:nth-child(10) { animation-delay: 155ms; }
    .nav-list .nav-btn:nth-child(11) { animation-delay: 170ms; }
    .nav-list .nav-btn:nth-child(12) { animation-delay: 185ms; }
    .nav-list .nav-btn:nth-child(13) { animation-delay: 200ms; }
    .nav-list .nav-btn:nth-child(14) { animation-delay: 215ms; }
    .nav-list .nav-btn:nth-child(15) { animation-delay: 230ms; }
    .nav-list .nav-btn:nth-child(16) { animation-delay: 245ms; }
    .nav-list .nav-btn:nth-child(17) { animation-delay: 260ms; }
    .nav-list .nav-btn:nth-child(18) { animation-delay: 275ms; }
    .nav-list .nav-btn:nth-child(19) { animation-delay: 290ms; }
    .nav-list .nav-btn:nth-child(20) { animation-delay: 305ms; }
    .nav-list .nav-btn:nth-child(21) { animation-delay: 320ms; }
    .nav-list .nav-btn:nth-child(22) { animation-delay: 335ms; }
    .nav-list .nav-btn:nth-child(23) { animation-delay: 350ms; }
    .nav-list .nav-btn:nth-child(24) { animation-delay: 365ms; }
    .nav-list .nav-btn:nth-child(25) { animation-delay: 380ms; }
    }
    .nav-btn:hover {
      transform: translateX(2px);
      border-color: color-mix(in srgb, var(--accent) 32%, var(--border));
      box-shadow: 0 8px 18px rgba(15, 23, 42, 0.12);
      filter: none;
    }
    .nav-btn.active {
      background: linear-gradient(140deg, color-mix(in srgb, var(--accent) 72%, #ffffff 8%), color-mix(in srgb, var(--accent-2) 76%, #ffffff 8%));
      color: #f8feff;
      border-color: color-mix(in srgb, var(--accent) 58%, transparent);
      box-shadow: 0 12px 24px rgba(15, 23, 42, 0.2);
    }
    .workspace {
      min-width: 0;
    }
    .workspace-head {
      background: linear-gradient(150deg, color-mix(in srgb, var(--card) 90%, var(--surface-tint)), var(--card));
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 15px 16px;
      margin-bottom: 14px;
      box-shadow: var(--surface-shadow-soft);
      backdrop-filter: blur(8px);
    }
    .workspace-head h2 {
      margin: 0 0 2px;
      font-family: var(--font-display);
      font-size: 15px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      opacity: 0.72;
    }
    .workspace-head p {
      margin: 0;
      color: color-mix(in srgb, var(--text) 72%, var(--muted));
      font-size: 23px;
      font-family: var(--font-display);
      font-weight: 700;
      letter-spacing: 0.01em;
    }
    .workspace-panel {
      display: none;
    }
    .workspace-panel.active {
      display: block;
      animation: panelFade 220ms ease;
    }
    .card {
      background:
        linear-gradient(170deg, color-mix(in srgb, var(--card) 92%, var(--surface-tint)) 0%, var(--card) 100%);
      border: 1px solid var(--border);
      border-radius: 18px;
      box-shadow: var(--surface-shadow-soft);
      padding: 16px;
      position: relative;
      backdrop-filter: blur(7px);
      overflow: hidden;
    }
    .card::after {
      content: "";
      position: absolute;
      inset: 0;
      pointer-events: none;
      background: linear-gradient(120deg, color-mix(in srgb, var(--accent) 8%, transparent), transparent 40%);
      opacity: 0.25;
    }
    .card h2 {
      margin: 0 0 12px;
      font-size: 24px;
      font-family: var(--font-display);
      letter-spacing: -0.01em;
      line-height: 1.1;
      position: relative;
      z-index: 1;
    }
    .row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 10px;
      position: relative;
      z-index: 1;
    }
    input, textarea, button, select {
      font: inherit;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 9px 11px;
      background: color-mix(in srgb, var(--card) 92%, var(--surface-tint));
      color: var(--text);
    }
    input, select { flex: 1 1 180px; }
    textarea { width: 100%; min-height: 96px; line-height: 1.45; }
    input:focus,
    textarea:focus,
    select:focus,
    button:focus-visible {
      outline: none;
      box-shadow: var(--focus-ring);
      border-color: color-mix(in srgb, var(--accent) 55%, var(--border));
    }
    input::placeholder,
    textarea::placeholder {
      color: color-mix(in srgb, var(--muted) 88%, transparent);
    }
    button {
      background: linear-gradient(150deg, var(--accent), color-mix(in srgb, var(--accent-2) 76%, var(--accent)));
      color: #fff;
      border: none;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.01em;
      box-shadow: 0 10px 20px rgba(15, 23, 42, 0.2);
      transition: transform 120ms ease, filter 140ms ease, box-shadow 140ms ease;
    }
    button.secondary {
      background: linear-gradient(145deg, var(--button-secondary-bg), color-mix(in srgb, var(--button-secondary-bg) 76%, #000000));
      color: var(--button-secondary-text);
    }
    button:hover {
      filter: brightness(1.05);
      transform: translateY(-1px);
      box-shadow: 0 14px 24px rgba(15, 23, 42, 0.24);
    }
    button:active {
      transform: translateY(0);
      box-shadow: 0 6px 16px rgba(15, 23, 42, 0.2);
    }
    pre {
      background: var(--pre-bg);
      color: var(--pre-fg);
      border-radius: 12px;
      padding: 12px;
      overflow: auto;
      max-height: none;
      margin: 10px 0 0;
      font-size: 12px;
      line-height: 1.5;
      font-family: var(--font-mono);
      border: 1px solid color-mix(in srgb, var(--pre-fg) 15%, transparent);
    }
    pre[id^="out-"] {
      min-height: 22rem;
      height: 22rem;
      resize: vertical;
    }
    .db-grid-controls input,
    .db-grid-controls select {
      flex: 1 1 220px;
    }
    .db-grid-controls input:disabled,
    .db-grid-controls button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    #db-grid-view {
      display: none;
      margin-top: 8px;
    }
    #db-grid-view.open {
      display: block;
    }
    .db-grid-scroll {
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: auto;
      max-height: 70vh;
      background: color-mix(in srgb, var(--card) 96%, var(--surface-tint));
      box-shadow: inset 0 1px 0 color-mix(in srgb, var(--surface-tint) 75%, transparent);
    }
    .db-grid-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
      line-height: 1.35;
    }
    .db-grid-table th,
    .db-grid-table td {
      border-bottom: 1px solid var(--border);
      padding: 6px 8px;
      text-align: left;
      vertical-align: top;
    }
    .db-grid-table thead th {
      position: sticky;
      top: 0;
      z-index: 2;
      background: color-mix(in srgb, var(--card) 96%, var(--surface-tint));
    }
    .db-grid-table .db-filter-row th {
      top: 35px;
      z-index: 1;
    }
    .db-grid-table tbody tr:nth-child(even) {
      background: color-mix(in srgb, var(--accent-2) 10%, transparent);
    }
    .db-sort-btn {
      appearance: none;
      border: none;
      background: transparent;
      color: var(--text);
      cursor: pointer;
      font: inherit;
      font-weight: 700;
      padding: 0;
      line-height: 1.2;
    }
    .db-sort-btn:hover {
      text-decoration: underline;
    }
    .db-filter-input {
      width: 100%;
      min-width: 120px;
      padding: 4px 6px;
      font-size: 12px;
    }
    .inspector-list {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: color-mix(in srgb, var(--card) 96%, var(--surface-tint));
      padding: 10px;
      max-height: 24rem;
      overflow: auto;
      margin-top: 10px;
    }
    .inspector-card {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px;
      margin-bottom: 10px;
      background: color-mix(in srgb, var(--accent-2) 8%, transparent);
    }
    .inspector-card:last-child {
      margin-bottom: 0;
    }
    .inspector-card h4 {
      margin: 0 0 4px;
      font-size: 13px;
    }
    .inspector-meta {
      font-size: 12px;
      color: var(--muted);
      margin: 0 0 6px;
      word-break: break-word;
    }
    .inspector-copy-row {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .inspector-copy-row button {
      padding: 5px 8px;
      font-size: 12px;
    }
    .inspector-copy-status {
      margin-top: 6px;
      font-size: 12px;
      color: var(--muted);
    }
    .db-cell {
      max-width: 560px;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .dropzone {
      border: 2px dashed color-mix(in srgb, var(--accent) 66%, var(--border));
      border-radius: 12px;
      padding: 18px;
      text-align: center;
      color: var(--muted);
      background: var(--drop-bg);
      margin-bottom: 12px;
      box-shadow: inset 0 0 0 1px color-mix(in srgb, var(--accent) 14%, transparent);
      transition: background 150ms ease, border-color 150ms ease, transform 150ms ease;
    }
    .dropzone.drag {
      background: var(--drop-drag-bg);
      border-color: var(--accent);
      transform: translateY(-1px);
    }
    .import-live {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: color-mix(in srgb, var(--card) 95%, var(--surface-tint));
      padding: 12px;
      margin-bottom: 12px;
      display: grid;
      grid-template-columns: 180px minmax(0, 1fr);
      gap: 12px;
      position: relative;
      z-index: 1;
    }
    .import-live.empty {
      grid-template-columns: 1fr;
    }
    .import-preview {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: color-mix(in srgb, var(--accent-2) 10%, transparent);
      min-height: 232px;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--muted);
      font-size: 12px;
      text-align: center;
      padding: 10px;
    }
    .import-preview embed,
    .import-preview iframe {
      width: 100%;
      height: 232px;
      border: 0;
      background: #fff;
    }
    .import-preview img {
      max-width: 100%;
      max-height: 232px;
      object-fit: contain;
      display: block;
    }
    .import-title {
      margin: 0 0 4px;
      font-family: var(--font-display);
      font-size: 16px;
      line-height: 1.2;
      word-break: break-word;
    }
    .import-meta {
      margin: 0 0 10px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.4;
      word-break: break-word;
    }
    .import-progress-track {
      width: 100%;
      height: 10px;
      border-radius: 999px;
      background: color-mix(in srgb, var(--accent-2) 16%, transparent);
      border: 1px solid color-mix(in srgb, var(--accent-2) 24%, transparent);
      overflow: hidden;
      margin-bottom: 8px;
    }
    .import-progress-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--accent), color-mix(in srgb, var(--accent-2) 72%, var(--accent)));
      border-radius: inherit;
      transition: width 180ms ease;
      position: relative;
    }
    .import-progress-bar.active::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(120deg, transparent 0%, rgba(255, 255, 255, 0.35) 45%, transparent 70%);
      animation: importShimmer 900ms linear infinite;
    }
    .import-status-line {
      margin: 0 0 8px;
      font-size: 12px;
      color: var(--muted);
      min-height: 18px;
    }
    .import-counters {
      margin: 0 0 10px;
      font-size: 12px;
      color: var(--muted);
      min-height: 18px;
    }
    .import-steps {
      display: grid;
      gap: 6px;
      margin-bottom: 10px;
    }
    .import-step {
      border: 1px solid var(--border);
      border-radius: 9px;
      padding: 7px 9px;
      background: color-mix(in srgb, var(--card) 92%, var(--surface-tint));
      font-size: 12px;
      line-height: 1.3;
      word-break: break-word;
    }
    .import-step-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 5px;
    }
    .import-step-head strong {
      font-size: 12px;
    }
    .step-progress-track {
      width: 100%;
      height: 7px;
      border-radius: 999px;
      background: color-mix(in srgb, var(--accent-2) 16%, transparent);
      border: 1px solid color-mix(in srgb, var(--accent-2) 24%, transparent);
      overflow: hidden;
      margin-bottom: 4px;
    }
    .step-progress-bar {
      height: 100%;
      width: 0%;
      border-radius: inherit;
      transition: width 160ms ease;
      background: linear-gradient(90deg, var(--accent), color-mix(in srgb, var(--accent-2) 72%, var(--accent)));
      position: relative;
    }
    .step-progress-bar.active::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(120deg, transparent 0%, rgba(255, 255, 255, 0.34) 45%, transparent 70%);
      animation: importShimmer 900ms linear infinite;
    }
    .import-step-detail {
      margin: 0;
      color: var(--muted);
      font-size: 11px;
      line-height: 1.35;
      min-height: 14px;
    }
    .import-step .step-badge {
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 10px;
      font-weight: 700;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      border: 1px solid transparent;
    }
    .import-step.pending .step-badge {
      background: rgba(100, 116, 139, 0.14);
      border-color: rgba(100, 116, 139, 0.22);
      color: var(--muted);
    }
    .import-step.pending .step-progress-bar {
      background: rgba(100, 116, 139, 0.32);
    }
    .import-step.active .step-badge {
      background: rgba(14, 116, 144, 0.18);
      border-color: rgba(14, 116, 144, 0.36);
      color: #0f6a7d;
    }
    .import-step.done .step-badge {
      background: rgba(20, 150, 90, 0.18);
      border-color: rgba(20, 150, 90, 0.36);
      color: #0f7a4f;
    }
    .import-step.skipped .step-badge {
      background: rgba(100, 116, 139, 0.18);
      border-color: rgba(100, 116, 139, 0.32);
      color: var(--text);
    }
    .import-step.skipped .step-progress-bar {
      background: rgba(100, 116, 139, 0.5);
    }
    .import-step.error .step-badge {
      background: rgba(180, 35, 24, 0.16);
      border-color: rgba(180, 35, 24, 0.36);
      color: #9f1e14;
    }
    .import-step.error .step-progress-bar {
      background: linear-gradient(90deg, #b42318, #9f1e14);
    }
    .import-metrics {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
      gap: 8px;
      margin-bottom: 10px;
    }
    .import-metric {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 7px 8px;
      background: color-mix(in srgb, var(--card) 90%, var(--surface-tint));
    }
    .import-metric p {
      margin: 0;
      line-height: 1.25;
    }
    .import-metric .k {
      font-size: 10px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--muted);
      font-family: var(--font-display);
    }
    .import-metric .v {
      font-size: 14px;
      font-weight: 700;
      margin-top: 2px;
    }
    .import-history-title {
      margin: 12px 0 7px;
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.12em;
      font-family: var(--font-display);
      font-weight: 700;
    }
    .import-history {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: color-mix(in srgb, var(--card) 96%, var(--surface-tint));
      padding: 10px;
      max-height: 17rem;
      overflow: auto;
      display: grid;
      gap: 8px;
      position: relative;
      z-index: 1;
    }
    .import-history-item {
      border: 1px solid var(--border);
      border-radius: 9px;
      padding: 8px 9px;
      background: color-mix(in srgb, var(--accent-2) 8%, transparent);
      font-size: 12px;
      line-height: 1.35;
      word-break: break-word;
    }
    .import-history-item h4 {
      margin: 0 0 3px;
      font-size: 12px;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    @keyframes importShimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(200%); }
    }
    .small {
      color: var(--muted);
      font-size: 12px;
      line-height: 1.45;
      position: relative;
      z-index: 1;
    }
    .err { color: var(--error); font-size: 12px; }
    .metric-grid,
    .dashboard-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
      gap: 12px;
      margin: 12px 0;
    }
    .metric-card {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 11px 12px;
      background: linear-gradient(160deg, color-mix(in srgb, var(--card) 92%, var(--surface-tint)), color-mix(in srgb, var(--accent) 8%, transparent));
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.08);
      position: relative;
      overflow: hidden;
    }
    .metric-card::before {
      content: "";
      position: absolute;
      inset: 0 auto 0 0;
      width: 4px;
      background: linear-gradient(180deg, var(--accent), var(--accent-2));
      opacity: 0.64;
    }
    .metric-label {
      margin: 0 0 6px;
      color: var(--muted);
      font-size: 11px;
      line-height: 1.2;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      font-family: var(--font-display);
      font-weight: 600;
    }
    .metric-value {
      margin: 0;
      font-size: 20px;
      font-weight: 700;
      line-height: 1.2;
      word-break: break-word;
    }
    .status-pill {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 11px;
      font-weight: 700;
      border: 1px solid transparent;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }
    .status-ok {
      background: rgba(20, 150, 90, 0.18);
      color: #0f7a4f;
      border-color: rgba(20, 150, 90, 0.36);
    }
    .status-warn {
      background: rgba(217, 119, 6, 0.18);
      color: #9a5a00;
      border-color: rgba(217, 119, 6, 0.36);
    }
    .status-error {
      background: rgba(180, 35, 24, 0.16);
      color: #9f1e14;
      border-color: rgba(180, 35, 24, 0.36);
    }
    .status-neutral {
      background: rgba(100, 116, 139, 0.18);
      color: var(--text);
      border-color: rgba(100, 116, 139, 0.32);
    }
    .issue-list {
      margin-top: 10px;
      display: grid;
      gap: 10px;
    }
    .issue-item {
      border: 1px solid var(--border);
      border-left: 4px solid transparent;
      border-radius: 10px;
      padding: 10px 11px;
      background: color-mix(in srgb, var(--card) 88%, var(--surface-tint));
      font-size: 13px;
      line-height: 1.35;
      word-break: break-word;
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.08);
    }
    .issue-item strong {
      margin-right: 6px;
      text-transform: uppercase;
      font-size: 11px;
      letter-spacing: 0.02em;
    }
    .issue-item.issue-error {
      border-left-color: #b42318;
    }
    .issue-item.issue-warning {
      border-left-color: #d97706;
    }
    .issue-item.issue-info {
      border-left-color: #475569;
    }
    .info-icon {
      display: inline-flex;
      width: 16px;
      height: 16px;
      border-radius: 999px;
      border: 1px solid var(--border);
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: 700;
      background: var(--help-icon-bg);
      color: var(--help-icon-fg);
      cursor: help;
      user-select: none;
      line-height: 1;
      transition: transform 130ms ease, filter 130ms ease;
    }
    .info-icon:hover {
      transform: translateY(-1px);
      filter: brightness(1.07);
    }
    details.raw-json {
      margin-top: 10px;
      border: 1px solid var(--border);
      border-radius: 11px;
      background: color-mix(in srgb, var(--card) 95%, var(--surface-tint));
      overflow: hidden;
    }
    details.raw-json > summary {
      cursor: pointer;
      color: var(--muted);
      font-size: 11px;
      font-weight: 600;
      list-style: none;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-family: var(--font-display);
      padding: 10px 12px;
      background: color-mix(in srgb, var(--accent-2) 10%, transparent);
    }
    details.raw-json > summary::-webkit-details-marker {
      display: none;
    }
    .dashboard-section-title {
      margin: 13px 0 7px;
      font-size: 11px;
      color: var(--muted);
      font-weight: 700;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      font-family: var(--font-display);
    }
    .vector-card-list {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: color-mix(in srgb, var(--card) 96%, var(--surface-tint));
      padding: 10px;
      max-height: 22rem;
      overflow: auto;
      margin-top: 10px;
      display: grid;
      gap: 10px;
      box-shadow: inset 0 1px 0 color-mix(in srgb, var(--surface-tint) 75%, transparent);
    }
    .vector-card {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px;
      background: color-mix(in srgb, var(--accent-2) 9%, transparent);
      word-break: break-word;
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.08);
    }
    .vector-card h4 {
      margin: 0 0 5px;
      font-size: 13px;
    }
    .vector-card p {
      margin: 0;
      font-size: 12px;
      color: color-mix(in srgb, var(--muted) 90%, var(--text));
      white-space: pre-wrap;
      line-height: 1.45;
    }
    .help-icon {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 30px;
      height: 30px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: var(--help-icon-bg);
      color: var(--help-icon-fg);
      font-weight: 700;
      line-height: 1;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      min-width: 30px;
      box-shadow: 0 7px 16px rgba(0, 0, 0, 0.16);
      transition: transform 140ms ease, filter 140ms ease;
      z-index: 2;
    }
    .help-icon:hover {
      filter: brightness(1.08);
      transform: translateY(-1px);
    }
    .help-modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: var(--help-overlay);
      z-index: 999;
      padding: 18px;
    }
    .help-modal.open {
      display: flex;
      animation: fadeIn 170ms ease;
    }
    .help-panel {
      width: min(920px, 100%);
      max-height: 86vh;
      overflow: auto;
      background: linear-gradient(170deg, color-mix(in srgb, var(--help-panel-bg) 92%, var(--surface-tint)), var(--help-panel-bg));
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 16px;
      box-shadow: 0 24px 60px rgba(12, 25, 41, 0.35);
      animation: panelFloatIn 190ms ease;
    }
    .help-panel::-webkit-scrollbar,
    .nav-column::-webkit-scrollbar,
    .vector-card-list::-webkit-scrollbar,
    .inspector-list::-webkit-scrollbar,
    .db-grid-scroll::-webkit-scrollbar,
    pre::-webkit-scrollbar {
      width: 10px;
      height: 10px;
    }
    .help-panel::-webkit-scrollbar-thumb,
    .nav-column::-webkit-scrollbar-thumb,
    .vector-card-list::-webkit-scrollbar-thumb,
    .inspector-list::-webkit-scrollbar-thumb,
    .db-grid-scroll::-webkit-scrollbar-thumb,
    pre::-webkit-scrollbar-thumb {
      background: color-mix(in srgb, var(--accent) 32%, var(--border));
      border-radius: 999px;
      border: 2px solid transparent;
      background-clip: padding-box;
    }
    .help-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      gap: 10px;
    }
    .help-head h3 { margin: 0; font-size: 18px; }
    .help-content h4 { margin: 12px 0 6px; }
    .help-content p { margin: 0 0 8px; }
    .help-content ul { margin: 0 0 12px 18px; padding: 0; }
    .help-content li { margin-bottom: 4px; }
    .help-content code {
      font-family: var(--font-mono);
      background: var(--help-code-bg);
      color: var(--help-code-fg);
      border-radius: 4px;
      padding: 1px 4px;
    }
    .help-content pre {
      margin: 8px 0 12px;
      max-height: none;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .help-content pre code {
      background: transparent;
      color: inherit;
      padding: 0;
      border-radius: 0;
    }
    @keyframes panelFade {
      from {
        opacity: 0;
        transform: translateY(7px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    @keyframes navSlideIn {
      from {
        opacity: 0;
        transform: translateX(-8px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }
    @keyframes panelFloatIn {
      from {
        opacity: 0;
        transform: translateY(10px) scale(0.99);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    @media (max-width: 980px) {
      .app-shell {
        grid-template-columns: 1fr;
        padding: 14px 12px 22px;
      }
      .nav-column {
        position: static;
        max-height: none;
      }
      .nav-list {
        display: flex;
        flex-wrap: nowrap;
        overflow-x: auto;
      }
      .nav-btn {
        flex: 0 0 auto;
        width: auto;
        min-width: 178px;
      }
      .workspace-head p {
        font-size: 20px;
      }
      .card h2 {
        font-size: 21px;
      }
    }
    @media (prefers-reduced-motion: reduce) {
      .workspace-panel.active,
      .help-panel,
      .help-modal.open,
      .nav-btn {
        animation: none;
      }
      button,
      .help-icon,
      .nav-btn,
      .dropzone,
      .info-icon {
        transition: none;
      }
    }
    @media (max-width: 640px) {
      .workspace-head {
        padding: 13px;
      }
      .workspace-head p {
        font-size: 18px;
      }
      .card {
        padding: 13px;
      }
      .metric-grid,
      .dashboard-grid {
        grid-template-columns: 1fr;
      }
      .vector-card-list,
      .inspector-list {
        max-height: 18rem;
      }
      .import-live {
        grid-template-columns: 1fr;
      }
      .import-preview {
        min-height: 190px;
      }
      .import-preview embed,
      .import-preview iframe,
      .import-preview img {
        height: 190px;
        max-height: 190px;
      }
    }
  </style>
</head>
<body data-theme="harmonious-light">
  <header>
    <div class="header-top">
      <div class="brand-block">
        <h1>Stemma Codicum</h1>
        <p class="hero-subtitle">Source Tracing & Validation.</p>
      </div>
      <div class="theme-picker">
        <label for="theme-select">Theme</label>
        <select id="theme-select" onchange="setTheme(this.value)">
          <option value="harmonious-light">Harmonious Light</option>
          <option value="restful-dark">Restful Dark</option>
          <option value="forest-mist">Forest Mist</option>
          <option value="sunset-paper">Sunset Paper</option>
          <option value="midnight-contrast">Midnight Contrast</option>
        </select>
      </div>
    </div>
  </header>
  <main class="app-shell">
    <aside class="nav-column">
      <h2 class="nav-title">Functions</h2>
      <p class="small nav-copy">Select a function to open its full panel.</p>
      <div class="nav-list">
        <button class="secondary nav-btn" type="button" data-pane="dashboard">Home Dashboard</button>
        <button class="secondary nav-btn" type="button" data-pane="project">Project and Health</button>
        <button class="secondary nav-btn" type="button" data-pane="database">Database Explorer</button>
        <button class="secondary nav-btn" type="button" data-pane="ingest">Import</button>
        <button class="secondary nav-btn" type="button" data-pane="references">References</button>
        <button class="secondary nav-btn" type="button" data-pane="extraction">Extraction</button>
        <button class="secondary nav-btn" type="button" data-pane="vector">Vector</button>
        <button class="secondary nav-btn" type="button" data-pane="claims">Claims</button>
        <button class="secondary nav-btn" type="button" data-pane="binding">Binding</button>
        <button class="secondary nav-btn" type="button" data-pane="verification">Verification and Reports</button>
        <button class="secondary nav-btn" type="button" data-pane="trace">Trace</button>
        <button class="secondary nav-btn" type="button" data-pane="ceapf">CEAPF</button>
      </div>
    </aside>

    <section class="workspace">
      <div class="workspace-head">
        <h2 id="workspace-title">Function Workspace</h2>
        <p id="workspace-subtitle">Home Dashboard</p>
      </div>

      <section class="card workspace-panel" data-pane="dashboard" data-help-key="dashboard">
      <h2>Home Dashboard</h2>
      <div class="row">
        <button onclick="loadDashboard()">Refresh Summary</button>
        <button class="secondary" onclick="loadDashboard(true)">Refresh + Doctor</button>
      </div>
      <p id="dashboard-status" class="small">Load summary to view overall system status.</p>
      <h3 class="dashboard-section-title">System Snapshot</h3>
      <div id="dashboard-kpis" class="dashboard-grid"></div>
      <h3 class="dashboard-section-title">Recent Runs</h3>
      <div id="dashboard-runs" class="issue-list">
        <p class="small">No dashboard summary loaded yet.</p>
      </div>
      <details class="raw-json">
        <summary>Raw JSON</summary>
        <pre id="out-dashboard"></pre>
      </details>
      </section>

      <section class="card workspace-panel" data-pane="project" data-help-key="project">
      <h2>Project and Health</h2>
      <div class="row">
        <button onclick="runInitProject()">Init Project</button>
        <button class="secondary" onclick="runDoctor()">Doctor</button>
      </div>
      <p id="project-health-status" class="small">Run Doctor to load health diagnostics.</p>
      <div id="project-health-visual" class="metric-grid"></div>
      <div id="project-health-issues" class="issue-list">
        <p class="small">No health issues loaded.</p>
      </div>
      <details class="raw-json">
        <summary>Raw JSON</summary>
        <pre id="out-project"></pre>
      </details>
      </section>

      <section class="card workspace-panel" data-pane="database" data-help-key="database">
      <h2>Database Explorer</h2>
      <div class="row">
        <button class="secondary" onclick="dbListTables()">List Tables</button>
        <select id="db-table-select">
          <option value="">Select table</option>
        </select>
      </div>
      <div class="row">
        <input id="db-limit" value="50" placeholder="Row limit" />
        <input id="db-offset" value="0" placeholder="Offset" />
        <button onclick="dbViewTable()">View Rows</button>
        <button class="secondary" onclick="dbDescribeTable()">Table Schema</button>
      </div>
      <div id="db-grid-controls" class="row db-grid-controls">
        <select id="db-view-mode" onchange="dbSetViewMode(this.value)">
          <option value="spreadsheet">Spreadsheet View</option>
          <option value="json">JSON View</option>
        </select>
        <input id="db-search" placeholder="Search current view (all columns)" />
        <button id="db-clear-filters" class="secondary" onclick="dbClearFilters()">Clear Filters</button>
      </div>
      <p class="small">Inspect table names, row counts, schema, and sample rows.</p>
      <div id="db-grid-view">
        <p class="small" id="db-grid-meta">Load a table to inspect data in spreadsheet mode.</p>
        <div class="db-grid-scroll">
          <table id="db-grid-table" class="db-grid-table"></table>
        </div>
      </div>
      <pre id="out-db"></pre>
      </section>

      <section class="card workspace-panel" data-pane="ingest" data-help-key="ingest">
      <h2>Import</h2>
      <div id="dropzone" class="dropzone">Drag & drop a document here to import (dedupe-aware)</div>
      <div class="row">
        <input id="ingest-path" placeholder="Absolute file path" />
        <button onclick="ingestPath()">Import File Path</button>
      </div>
      <div class="row">
        <input id="resources-limit" value="20" />
        <button class="secondary" onclick="listResources()">List Resources</button>
      </div>
      <div id="import-live" class="import-live empty">
        <p class="small">Drop a document to begin. This panel will show thumbnail preview, staged progress, extraction/table/vector status, and confirmation metadata.</p>
      </div>
      <h3 class="import-history-title">Recent Imports</h3>
      <div id="import-history" class="import-history">
        <p class="small">No imports yet.</p>
      </div>
      <h3 class="dashboard-section-title">Mass Import (Recursive)</h3>
      <div class="row">
        <input id="pipe-root" value="/Volumes/X10/data/Institution" placeholder="Root directory" />
        <input id="pipe-max" placeholder="Max files (optional)" value="25" />
        <input id="pipe-timeout" placeholder="Extract timeout sec" value="300" />
        <select id="pipe-skip">
          <option value="false">extract enabled</option>
          <option value="true">skip extraction</option>
        </select>
        <button class="secondary" onclick="runMassImport()">Run Mass Import</button>
      </div>
      <p class="small">Mass import recursively scans the root path and processes all supported document types.</p>
      <details class="raw-json">
        <summary>Raw JSON</summary>
        <pre id="out-ingest"></pre>
      </details>
      </section>

      <section class="card workspace-panel" data-pane="references" data-help-key="references">
      <h2>References</h2>
      <div class="row">
        <input id="bib-path" placeholder="/path/to/references.bib" />
        <button onclick="importBib()">Import BibTeX</button>
      </div>
      <div class="row">
        <input id="link-cite-id" placeholder="Cite ID" />
        <input id="link-digest" placeholder="Resource digest" />
        <button onclick="linkReference()">Link Ref->Resource</button>
      </div>
      <div class="row">
        <button class="secondary" onclick="callApi('GET','/api/refs',null,'out-refs')">List Refs</button>
        <button class="secondary" onclick="callApi('GET','/api/citations',null,'out-refs')">List Citations</button>
      </div>
      <pre id="out-refs"></pre>
      </section>

      <section class="card workspace-panel" data-pane="extraction" data-help-key="extraction">
      <h2>Extraction</h2>
      <div class="row">
        <input id="extract-resource-id" placeholder="Resource ID (optional)" />
        <input id="extract-digest" placeholder="Resource digest (optional)" />
        <button onclick="extractRun()">Run Extract</button>
      </div>
      <div class="row">
        <input id="extract-tables-id" placeholder="Resource ID (optional)" />
        <input id="extract-tables-digest" placeholder="Resource digest (optional)" />
        <button class="secondary" onclick="extractTables()">List Tables</button>
      </div>
      <p class="small">Extraction Inspector: inspect canonical text, standoff segments, annotations, and full extraction dumps.</p>
      <div class="row">
        <input id="inspect-resource-id" placeholder="Inspector resource ID (optional)" />
        <input id="inspect-resource-digest" placeholder="Inspector resource digest (optional)" />
        <input id="inspect-run-id" placeholder="Inspector run ID (optional, latest if empty)" />
      </div>
      <div class="row">
        <input id="inspect-segment-type" placeholder="Segment type filter (e.g. layout:paragraph)" />
        <input id="inspect-layer" placeholder="Layer filter (e.g. domain_financial)" />
        <input id="inspect-category" placeholder="Category filter (e.g. metric)" />
        <input id="inspect-limit" value="200" placeholder="Limit" />
      </div>
      <div class="row">
        <input id="inspect-segment-limit" value="2000" placeholder="Dump segment limit" />
        <input id="inspect-annotation-limit" value="2000" placeholder="Dump annotation limit" />
        <input id="inspect-table-limit" value="500" placeholder="Dump table limit" />
      </div>
      <div class="row">
        <button class="secondary" onclick="extractInspectorText()">Inspect Text</button>
        <button class="secondary" onclick="extractInspectorSegments()">Inspect Segments</button>
        <button class="secondary" onclick="extractInspectorAnnotations()">Inspect Annotations</button>
        <button class="secondary" onclick="extractInspectorDump()">Inspect Dump</button>
      </div>
      <div id="extract-inspector-list" class="inspector-list">
        <p class="small">No inspector items loaded yet.</p>
      </div>
      <p id="extract-inspector-copy-status" class="inspector-copy-status"></p>
      <pre id="out-extract"></pre>
      <pre id="out-extract-inspector"></pre>
      </section>

      <section class="card workspace-panel" data-pane="vector" data-help-key="vector">
      <h2>Vector Index and Search</h2>
      <div class="row">
        <input id="vector-resource-id" placeholder="Resource ID (optional)" />
        <input id="vector-resource-digest" placeholder="Resource digest (optional)" />
        <input id="vector-extraction-run-id" placeholder="Extraction run ID (optional)" />
      </div>
      <div class="row">
        <input id="vector-status-limit" value="25" placeholder="Status run limit" />
        <select id="vector-force">
          <option value="false">skip if already indexed</option>
          <option value="true">force re-index</option>
        </select>
        <button onclick="vectorIndex()">Index</button>
        <button class="secondary" onclick="vectorStatus()">Status</button>
      </div>
      <div class="row">
        <input id="vector-backfill-limit-resources" value="100000" placeholder="Backfill limit resources" />
        <input id="vector-backfill-max-process" placeholder="Backfill max process (optional)" />
        <button class="secondary" onclick="vectorBackfill()">Backfill</button>
      </div>
      <div class="row">
        <input id="vector-query" placeholder="Semantic query" />
        <input id="vector-query-limit" value="10" placeholder="Search limit" />
        <button class="secondary" onclick="vectorSearch()">Search</button>
      </div>
      <p id="vector-status-note" class="small">Load status to inspect vector backend health and run history.</p>
      <div id="vector-summary" class="metric-grid"></div>
      <div id="vector-runs" class="vector-card-list">
        <p class="small">No vector runs loaded yet.</p>
      </div>
      <div id="vector-search-results" class="vector-card-list">
        <p class="small">No vector search results yet.</p>
      </div>
      <details class="raw-json">
        <summary>Raw JSON</summary>
        <pre id="out-vector"></pre>
      </details>
      </section>

      <section class="card workspace-panel" data-pane="claims" data-help-key="claims">
      <h2>Claims</h2>
      <div class="row">
        <input id="claims-file" placeholder="Claims file path" />
        <select id="claims-format">
          <option value="csv">csv</option>
          <option value="json">json</option>
          <option value="md">md</option>
        </select>
        <input id="claim-set" placeholder="Claim set name" />
        <button onclick="importClaims()">Import Claims</button>
      </div>
      <div class="row">
        <input id="claims-list-set" placeholder="Claim set filter (optional)" />
        <button class="secondary" onclick="listClaims()">List Claims</button>
        <button class="secondary" onclick="callApi('GET','/api/claim-sets',null,'out-claims')">List Claim Sets</button>
      </div>
      <pre id="out-claims"></pre>
      </section>

      <section class="card workspace-panel" data-pane="binding" data-help-key="binding">
      <h2>Binding</h2>
      <div class="row">
        <input id="bind-claim-id" placeholder="Claim ID" />
        <input id="bind-resource-id" placeholder="Resource ID (optional)" />
        <input id="bind-digest" placeholder="Resource digest (optional)" />
      </div>
      <div class="row">
        <input id="bind-role" placeholder="Role (value-cell/quote/etc.)" />
      </div>
      <textarea id="bind-selectors">[{"type":"PageGeometrySelector","pageIndex":0,"boxes":[]},{"type":"TextQuoteSelector","exact":"example"}]</textarea>
      <div class="row">
        <button onclick="bindAdd()">Add Binding</button>
        <button class="secondary" onclick="bindValidate()">Validate Binding</button>
      </div>
      <pre id="out-bind"></pre>
      </section>

      <section class="card workspace-panel" data-pane="verification" data-help-key="verification">
      <h2>Verification and Reports</h2>
      <div class="row">
        <input id="verify-claim-id" placeholder="Claim ID" />
        <button onclick="verifyClaim()">Verify Claim</button>
      </div>
      <div class="row">
        <input id="verify-claim-set" placeholder="Claim set" />
        <button onclick="verifySet()">Verify Set</button>
      </div>
      <div class="row">
        <input id="report-run-id" placeholder="Verification run ID" />
        <input id="report-json-out" placeholder="json output path (optional)" />
        <input id="report-md-out" placeholder="md output path (optional)" />
        <button class="secondary" onclick="reportVerification()">Get Report</button>
      </div>
      <pre id="out-verify"></pre>
      </section>

      <section class="card workspace-panel" data-pane="trace" data-help-key="trace">
      <h2>Trace</h2>
      <div class="row">
        <input id="trace-claim-id" placeholder="Claim ID" />
        <button onclick="traceClaim()">Trace Claim</button>
      </div>
      <div class="row">
        <input id="trace-resource-id" placeholder="Resource ID (optional)" />
        <input id="trace-resource-digest" placeholder="Resource digest (optional)" />
        <button onclick="traceResource()">Trace Resource</button>
      </div>
      <div class="row">
        <input id="trace-cite-id" placeholder="Cite ID" />
        <button onclick="traceCitation()">Trace Citation</button>
      </div>
      <pre id="out-trace"></pre>
      </section>

      <section class="card workspace-panel" data-pane="ceapf" data-help-key="ceapf">
      <h2>CEAPF</h2>
      <textarea id="ceapf-prop">{"subject":"org:InstitutionZ","predicate":"ceapf:spent","object":{"amount":3.4,"unit":"GBP"}}</textarea>
      <div class="row">
        <button onclick="addProposition()">Add Proposition</button>
        <button class="secondary" onclick="listPropositions()">List Propositions</button>
      </div>
      <div class="row">
        <input id="ceapf-prop-id" placeholder="Proposition ID" />
        <input id="ceapf-agent" placeholder="Agent" value="person:AuthorX" />
        <input id="ceapf-modality" placeholder="Modality" value="asserts" />
        <button onclick="addAssertion()">Add Assertion</button>
      </div>
      <div class="row">
        <input id="ceapf-rel-type" placeholder="Relation type" value="supports" />
        <input id="ceapf-from-type" placeholder="From type" value="assertion_event" />
        <input id="ceapf-from-id" placeholder="From ID" />
        <input id="ceapf-to-type" placeholder="To type" value="proposition" />
        <input id="ceapf-to-id" placeholder="To ID" />
        <button onclick="addRelation()">Add Relation</button>
      </div>
      <pre id="out-ceapf"></pre>
      </section>

    </section>
  </main>

<div id="help-modal" class="help-modal" aria-hidden="true">
  <div class="help-panel">
    <div class="help-head">
      <h3 id="help-title">Help</h3>
      <button class="secondary" onclick="closeHelp()">Close</button>
    </div>
    <div id="help-content" class="help-content"></div>
  </div>
</div>

<script>
const HELP_CONTENT = {
  dashboard: {
    title: "Home Dashboard",
    basic: `
      <p>Use this panel for a single-page summary of core system health and workload state.</p>
      <ul>
        <li><code>Refresh Summary</code>: lightweight snapshot (counts + recent runs + vector state).</li>
        <li><code>Refresh + Doctor</code>: includes full integrity checks.</li>
      </ul>
    `,
    full: `
      <p>The dashboard is intended for triage and routine checks before deeper workflows.</p>
      <h4>Recommended cadence</h4>
      <ul>
        <li>Use lightweight summary during active work.</li>
        <li>Use doctor refresh before major ingest/extract batches.</li>
      </ul>
      <pre><code>GET /api/dashboard/summary
GET /api/dashboard/summary?include_doctor=true</code></pre>
    `,
  },
  project: {
    title: "Project and Health",
    basic: `
      <p>Use this card to initialize project files and run diagnostic checks.</p>
      <h4>Core actions</h4>
      <ul>
        <li><code>Init Project</code>: creates/repairs <code>.stemma/</code> and database schema.</li>
        <li><code>Doctor</code>: runs integrity checks and DB runtime checks.</li>
      </ul>
      <h4>Example flow</h4>
      <pre><code>1) Click Init Project
2) Click Doctor
3) Confirm "ok": true and db_runtime.journal_mode = "wal"</code></pre>
    `,
    full: `
      <p>This card corresponds to <code>stemma init</code> and <code>stemma doctor</code>. Run these before batch work or after crashes.</p>
      <h4>When to use</h4>
      <ul>
        <li>Fresh project setup.</li>
        <li>Before/after long import runs.</li>
        <li>To verify DB concurrency settings and archive integrity.</li>
      </ul>
      <h4>Example</h4>
      <pre><code>POST /api/init
GET /api/doctor

Expected doctor signals:
- checks_run >= 4
- db_runtime.journal_mode = "wal"
- db_runtime.busy_timeout_ms > 0</code></pre>
    `,
  },
  database: {
    title: "Database Explorer",
    basic: `
      <p>Inspect real database state: table list, row counts, schema, and sample rows.</p>
      <h4>Quick start</h4>
      <ul>
        <li>Click <code>List Tables</code> to load all tables and counts.</li>
        <li>Select a table and click <code>View Rows</code>.</li>
        <li>Use <code>Spreadsheet View</code> for sortable/filterable grid output.</li>
        <li>Use <code>Table Schema</code> to view create SQL and columns.</li>
      </ul>
      <h4>Example</h4>
      <pre><code>Table: resources
Limit: 50
Offset: 0
Action: View Rows</code></pre>
    `,
    full: `
      <p>This card is for learning and diagnostics. It uses read-only style inspection endpoints.</p>
      <h4>Recommended checks</h4>
      <ul>
        <li>After ingest: verify rows in <code>resources</code> and <code>resource_digests</code>.</li>
        <li>After extraction: verify <code>extraction_runs</code> and <code>extracted_tables</code>.</li>
        <li>After binding/verification: inspect <code>evidence_*</code> and <code>verification_*</code> tables.</li>
        <li>Use global search + per-column filters to narrow large result sets quickly.</li>
      </ul>
      <h4>Example sequence</h4>
      <pre><code>1) List Tables
2) Table Schema on extraction_runs
3) View Rows on extraction_runs (limit 20)
4) View Rows on extracted_tables (limit 20)</code></pre>
    `,
  },
  ingest: {
    title: "Import",
    basic: `
      <p>Add source files into immutable archive storage with deduplication.</p>
      <ul>
        <li>Use drag/drop for quick single-file import.</li>
        <li>Use absolute path import for scripted workflows.</li>
        <li>Use mass import for recursive directory processing.</li>
        <li>Use <code>List Resources</code> to verify digest + metadata.</li>
      </ul>
      <pre><code>Path example:
/Users/you/downloads/report.pdf</code></pre>
    `,
    full: `
      <p>Equivalent to <code>stemma ingest ...</code>, <code>stemma resources</code>, and bulk import workflows. The archive is digest-addressed.</p>
      <h4>Tips</h4>
      <ul>
        <li>Duplicate file bytes return status <code>duplicate</code> without archive rewrite.</li>
        <li>Single-file import attempts extraction/vector indexing automatically for extractable media types.</li>
        <li>Mass import recursively scans a root path and resumes using state/log files under <code>.stemma/</code>.</li>
        <li>Use resources listing to obtain <code>resource.id</code> and digest for downstream steps.</li>
      </ul>
      <pre><code>Typical flow:
1) Import file or run mass import
2) List Resources (limit 20)
3) Confirm extraction/vector status in response</code></pre>
    `,
  },
  references: {
    title: "References",
    basic: `
      <p>Import bibliography records and connect citations to ingested resources.</p>
      <ul>
        <li><code>Import BibTeX</code> reads a .bib file.</li>
        <li><code>Link Ref-&gt;Resource</code> maps cite ID to resource digest.</li>
      </ul>
      <pre><code>Cite ID example: AB12
Digest example: 64-char sha256</code></pre>
    `,
    full: `
      <p>Use this when turning bibliographic metadata into auditable source links.</p>
      <h4>Recommended flow</h4>
      <ul>
        <li>Import BibTeX first.</li>
        <li>List citations to get generated cite IDs.</li>
        <li>Link each citation to a known ingested digest.</li>
      </ul>
      <pre><code>1) Import BibTeX
2) List Citations
3) Link Ref-&gt;Resource using cite_id + digest
4) List Refs to confirm links</code></pre>
    `,
  },
  extraction: {
    title: "Extraction",
    basic: `
      <p>Run extraction for one resource, then inspect tables, text, segments, and annotations.</p>
      <ul>
        <li>Provide either resource ID or digest.</li>
        <li><code>Run Extract</code> creates extraction runs.</li>
        <li><code>List Tables</code> returns extracted table records.</li>
        <li><code>Extraction Inspector</code> calls text/segment/annotation/dump APIs.</li>
      </ul>
      <pre><code>Use exactly one selector:
- Resource ID
- Resource digest</code></pre>
    `,
    full: `
      <p>This maps to <code>stemma extract run</code>, <code>stemma extract tables</code>, <code>stemma extract text</code>, <code>stemma extract segments</code>, <code>stemma extract annotations</code>, and <code>stemma extract dump</code>.</p>
      <h4>What to watch</h4>
      <ul>
        <li>Summary fields: parser, timing, tables found.</li>
        <li>Table IDs are deterministic for stable binding.</li>
        <li>Inspector supports optional <code>run_id</code> for historical run debugging.</li>
        <li>Segments and annotations include compact cards with <code>Copy Selector JSON</code> actions.</li>
      </ul>
      <pre><code>1) Run Extract for digest
2) List Tables for same digest
3) Use Inspect Text / Segments / Annotations
4) Copy table_id into binding selectors if needed</code></pre>
    `,
  },
  vector: {
    title: "Vector",
    basic: `
      <p>Manage vector indexing and semantic search.</p>
      <ul>
        <li><code>Index</code>: index latest or specified extraction run for one resource.</li>
        <li><code>Status</code>: show backend, model, chunk counts, and recent runs.</li>
        <li><code>Backfill</code>: index missing latest runs in bulk.</li>
        <li><code>Search</code>: semantic lookup over indexed chunks.</li>
      </ul>
    `,
    full: `
      <p>This panel wraps <code>/api/vector/index</code>, <code>/api/vector/status</code>, <code>/api/vector/backfill</code>, and <code>/api/vector/search</code>.</p>
      <h4>Good workflow</h4>
      <ul>
        <li>Run extraction first.</li>
        <li>Index resource or backfill recent candidates.</li>
        <li>Use status to check chunk/point consistency.</li>
        <li>Run semantic queries and inspect hit metadata.</li>
      </ul>
    `,
  },
  claims: {
    title: "Claims",
    basic: `
      <p>Import claims into a claim set and inspect claim records.</p>
      <ul>
        <li>Choose format (<code>csv</code>, <code>json</code>, <code>md</code>).</li>
        <li>Set claim set name for grouping.</li>
      </ul>
      <pre><code>Claim set example: annual-report-2025</code></pre>
    `,
    full: `
      <p>This card is the entry point for structured assertion data.</p>
      <h4>Good workflow</h4>
      <ul>
        <li>Import into a named claim set.</li>
        <li>Use list filters to inspect only one set.</li>
        <li>Then bind evidence and run verification.</li>
      </ul>
      <pre><code>1) Import Claims
2) List Claim Sets
3) List Claims (claim set filter)</code></pre>
    `,
  },
  binding: {
    title: "Binding",
    basic: `
      <p>Attach evidence selectors to a claim and validate required roles.</p>
      <ul>
        <li>Provide claim ID and one resource selector (ID or digest).</li>
        <li>Provide role and selector JSON array.</li>
      </ul>
      <pre><code>[{"type":"PageGeometrySelector","pageIndex":0,"boxes":[]},
 {"type":"TextQuoteSelector","exact":"example"}]</code></pre>
    `,
    full: `
      <p>Bindings are the core of machine-verifiable provenance.</p>
      <h4>Guidance</h4>
      <ul>
        <li>Use at least two distinct selector types for robustness.</li>
        <li>Run <code>Validate Binding</code> after each add.</li>
        <li>For quantitative claims, include value-cell and supporting roles.</li>
      </ul>
      <pre><code>1) Add Binding
2) Validate Binding
3) Fix missing roles or selector diversity issues</code></pre>
    `,
  },
  verification: {
    title: "Verification and Reports",
    basic: `
      <p>Run deterministic verification and export run reports.</p>
      <ul>
        <li><code>Verify Claim</code>: one claim.</li>
        <li><code>Verify Set</code>: all claims in set.</li>
        <li><code>Get Report</code>: summary + optional file exports.</li>
      </ul>
      <pre><code>Policy profile defaults to "strict"</code></pre>
    `,
    full: `
      <p>Use verification after import + binding are complete.</p>
      <h4>Typical process</h4>
      <ul>
        <li>Verify set for batch signal.</li>
        <li>Use report output to inspect failures.</li>
        <li>Optionally export JSON and Markdown reports.</li>
      </ul>
      <pre><code>1) Verify Set (claim set)
2) Copy run_id from response
3) Get Report with run_id</code></pre>
    `,
  },
  trace: {
    title: "Trace",
    basic: `
      <p>Navigate links between claims, evidence, resources, and citations.</p>
      <ul>
        <li>Trace from claim ID, resource selector, or cite ID.</li>
      </ul>
      <pre><code>Trace by one anchor at a time:
- claim_id
- resource_id/resource_digest
- cite_id</code></pre>
    `,
    full: `
      <p>Trace is best for audits and debugging missing evidence links.</p>
      <h4>Use cases</h4>
      <ul>
        <li>Confirm which evidence items back a claim.</li>
        <li>Find all claims tied to one resource.</li>
        <li>Review citation-resource consistency.</li>
      </ul>
      <pre><code>1) Trace claim
2) Trace resource from returned resource id
3) Trace citation from cite id</code></pre>
    `,
  },
  ceapf: {
    title: "CEAPF",
    basic: `
      <p>Create propositions/assertions and connect them with argument relations.</p>
      <ul>
        <li>Add proposition JSON.</li>
        <li>Add assertion event for proposition.</li>
        <li>Add support/rebuttal relation edges.</li>
      </ul>
      <pre><code>{"subject":"org:X","predicate":"ceapf:spent","object":{"amount":3.4,"unit":"GBP"}}</code></pre>
    `,
    full: `
      <p>CEAPF supports higher-level argument graph modeling on top of evidence.</p>
      <h4>Practical flow</h4>
      <ul>
        <li>Create proposition first.</li>
        <li>Create assertion(s) with modality and agent.</li>
        <li>Connect assertions and propositions with directed relation types.</li>
      </ul>
      <pre><code>Relation types:
- supports
- rebuts
- undercuts
- qualifies</code></pre>
    `,
  },
};

function installHelpButtons() {
  document.querySelectorAll('.card[data-help-key]').forEach((card) => {
    const key = card.dataset.helpKey;
    const icon = document.createElement('button');
    icon.className = 'help-icon';
    icon.textContent = '?';
    icon.title = 'Help';
    icon.setAttribute('aria-label', 'Help');
    icon.onclick = () => showHelp(key);
    card.appendChild(icon);
  });
}

function showHelp(key) {
  const entry = HELP_CONTENT[key];
  if (!entry) return;
  document.getElementById('help-title').textContent = `${entry.title} Help`;
  document.getElementById('help-content').innerHTML = `
    <h4>Basic</h4>
    ${entry.basic || ''}
    <h4>Comprehensive</h4>
    ${entry.full || ''}
  `;
  const modal = document.getElementById('help-modal');
  modal.classList.add('open');
  modal.setAttribute('aria-hidden', 'false');
}

function closeHelp() {
  const modal = document.getElementById('help-modal');
  modal.classList.remove('open');
  modal.setAttribute('aria-hidden', 'true');
}

function setActivePane(pane) {
  const panels = Array.from(document.querySelectorAll('.workspace-panel[data-pane]'));
  if (!panels.length) return;

  const known = new Set(panels.map((panel) => panel.dataset.pane));
  const chosen = known.has(pane) ? pane : panels[0].dataset.pane;

  panels.forEach((panel) => {
    panel.classList.toggle('active', panel.dataset.pane === chosen);
  });
  document.querySelectorAll('.nav-btn[data-pane]').forEach((btn) => {
    btn.classList.toggle('active', btn.dataset.pane === chosen);
  });

  const entry = HELP_CONTENT[chosen];
  const subtitle = document.getElementById('workspace-subtitle');
  if (subtitle) subtitle.textContent = entry ? entry.title : chosen;
  localStorage.setItem('stemmaActivePane', chosen);
}

function initWorkspaceNav() {
  const buttons = Array.from(document.querySelectorAll('.nav-btn[data-pane]'));
  buttons.forEach((btn) => {
    btn.onclick = () => setActivePane(btn.dataset.pane);
  });
  const saved = localStorage.getItem('stemmaActivePane');
  const fallback = buttons.length ? buttons[0].dataset.pane : 'project';
  setActivePane(saved || fallback);
}

function initResizableOutputs() {
  const minHeightPx = 320;
  document.querySelectorAll('pre[id^="out-"]').forEach((panel) => {
    const key = `stemmaOutHeight:${panel.id}`;
    const saved = Number(localStorage.getItem(key) || "0");
    if (Number.isFinite(saved) && saved >= minHeightPx) {
      panel.style.height = `${saved}px`;
    }
    const persist = () => {
      const next = Math.max(minHeightPx, panel.clientHeight || minHeightPx);
      localStorage.setItem(key, String(next));
    };
    panel.addEventListener('mouseup', persist);
    panel.addEventListener('touchend', persist, { passive: true });
  });
}

function setTheme(themeName) {
  const allowed = new Set([
    'harmonious-light',
    'restful-dark',
    'forest-mist',
    'sunset-paper',
    'midnight-contrast',
  ]);
  const selected = allowed.has(themeName) ? themeName : 'harmonious-light';
  document.body.setAttribute('data-theme', selected);
  localStorage.setItem('stemmaTheme', selected);
  const picker = document.getElementById('theme-select');
  if (picker && picker.value !== selected) picker.value = selected;
}

function initTheme() {
  const saved = localStorage.getItem('stemmaTheme');
  setTheme(saved || 'harmonious-light');
}

function candidateApiUrls(url) {
  const results = [];
  const seen = new Set();
  const add = (u) => {
    if (!u || seen.has(u)) return;
    seen.add(u);
    results.push(u);
  };

  // Absolute path as configured in the UI.
  add(url);

  // Relative fallback (works when app is mounted under a path prefix).
  if (url.startsWith('/')) add(url.slice(1));

  // Prefix fallback for mounts like /stemma -> /stemma/api/...
  if (url.startsWith('/')) {
    const path = window.location.pathname || '/';
    const trimmed = path.replace(/\/+$/, '');
    const lastSeg = trimmed.split('/').pop() || '';
    if (trimmed && trimmed !== '/' && !lastSeg.includes('.')) {
      const prefixed = `${trimmed}${url}`;
      add(prefixed.replace(/\/{2,}/g, '/'));
    }
  }

  return results;
}

async function callApi(method, url, body, outId, isFormData=false) {
  const opts = { method, headers: {} };
  if (body !== null && body !== undefined) {
    if (isFormData) {
      opts.body = body;
    } else {
      opts.headers['Content-Type'] = 'application/json';
      opts.body = JSON.stringify(body);
    }
  }
  const attempts = candidateApiUrls(url);
  let lastData = null;
  try {
    for (const attemptUrl of attempts) {
      const res = await fetch(attemptUrl, opts);
      let data;
      const contentType = (res.headers.get('content-type') || '').toLowerCase();
      if (contentType.includes('application/json')) {
        data = await res.json();
      } else {
        const text = await res.text();
        data = { detail: text || `HTTP ${res.status}` };
      }

      if (!(res.status === 404 && data && data.detail === 'Not Found')) {
        if (outId) document.getElementById(outId).textContent = JSON.stringify(data, null, 2);
        return data;
      }
      lastData = data;
    }

    const payload = {
      ...(lastData || { detail: 'Not Found' }),
      attempted_urls: attempts,
    };
    if (outId) document.getElementById(outId).textContent = JSON.stringify(payload, null, 2);
    return payload;
  } catch (e) {
    if (outId) {
      document.getElementById(outId).textContent = JSON.stringify(
        { error: String(e), attempted_urls: attempts },
        null,
        2
      );
    }
    throw e;
  }
}

const HEALTH_FIELD_HELP = {
  ok: 'Overall result of the full doctor check suite.',
  checks_run: 'Number of health checks executed in this doctor run.',
  journal_mode: 'SQLite journal mode. WAL is required for robust concurrent access.',
  busy_timeout_ms: 'Milliseconds SQLite waits for a lock before failing.',
  foreign_keys: 'Whether SQLite foreign key constraints are enforced.',
  synchronous: 'SQLite durability level. Higher values increase durability.',
  wal_autocheckpoint_pages: 'WAL pages written before automatic checkpoint.',
  issues: 'Warnings and errors discovered during doctor checks.',
};

function toSafeInt(value, fallback = 0) {
  const parsed = Number(value);
  return Number.isFinite(parsed) ? Math.floor(parsed) : fallback;
}

function statusClass(status) {
  const normalized = String(status || '').toLowerCase();
  if (normalized === 'ok' || normalized === 'healthy' || normalized === 'success' || normalized === 'pass') {
    return 'status-ok';
  }
  if (normalized === 'warning' || normalized === 'warn' || normalized === 'degraded') {
    return 'status-warn';
  }
  if (normalized === 'error' || normalized === 'failed' || normalized === 'fail') {
    return 'status-error';
  }
  return 'status-neutral';
}

function infoIcon(tooltip) {
  return `<span class="info-icon" title="${dbEscapeHtml(tooltip || '')}" aria-label="${dbEscapeHtml(tooltip || '')}">?</span>`;
}

function metricCard(label, valueHtml, helpText='') {
  return `
    <article class="metric-card">
      <p class="metric-label">${dbEscapeHtml(label)}${helpText ? ' ' + infoIcon(helpText) : ''}</p>
      <p class="metric-value">${valueHtml}</p>
    </article>
  `;
}

function renderIssueList(containerId, issues) {
  const container = document.getElementById(containerId);
  if (!container) return;
  if (!Array.isArray(issues) || !issues.length) {
    container.innerHTML = '<p class="small">No issues detected.</p>';
    return;
  }
  container.innerHTML = issues
    .map((issue) => {
      const level = String(issue.level || 'info').toLowerCase();
      const klass = level === 'error' ? 'issue-error' : (level === 'warning' ? 'issue-warning' : 'issue-info');
      return `<article class="issue-item ${klass}"><strong>${dbEscapeHtml(level)}</strong>${dbEscapeHtml(issue.message || '')}</article>`;
    })
    .join('');
}

function renderProjectHealth(payload) {
  const statusLine = document.getElementById('project-health-status');
  const visual = document.getElementById('project-health-visual');
  if (!statusLine || !visual) return;

  if (!payload || payload.ok === undefined) {
    statusLine.textContent = 'No health payload loaded.';
    visual.innerHTML = '';
    renderIssueList('project-health-issues', []);
    return;
  }

  if (payload.db_runtime) {
    const issues = Array.isArray(payload.issues) ? payload.issues : [];
    const errorCount = issues.filter((i) => String(i.level || '').toLowerCase() === 'error').length;
    const warningCount = issues.filter((i) => String(i.level || '').toLowerCase() === 'warning').length;
    const overall = payload.ok ? (warningCount > 0 ? 'warning' : 'ok') : 'error';
    statusLine.textContent = `Doctor loaded: ${payload.checks_run || 0} checks, ${errorCount} errors, ${warningCount} warnings.`;

    const runtime = payload.db_runtime || {};
    const syncCode = Number(runtime.synchronous);
    const syncName = (
      syncCode === 0 ? 'OFF' :
      syncCode === 1 ? 'NORMAL' :
      syncCode === 2 ? 'FULL' :
      syncCode === 3 ? 'EXTRA' :
      `CODE ${dbEscapeHtml(String(syncCode))}`
    );

    visual.innerHTML = `
      ${metricCard('Overall', `<span class="status-pill ${statusClass(overall)}">${dbEscapeHtml(overall.toUpperCase())}</span>`, HEALTH_FIELD_HELP.ok)}
      ${metricCard('Checks Run', dbEscapeHtml(String(payload.checks_run ?? 0)), HEALTH_FIELD_HELP.checks_run)}
      ${metricCard('Journal Mode', `<span class="status-pill ${statusClass(runtime.journal_mode === 'wal' ? 'ok' : 'warning')}">${dbEscapeHtml(String(runtime.journal_mode || 'unknown').toUpperCase())}</span>`, HEALTH_FIELD_HELP.journal_mode)}
      ${metricCard('Busy Timeout', `${dbEscapeHtml(String(runtime.busy_timeout_ms ?? 0))} ms`, HEALTH_FIELD_HELP.busy_timeout_ms)}
      ${metricCard('Foreign Keys', `<span class="status-pill ${statusClass(runtime.foreign_keys ? 'ok' : 'error')}">${runtime.foreign_keys ? 'ENABLED' : 'DISABLED'}</span>`, HEALTH_FIELD_HELP.foreign_keys)}
      ${metricCard('Synchronous', dbEscapeHtml(syncName), HEALTH_FIELD_HELP.synchronous)}
      ${metricCard('WAL Auto-checkpoint', `${dbEscapeHtml(String(runtime.wal_autocheckpoint_pages ?? 'n/a'))} pages`, HEALTH_FIELD_HELP.wal_autocheckpoint_pages)}
      ${metricCard('Issues', dbEscapeHtml(String(issues.length)), HEALTH_FIELD_HELP.issues)}
    `;
    renderIssueList('project-health-issues', issues);
    return;
  }

  const created = Array.isArray(payload.paths_created) ? payload.paths_created : [];
  statusLine.textContent = payload.ok
    ? `Project initialized. ${created.length} path(s) created or repaired.`
    : 'Project initialization failed.';
  visual.innerHTML = `
    ${metricCard('Init Status', `<span class="status-pill ${statusClass(payload.ok ? 'ok' : 'error')}">${payload.ok ? 'READY' : 'FAILED'}</span>`, 'Result of project initialization.')}
    ${metricCard('Database Path', dbEscapeHtml(String(payload.db_path || 'n/a')), 'SQLite database path used by this project.')}
    ${metricCard('Paths Created', dbEscapeHtml(String(created.length)), 'Filesystem paths created or repaired by init.')}
  `;
  renderIssueList('project-health-issues', []);
}

async function runInitProject() {
  const payload = await callApi('POST', '/api/init', {}, 'out-project');
  renderProjectHealth(payload);
}

async function runDoctor() {
  const payload = await callApi('GET', '/api/doctor', null, 'out-project');
  renderProjectHealth(payload);
}

function dashboardRunCards(data) {
  const container = document.getElementById('dashboard-runs');
  if (!container) return;
  const extraction = data?.latest?.extraction_run || null;
  const verification = data?.latest?.verification_run || null;
  const cards = [];
  if (extraction) {
    cards.push(
      `<article class="issue-item issue-info"><strong>Extraction</strong>run ${dbEscapeHtml(extraction.id)} (${dbEscapeHtml(extraction.status || 'unknown')}) at ${dbEscapeHtml(extraction.created_at || 'n/a')}</article>`
    );
  }
  if (verification) {
    const counts = verification.result_status_counts || {};
    const statusSummary = Object.keys(counts).sort().map((k) => `${k}=${counts[k]}`).join(', ') || 'no results';
    cards.push(
      `<article class="issue-item issue-info"><strong>Verification</strong>run ${dbEscapeHtml(verification.id)} (${dbEscapeHtml(verification.policy_profile || 'n/a')}) at ${dbEscapeHtml(verification.created_at || 'n/a')} | ${dbEscapeHtml(statusSummary)}</article>`
    );
  }
  if (!cards.length) {
    container.innerHTML = '<p class="small">No recent extraction or verification runs found.</p>';
    return;
  }
  container.innerHTML = cards.join('');
}

function renderDashboard(data, includeDoctor) {
  const statusEl = document.getElementById('dashboard-status');
  const kpiEl = document.getElementById('dashboard-kpis');
  if (!statusEl || !kpiEl) return;

  if (!data || data.ok !== true) {
    statusEl.textContent = 'Failed to load dashboard summary.';
    kpiEl.innerHTML = '';
    dashboardRunCards(null);
    return;
  }

  const counts = data.counts || {};
  const vector = data.vector || {};
  const health = data.health || null;
  const healthLabel = health
    ? (health.ok ? (health.warning_count > 0 ? 'WARNING' : 'OK') : 'ERROR')
    : 'NOT RUN';
  const healthTone = health
    ? (health.ok ? (health.warning_count > 0 ? 'warning' : 'ok') : 'error')
    : 'neutral';

  kpiEl.innerHTML = `
    ${metricCard('System Health', `<span class="status-pill ${statusClass(healthTone)}">${dbEscapeHtml(healthLabel)}</span>`, 'Doctor status snapshot.')}
    ${metricCard('Resources', dbEscapeHtml(String(counts.resources ?? 0)), 'Ingested source documents.')}
    ${metricCard('Claims', dbEscapeHtml(String(counts.claims ?? 0)), 'Claims available for verification.')}
    ${metricCard('Evidence Bindings', dbEscapeHtml(String(counts.claim_evidence_bindings ?? 0)), 'Claim-to-evidence links.')}
    ${metricCard('Extraction Runs', dbEscapeHtml(String(counts.extraction_runs ?? 0)), 'Total extraction runs in project history.')}
    ${metricCard('Verification Runs', dbEscapeHtml(String(counts.verification_runs ?? 0)), 'Total verification runs in project history.')}
    ${metricCard('Vector Backend', dbEscapeHtml(String(vector.backend || 'n/a')), 'Current vector backend mode.')}
    ${metricCard('Vector Points', dbEscapeHtml(String(vector.qdrant_points ?? 0)), 'Point count in vector database collection.')}
  `;

  statusEl.textContent = `Summary refreshed at ${data.generated_at || 'n/a'}${includeDoctor ? ' (doctor included).' : '.'}`;
  dashboardRunCards(data);

  if (health) {
    renderProjectHealth(health);
  }
}

async function loadDashboard(includeDoctor = false) {
  const query = includeDoctor ? '?include_doctor=true' : '';
  const payload = await callApi('GET', `/api/dashboard/summary${query}`, null, 'out-dashboard');
  renderDashboard(payload, includeDoctor);
}

function vectorTargetPayload() {
  const resourceId = (document.getElementById('vector-resource-id').value || '').trim();
  const resourceDigest = (document.getElementById('vector-resource-digest').value || '').trim();
  const extractionRunId = (document.getElementById('vector-extraction-run-id').value || '').trim();
  return {
    resourceId,
    resourceDigest,
    extractionRunId,
  };
}

function vectorStatusQuery() {
  const target = vectorTargetPayload();
  const limitRaw = document.getElementById('vector-status-limit').value || '25';
  const limit = Math.max(1, toSafeInt(limitRaw, 25));
  const params = new URLSearchParams();
  params.set('limit_runs', String(limit));
  if (target.resourceId) {
    params.set('resource_id', target.resourceId);
  } else if (target.resourceDigest) {
    params.set('resource_digest', target.resourceDigest);
  }
  return params.toString();
}

function renderVectorStatus(payload) {
  const note = document.getElementById('vector-status-note');
  const summary = document.getElementById('vector-summary');
  const runs = document.getElementById('vector-runs');
  if (!note || !summary || !runs) return;

  if (!payload || payload.ok !== true) {
    note.textContent = 'Vector status request failed.';
    summary.innerHTML = '';
    runs.innerHTML = '<p class="small">No vector status available.</p>';
    return;
  }

  const runList = Array.isArray(payload.runs) ? payload.runs : [];
  const successCount = runList.filter((r) => r.status === 'success').length;
  const failedCount = runList.filter((r) => r.status === 'failed').length;
  const runningCount = runList.filter((r) => r.status === 'running').length;
  const skippedCount = runList.filter((r) => r.status === 'skipped').length;

  summary.innerHTML = `
    ${metricCard('Backend', dbEscapeHtml(String(payload.backend || 'n/a')), 'Vector backend currently in use.')}
    ${metricCard('Collection', dbEscapeHtml(String(payload.collection_name || 'n/a')), 'Qdrant collection name.')}
    ${metricCard('Embedding Model', dbEscapeHtml(String(payload.embedding_model || 'n/a')), 'Embedding model used for indexing and querying.')}
    ${metricCard('Chunk Rows', dbEscapeHtml(String(payload.vector_chunk_rows ?? 0)), 'Rows in SQLite vector_chunks table.')}
    ${metricCard('Distinct Chunks', dbEscapeHtml(String(payload.distinct_chunk_ids ?? 0)), 'Distinct chunk identifiers indexed in SQLite.')}
    ${metricCard('Vector Points', dbEscapeHtml(String(payload.qdrant_points ?? 0)), 'Point count in vector database.')}
    ${metricCard('Run Success', dbEscapeHtml(String(successCount)), 'Recent successful vector index runs.')}
    ${metricCard('Run Failures', dbEscapeHtml(String(failedCount)), 'Recent failed vector index runs.')}
    ${metricCard('Run Running', dbEscapeHtml(String(runningCount)), 'Recent in-progress vector index runs.')}
    ${metricCard('Run Skipped', dbEscapeHtml(String(skippedCount)), 'Recent skipped vector index runs.')}
  `;
  note.textContent = `Loaded ${runList.length} recent vector run(s).`;

  if (!runList.length) {
    runs.innerHTML = '<p class="small">No vector runs found.</p>';
    return;
  }
  runs.innerHTML = runList
    .map((run) => {
      const tone = run.status === 'success' ? 'ok' : (run.status === 'failed' ? 'error' : (run.status === 'running' ? 'warning' : 'neutral'));
      const err = run.error_message ? `\nerror: ${run.error_message}` : '';
      return `
        <article class="vector-card">
          <h4><span class="status-pill ${statusClass(tone)}">${dbEscapeHtml(String(run.status || 'unknown').toUpperCase())}</span> ${dbEscapeHtml(run.id || '')}</h4>
          <p>resource: ${dbEscapeHtml(run.resource_id || 'n/a')}
extraction_run: ${dbEscapeHtml(run.extraction_run_id || 'n/a')}
chunks: ${dbEscapeHtml(String(run.chunks_indexed ?? 0))}/${dbEscapeHtml(String(run.chunks_total ?? 0))}
created: ${dbEscapeHtml(run.created_at || 'n/a')}
finished: ${dbEscapeHtml(run.finished_at || 'n/a')}${dbEscapeHtml(err)}</p>
        </article>
      `;
    })
    .join('');
}

function renderVectorSearch(payload) {
  const container = document.getElementById('vector-search-results');
  if (!container) return;
  if (!payload || payload.ok !== true) {
    container.innerHTML = '<p class="small">Vector search request failed.</p>';
    return;
  }
  const hits = Array.isArray(payload.hits) ? payload.hits : [];
  if (!hits.length) {
    container.innerHTML = '<p class="small">No semantic matches found.</p>';
    return;
  }
  container.innerHTML = hits
    .map((hit, idx) => `
      <article class="vector-card">
        <h4>#${idx + 1} score=${dbEscapeHtml(String(hit.score ?? 'n/a'))}</h4>
        <p>chunk_id: ${dbEscapeHtml(hit.chunk_id || 'n/a')}
resource_id: ${dbEscapeHtml(hit.resource_id || 'n/a')}
extraction_run_id: ${dbEscapeHtml(hit.extraction_run_id || 'n/a')}
source: ${dbEscapeHtml(hit.source_type || 'n/a')} ${dbEscapeHtml(hit.source_ref || '')}
page: ${dbEscapeHtml(String(hit.page_index ?? 'n/a'))}
offsets: ${dbEscapeHtml(String(hit.start_offset ?? 'n/a'))}-${dbEscapeHtml(String(hit.end_offset ?? 'n/a'))}</p>
        <p>${dbEscapeHtml(String(hit.text_content || ''))}</p>
      </article>
    `)
    .join('');
}

async function vectorStatus() {
  const payload = await callApi('GET', `/api/vector/status?${vectorStatusQuery()}`, null, 'out-vector');
  renderVectorStatus(payload);
}

async function vectorIndex() {
  const target = vectorTargetPayload();
  if (!target.resourceId && !target.resourceDigest) {
    document.getElementById('out-vector').textContent = JSON.stringify(
      { error: 'Provide resource ID or resource digest.' },
      null,
      2
    );
    return;
  }
  const payload = await callApi(
    'POST',
    '/api/vector/index',
    {
      resource_id: target.resourceId || null,
      resource_digest: target.resourceDigest || null,
      extraction_run_id: target.extractionRunId || null,
      force: document.getElementById('vector-force').value === 'true',
    },
    'out-vector'
  );
  document.getElementById('vector-status-note').textContent = payload.ok
    ? 'Vector index request completed. Refreshing status...'
    : 'Vector index request failed.';
  await vectorStatus();
}

async function vectorBackfill() {
  const limitResources = Math.max(1, toSafeInt(document.getElementById('vector-backfill-limit-resources').value, 100000));
  const maxProcessRaw = (document.getElementById('vector-backfill-max-process').value || '').trim();
  const maxProcess = maxProcessRaw ? Math.max(1, toSafeInt(maxProcessRaw, 1)) : null;
  const payload = await callApi(
    'POST',
    '/api/vector/backfill',
    {
      limit_resources: limitResources,
      max_process: maxProcess,
    },
    'out-vector'
  );
  document.getElementById('vector-status-note').textContent = payload.ok
    ? 'Backfill request completed. Refreshing status...'
    : 'Backfill request failed.';
  await vectorStatus();
}

async function vectorSearch() {
  const target = vectorTargetPayload();
  const query = (document.getElementById('vector-query').value || '').trim();
  const limit = Math.max(1, toSafeInt(document.getElementById('vector-query-limit').value, 10));
  if (!query) {
    document.getElementById('out-vector').textContent = JSON.stringify(
      { error: 'Provide a semantic query string.' },
      null,
      2
    );
    return;
  }
  const payload = await callApi(
    'POST',
    '/api/vector/search',
    {
      query,
      limit,
      resource_id: target.resourceId || null,
      resource_digest: target.resourceDigest || null,
      extraction_run_id: target.extractionRunId || null,
    },
    'out-vector'
  );
  renderVectorSearch(payload);
}

let dbTables = [];
let dbLastPayload = null;
let dbGridSource = null;
let dbGridState = {
  sortColumn: null,
  sortDirection: 'asc',
  globalSearch: '',
  columnFilters: {},
};

function currentDbTable() {
  return document.getElementById('db-table-select').value;
}

function dbOutputMode() {
  const select = document.getElementById('db-view-mode');
  return select ? select.value : 'spreadsheet';
}

function renderDbResult(payload) {
  dbLastPayload = payload;
  document.getElementById('out-db').textContent = JSON.stringify(payload, null, 2);
}

function dbEscapeHtml(value) {
  return String(value)
    .replaceAll('&', '&amp;')
    .replaceAll('<', '&lt;')
    .replaceAll('>', '&gt;')
    .replaceAll('"', '&quot;')
    .replaceAll("'", '&#39;');
}

function dbCellText(value) {
  if (value === null || value === undefined) return '';
  if (typeof value === 'object') return JSON.stringify(value);
  return String(value);
}

function dbMaybeNumber(value) {
  if (typeof value === 'number' && Number.isFinite(value)) return value;
  if (typeof value !== 'string') return null;
  const trimmed = value.trim();
  if (!trimmed) return null;
  if (!/^[+-]?\d+(\.\d+)?$/.test(trimmed)) return null;
  const num = Number(trimmed);
  return Number.isFinite(num) ? num : null;
}

function dbResetGridState() {
  dbGridState.sortColumn = null;
  dbGridState.sortDirection = 'asc';
  dbGridState.globalSearch = '';
  dbGridState.columnFilters = {};
  const search = document.getElementById('db-search');
  if (search) search.value = '';
}

function dbSetGridSource(source) {
  dbGridSource = source;
  dbResetGridState();
  if (dbOutputMode() === 'spreadsheet') dbRenderGrid();
}

function dbSetGridMessage(message) {
  const meta = document.getElementById('db-grid-meta');
  const table = document.getElementById('db-grid-table');
  if (meta) meta.textContent = message;
  if (table) table.innerHTML = '';
}

function dbFilteredSortedRows() {
  if (!dbGridSource) return [];
  const columns = dbGridSource.columns;
  const global = (dbGridState.globalSearch || '').trim().toLowerCase();
  let rows = dbGridSource.rows.filter((row) => {
    if (global) {
      const hasGlobal = columns.some((col) => dbCellText(row[col]).toLowerCase().includes(global));
      if (!hasGlobal) return false;
    }
    for (const col of columns) {
      const filter = (dbGridState.columnFilters[col] || '').trim().toLowerCase();
      if (!filter) continue;
      if (!dbCellText(row[col]).toLowerCase().includes(filter)) return false;
    }
    return true;
  });

  const sortCol = dbGridState.sortColumn;
  if (!sortCol) return rows;
  const direction = dbGridState.sortDirection === 'desc' ? -1 : 1;
  rows = [...rows].sort((a, b) => {
    const av = a[sortCol];
    const bv = b[sortCol];
    if (av === bv) return 0;
    if (av === null || av === undefined) return 1 * direction;
    if (bv === null || bv === undefined) return -1 * direction;

    const an = dbMaybeNumber(av);
    const bn = dbMaybeNumber(bv);
    if (an !== null && bn !== null) return (an - bn) * direction;

    const as = dbCellText(av);
    const bs = dbCellText(bv);
    return as.localeCompare(bs, undefined, { numeric: true, sensitivity: 'base' }) * direction;
  });
  return rows;
}

function dbRenderGrid() {
  if (!dbGridSource || !Array.isArray(dbGridSource.columns) || !dbGridSource.columns.length) {
    dbSetGridMessage('No tabular data loaded yet.');
    return;
  }
  const columns = dbGridSource.columns;
  const visibleRows = dbFilteredSortedRows();
  const meta = document.getElementById('db-grid-meta');
  if (meta) {
    const loaded = dbGridSource.rows.length;
    const total = dbGridSource.totalRows ?? loaded;
    const offset = dbGridSource.offset ?? 0;
    const limit = dbGridSource.limit ?? loaded;
    const scope = dbGridSource.title || 'Current view';
    meta.textContent = `${scope}: ${visibleRows.length} matching rows (loaded ${loaded}, table total ${total}, offset ${offset}, limit ${limit}).`;
  }

  const table = document.getElementById('db-grid-table');
  const header = columns
    .map((col, idx) => {
      const active = dbGridState.sortColumn === col;
      const arrow = active ? (dbGridState.sortDirection === 'asc' ? ' ' : ' ') : '';
      return `<th><button class="db-sort-btn" type="button" data-col-idx="${idx}">${dbEscapeHtml(col)}${arrow}</button></th>`;
    })
    .join('');
  const filters = columns
    .map((col, idx) => {
      const value = dbGridState.columnFilters[col] || '';
      return `<th><input class="db-filter-input" data-col-idx="${idx}" value="${dbEscapeHtml(value)}" placeholder="Filter" /></th>`;
    })
    .join('');
  const body = visibleRows.length
    ? visibleRows
        .map((row) => {
          const cells = columns.map((col) => `<td class="db-cell">${dbEscapeHtml(dbCellText(row[col]))}</td>`).join('');
          return `<tr>${cells}</tr>`;
        })
        .join('')
    : `<tr><td class="small" colspan="${columns.length}">No rows match current filters.</td></tr>`;

  table.innerHTML = `<thead><tr>${header}</tr><tr class="db-filter-row">${filters}</tr></thead><tbody>${body}</tbody>`;

  table.querySelectorAll('.db-sort-btn').forEach((button) => {
    button.addEventListener('click', () => {
      const idx = Number(button.getAttribute('data-col-idx'));
      const col = columns[idx];
      if (!col) return;
      if (dbGridState.sortColumn === col) {
        dbGridState.sortDirection = dbGridState.sortDirection === 'asc' ? 'desc' : 'asc';
      } else {
        dbGridState.sortColumn = col;
        dbGridState.sortDirection = 'asc';
      }
      dbRenderGrid();
    });
  });
  table.querySelectorAll('.db-filter-input').forEach((input) => {
    input.addEventListener('input', () => {
      const idx = Number(input.getAttribute('data-col-idx'));
      const col = columns[idx];
      if (!col) return;
      dbGridState.columnFilters[col] = input.value || '';
      dbRenderGrid();
    });
  });
}

function dbSetViewMode(mode) {
  const allowed = new Set(['json', 'spreadsheet']);
  const selected = allowed.has(mode) ? mode : 'spreadsheet';
  const modeSelect = document.getElementById('db-view-mode');
  if (modeSelect && modeSelect.value !== selected) modeSelect.value = selected;
  localStorage.setItem('stemmaDbViewMode', selected);

  const pre = document.getElementById('out-db');
  const grid = document.getElementById('db-grid-view');
  const search = document.getElementById('db-search');
  const clear = document.getElementById('db-clear-filters');
  if (selected === 'spreadsheet') {
    if (grid) grid.classList.add('open');
    if (pre) pre.style.display = 'none';
    if (search) search.disabled = false;
    if (clear) clear.disabled = false;
    dbRenderGrid();
  } else {
    if (grid) grid.classList.remove('open');
    if (pre) pre.style.display = '';
    if (search) search.disabled = true;
    if (clear) clear.disabled = true;
    if (dbLastPayload) renderDbResult(dbLastPayload);
  }
}

function initDbExplorer() {
  const search = document.getElementById('db-search');
  if (search) {
    search.addEventListener('input', () => {
      dbGridState.globalSearch = search.value || '';
      if (dbOutputMode() === 'spreadsheet') dbRenderGrid();
    });
  }

  const savedMode = localStorage.getItem('stemmaDbViewMode');
  const modeSelect = document.getElementById('db-view-mode');
  if (modeSelect && (savedMode === 'json' || savedMode === 'spreadsheet')) {
    modeSelect.value = savedMode;
  }
  dbSetViewMode(modeSelect ? modeSelect.value : 'spreadsheet');
}

function dbClearFilters() {
  dbResetGridState();
  if (dbOutputMode() === 'spreadsheet') dbRenderGrid();
}

function refreshDbSelect() {
  const select = document.getElementById('db-table-select');
  const current = select.value;
  select.innerHTML = '';
  const placeholder = document.createElement('option');
  placeholder.value = '';
  placeholder.textContent = 'Select table';
  select.appendChild(placeholder);
  dbTables.forEach((t) => {
    const opt = document.createElement('option');
    opt.value = t.name;
    opt.textContent = `${t.name} (${t.row_count} rows)`;
    select.appendChild(opt);
  });
  if (current && dbTables.some((t) => t.name === current)) {
    select.value = current;
  }
}

async function dbListTables() {
  const data = await callApi('GET', '/api/db/tables', null, null);
  if (data && data.detail === 'Not Found') {
    const payload = {
      ok: false,
      error: 'Database Explorer API endpoint was not found on this server instance.',
      hint: 'Restart the web server from the current workspace so /api/db/tables is registered.',
      attempted_urls: data.attempted_urls || [],
    };
    renderDbResult(payload);
    dbSetGridMessage(payload.error);
    return;
  }

  dbTables = Array.isArray(data.tables) ? data.tables : [];
  refreshDbSelect();

  renderDbResult(data);
  dbSetGridSource({
    title: 'Table list',
    table: null,
    columns: ['name', 'row_count', 'column_count'],
    rows: dbTables.map((t) => ({
      name: t.name,
      row_count: t.row_count,
      column_count: Array.isArray(t.columns) ? t.columns.length : 0,
    })),
    totalRows: dbTables.length,
    offset: 0,
    limit: dbTables.length,
  });
}

async function dbViewTable() {
  const name = currentDbTable();
  if (!name) {
    const payload = { error: 'Select a table first.' };
    renderDbResult(payload);
    dbSetGridMessage(payload.error);
    return;
  }
  const limit = Number(document.getElementById('db-limit').value || '50');
  const offset = Number(document.getElementById('db-offset').value || '0');
  const safeLimit = Number.isFinite(limit) && limit > 0 ? Math.floor(limit) : 50;
  const safeOffset = Number.isFinite(offset) && offset >= 0 ? Math.floor(offset) : 0;
  const data = await callApi(
    'GET',
    `/api/db/table?name=${encodeURIComponent(name)}&limit=${safeLimit}&offset=${safeOffset}`,
    null,
    null
  );
  renderDbResult(data);
  if (!data || data.ok !== true || !Array.isArray(data.rows)) {
    dbSetGridMessage(data?.detail || data?.error || 'Unable to load table rows.');
    return;
  }
  dbSetGridSource({
    title: `Table: ${name}`,
    table: name,
    columns: Array.isArray(data.columns) ? data.columns : [],
    rows: data.rows,
    totalRows: Number.isFinite(data.total_rows) ? data.total_rows : data.rows.length,
    offset: safeOffset,
    limit: safeLimit,
  });
}

function dbDescribeTable() {
  const name = currentDbTable();
  if (!name) {
    const payload = { error: 'Select a table first.' };
    renderDbResult(payload);
    dbSetGridMessage(payload.error);
    return;
  }
  const match = dbTables.find((t) => t.name === name);
  if (!match) {
    const payload = { error: 'Table metadata not loaded. Click "List Tables" first.' };
    renderDbResult(payload);
    dbSetGridMessage(payload.error);
    return;
  }
  const payload = {
    ok: true,
    table: name,
    row_count: match.row_count,
    columns: match.columns,
    create_sql: match.create_sql,
  };
  renderDbResult(payload);
  dbSetGridSource({
    title: `Schema: ${name}`,
    table: name,
    columns: ['name', 'type', 'notnull', 'pk'],
    rows: Array.isArray(match.columns)
      ? match.columns.map((c) => ({
          name: c.name,
          type: c.type,
          notnull: c.notnull,
          pk: c.pk,
        }))
      : [],
    totalRows: Array.isArray(match.columns) ? match.columns.length : 0,
    offset: 0,
    limit: Array.isArray(match.columns) ? match.columns.length : 0,
  });
}

const IMPORT_STEPS = [
  { id: 'archive', label: 'Archive & Dedupe' },
  { id: 'extract', label: 'Text Extraction' },
  { id: 'tables', label: 'Tables & Annotations' },
  { id: 'vector', label: 'Vector Index Update' },
];

let importProgressTimer = null;
let importCounterTimer = null;
let importProgressValue = 0;
let importPreviewUrl = null;
let importHistoryItems = [];

function importFileSizeText(bytes) {
  const n = Number(bytes);
  if (!Number.isFinite(n) || n < 0) return 'unknown size';
  if (n < 1024) return `${n} B`;
  if (n < 1024 * 1024) return `${(n / 1024).toFixed(1)} KB`;
  return `${(n / (1024 * 1024)).toFixed(1)} MB`;
}

function importPathBasename(path) {
  if (!path) return 'document';
  const clean = String(path).replace(/\\/g, '/');
  const parts = clean.split('/');
  return parts[parts.length - 1] || clean;
}

function importClearPreviewUrl() {
  if (importPreviewUrl) {
    URL.revokeObjectURL(importPreviewUrl);
    importPreviewUrl = null;
  }
}

function importPreviewMarkup(meta) {
  if (meta && meta.file && meta.file.type && meta.file.type.startsWith('image/')) {
    importClearPreviewUrl();
    importPreviewUrl = URL.createObjectURL(meta.file);
    return `<img src="${importPreviewUrl}" alt="${dbEscapeHtml(meta.file.name || 'import file')}" />`;
  }

  const name = (meta && meta.name) ? String(meta.name) : '';
  const looksPdf = (meta && meta.file && meta.file.type === 'application/pdf') || name.toLowerCase().endsWith('.pdf');
  if (meta && meta.file && looksPdf) {
    importClearPreviewUrl();
    importPreviewUrl = URL.createObjectURL(meta.file);
    return `<embed src="${importPreviewUrl}#toolbar=0&navpanes=0&scrollbar=0" type="application/pdf" />`;
  }

  const title = dbEscapeHtml(name || 'Document');
  return `<div><strong>${title}</strong><br /><span class="small">Preview available for dropped PDF/image files.</span></div>`;
}

function importStepHtml(stepState) {
  const state = stepState.state || 'pending';
  const detail = stepState.detail ? dbEscapeHtml(stepState.detail) : '';
  const stats = stepState.stats ? `  ${dbEscapeHtml(stepState.stats)}` : '';
  const progressRaw = Number(stepState.progress);
  const progress = Number.isFinite(progressRaw)
    ? Math.max(0, Math.min(100, progressRaw))
    : (state === 'pending' ? 0 : 100);
  return `
    <div class="import-step ${state}">
      <div class="import-step-head">
        <strong>${dbEscapeHtml(stepState.label)}</strong>
        <span class="step-badge">${dbEscapeHtml(state)}</span>
      </div>
      <div class="step-progress-track">
        <div class="step-progress-bar ${state === 'active' ? 'active' : ''}" style="width:${progress}%"></div>
      </div>
      <p class="import-step-detail">${detail}${stats}</p>
    </div>
  `;
}

function importRenderHistory() {
  const el = document.getElementById('import-history');
  if (!el) return;
  if (!importHistoryItems.length) {
    el.innerHTML = '<p class="small">No imports yet.</p>';
    return;
  }
  el.innerHTML = importHistoryItems
    .map((item) => `
      <article class="import-history-item">
        <h4><span class="status-pill ${statusClass(item.statusTone || 'neutral')}">${dbEscapeHtml(item.statusLabel || 'unknown')}</span>${dbEscapeHtml(item.name || 'document')}</h4>
        <p>${dbEscapeHtml(item.summary || '')}</p>
      </article>
    `)
    .join('');
}

function importAddHistory(item) {
  importHistoryItems.unshift(item);
  if (importHistoryItems.length > 12) importHistoryItems.length = 12;
  importRenderHistory();
}

function importStopTimers() {
  if (importProgressTimer) {
    clearInterval(importProgressTimer);
    importProgressTimer = null;
  }
  if (importCounterTimer) {
    clearInterval(importCounterTimer);
    importCounterTimer = null;
  }
}

function importSetProgress(value, active = false) {
  const bar = document.getElementById('import-progress-bar');
  if (!bar) return;
  bar.style.width = `${Math.max(0, Math.min(100, value))}%`;
  bar.classList.toggle('active', active);
}

function importRenderLive(meta, opts = {}) {
  const live = document.getElementById('import-live');
  if (!live) return;
  live.classList.remove('empty');

  const stepHtml = Array.isArray(opts.steps) ? opts.steps.map(importStepHtml).join('') : '';
  const metricHtml = Array.isArray(opts.metrics)
    ? opts.metrics
        .map((m) => `
          <div class="import-metric">
            <p class="k">${dbEscapeHtml(m.k || '')}</p>
            <p class="v">${dbEscapeHtml(String(m.v ?? ''))}</p>
          </div>
        `)
        .join('')
    : '';
  const actionsHtml = opts.actionsHtml || '';

  live.innerHTML = `
    <div class="import-preview">${importPreviewMarkup(meta)}</div>
    <div>
      <h4 class="import-title">${dbEscapeHtml(opts.title || meta.name || 'Import Job')}</h4>
      <p class="import-meta">${dbEscapeHtml(opts.meta || '')}</p>
      <div class="import-progress-track">
        <div id="import-progress-bar" class="import-progress-bar"></div>
      </div>
      <p id="import-status-line" class="import-status-line">${dbEscapeHtml(opts.statusLine || '')}</p>
      <p id="import-counters" class="import-counters">${dbEscapeHtml(opts.countersLine || '')}</p>
      <div class="import-steps">${stepHtml}</div>
      <div class="import-metrics">${metricHtml}</div>
      ${actionsHtml}
    </div>
  `;
  importSetProgress(opts.progress ?? 0, Boolean(opts.progressActive));
}

function importStartAnimatedJob(meta) {
  importStopTimers();
  importProgressValue = 5;
  const est = {
    pages: 0,
    words: 0,
    sentences: 0,
    paragraphs: 0,
    tables: 0,
    rows: 0,
    chunks: 0,
  };
  const stepProgress = {
    archive: 6,
    extract: 2,
    tables: 1,
    vector: 1,
  };
  const startMs = Date.now();
  const startedAt = new Date().toLocaleTimeString();
  importRenderLive(meta, {
    title: meta.name || 'Import Job',
    meta: `${meta.sourceLabel || 'Import'}  started ${startedAt}`,
    statusLine: 'Uploading and deduplicating document...',
    countersLine: 'Initializing parser and extraction pipeline...',
    steps: IMPORT_STEPS.map((s, idx) => ({ ...s, state: idx === 0 ? 'active' : 'pending', progress: idx === 0 ? 8 : 0 })),
    progress: importProgressValue,
    progressActive: true,
  });

  importProgressTimer = setInterval(() => {
    stepProgress.archive = Math.min(98, stepProgress.archive + (Math.random() * 5.8 + 2.4));
    stepProgress.extract = Math.min(96, stepProgress.extract + (Math.random() * 4.9 + 1.6));
    stepProgress.tables = Math.min(95, stepProgress.tables + (Math.random() * 3.8 + 1.2));
    if (stepProgress.extract > 18 || stepProgress.tables > 14) {
      stepProgress.vector = Math.min(94, stepProgress.vector + (Math.random() * 3.9 + 1.1));
    } else {
      stepProgress.vector = Math.min(20, stepProgress.vector + (Math.random() * 1.1));
    }

    importProgressValue = Math.min(
      92,
      (stepProgress.archive * 0.18)
      + (stepProgress.extract * 0.34)
      + (stepProgress.tables * 0.22)
      + (stepProgress.vector * 0.26)
    );

    const stageLabel = `Archive ${Math.floor(stepProgress.archive)}%  Text ${Math.floor(stepProgress.extract)}%  Tables ${Math.floor(stepProgress.tables)}%  Vectors ${Math.floor(stepProgress.vector)}%`;
    const stepStates = IMPORT_STEPS.map((s, idx) => ({
      ...s,
      state: (idx === 0 ? stepProgress.archive : (idx === 1 ? stepProgress.extract : (idx === 2 ? stepProgress.tables : stepProgress.vector))) >= 94
        ? 'done'
        : 'active',
      progress: idx === 0
        ? stepProgress.archive
        : (idx === 1 ? stepProgress.extract : (idx === 2 ? stepProgress.tables : stepProgress.vector)),
      detail: idx === 0
        ? 'Hashing, dedupe check, immutable archive write.'
        : (idx === 1
          ? 'Reading pages and parsing canonical text.'
          : (idx === 2
            ? 'Building table structures and annotations.'
            : 'Embedding chunks and updating vector store.')),
      stats: idx === 1
        ? `~${est.pages} pages  ~${est.words} words  ~${est.sentences} sentences  ~${est.paragraphs} paragraphs`
        : (idx === 2
          ? `~${est.tables} tables  ~${est.rows} rows`
          : (idx === 3 ? `~${est.chunks} chunks` : '')),
    }));
    const status = document.getElementById('import-status-line');
    if (status) status.textContent = `Running extraction, Docling structure parsing, and vector indexing by default. ${stageLabel}`;
    const counters = document.getElementById('import-counters');
    if (counters) {
      const elapsed = ((Date.now() - startMs) / 1000).toFixed(1);
      counters.textContent = `Elapsed ${elapsed}s  Pages ~${est.pages}  Words ~${est.words}  Sentences ~${est.sentences}  Paragraphs ~${est.paragraphs}  Tables ~${est.tables}  Rows ~${est.rows}  Vector chunks ~${est.chunks}`;
    }
    const steps = document.querySelector('#import-live .import-steps');
    if (steps) steps.innerHTML = stepStates.map(importStepHtml).join('');
    importSetProgress(importProgressValue, true);
  }, 220);

  importCounterTimer = setInterval(() => {
    est.pages += Math.max(1, Math.floor(Math.random() * 2));
    est.words += Math.max(90, Math.floor(Math.random() * 240));
    est.sentences += Math.max(4, Math.floor(Math.random() * 11));
    est.paragraphs += Math.max(1, Math.floor(Math.random() * 4));
    est.tables += Math.max(0, Math.floor(Math.random() * 2));
    est.rows += Math.max(1, Math.floor(Math.random() * 12));
    est.chunks += Math.max(4, Math.floor(Math.random() * 18));
  }, 700);
}

function importStepsFromPayload(payload, vectorPayload) {
  const extraction = payload?.extraction || {};
  const summary = extraction.summary || {};
  const latestVectorRun = Array.isArray(vectorPayload?.runs) && vectorPayload.runs.length
    ? vectorPayload.runs[0]
    : null;

  const steps = [];
  if (payload && payload.ok) {
    const archiveDetail = payload.status === 'duplicate'
      ? 'Duplicate detected; existing archive reused.'
      : 'Document archived and resource record created.';
    steps.push({
      ...IMPORT_STEPS[0],
      state: 'done',
      progress: 100,
      detail: archiveDetail,
      stats: payload?.resource?.digest_sha256 ? `digest ${String(payload.resource.digest_sha256).slice(0, 10)}...` : '',
    });
  } else {
    steps.push({
      ...IMPORT_STEPS[0],
      state: 'error',
      progress: 100,
      detail: payload?.detail || payload?.error || 'Import failed.',
    });
  }

  if (extraction.status === 'extracted') {
    const pageCount = summary.page_count;
    const textWords = summary.text_words ?? 0;
    const textSentences = summary.text_sentences ?? 0;
    const textParagraphs = summary.text_paragraphs ?? 0;
    const tableRows = summary.table_rows_total ?? 0;
    const tableCols = summary.table_cols_total ?? 0;
    const tableCells = summary.table_cells_total ?? 0;
    steps.push({
      ...IMPORT_STEPS[1],
      state: 'done',
      progress: 100,
      detail: pageCount ? `${pageCount} page(s) scanned.` : 'Text extraction completed.',
      stats: `${textWords} words, ${textSentences} sentences, ${textParagraphs} paragraphs`,
    });
    steps.push({
      ...IMPORT_STEPS[2],
      state: 'done',
      progress: 100,
      detail: `${summary.tables_found ?? 0} tables, ${summary.annotations_persisted ?? 0} annotations.`,
      stats: `${tableRows} rows, ${tableCols} cols, ${tableCells} cells`,
    });
    const vectorState = String(
      summary.vector_status
      || extraction?.vector?.status
      || latestVectorRun?.status
      || 'skipped'
    ).toLowerCase();
    const vectorChunksIndexed = summary.vector_chunks_indexed
      ?? extraction?.vector?.chunks_indexed
      ?? latestVectorRun?.chunks_indexed
      ?? 0;
    const vectorChunksTotal = summary.vector_chunks_total
      ?? extraction?.vector?.chunks_total
      ?? latestVectorRun?.chunks_total
      ?? 0;
    const vectorError = summary.vector_error || extraction?.vector?.error || latestVectorRun?.error_message || null;
    if (vectorState === 'failed') {
      steps.push({
        ...IMPORT_STEPS[3],
        state: 'error',
        progress: 100,
        detail: vectorError || 'Vector indexing failed.',
      });
    } else if (vectorState === 'success' || vectorState === 'running') {
      steps.push({
        ...IMPORT_STEPS[3],
        state: 'done',
        progress: 100,
        detail: `${vectorChunksIndexed}/${vectorChunksTotal} chunks indexed.`,
        stats: `${vectorPayload?.qdrant_points ?? 0} total vector points`,
      });
    } else {
      steps.push({
        ...IMPORT_STEPS[3],
        state: 'skipped',
        progress: 100,
        detail: 'Vector indexing not executed.',
      });
    }
    return steps;
  }

  if (extraction.status === 'failed') {
    steps.push({
      ...IMPORT_STEPS[1],
      state: 'error',
      progress: 100,
      detail: extraction.error || 'Extraction failed.',
    });
    steps.push({
      ...IMPORT_STEPS[2],
      state: 'skipped',
      progress: 100,
      detail: 'Skipped due to extraction failure.',
    });
    steps.push({
      ...IMPORT_STEPS[3],
      state: 'skipped',
      progress: 100,
      detail: 'Skipped due to extraction failure.',
    });
    return steps;
  }

  if (extraction.reason === 'already_extracted') {
    const vectorSummary = extraction.vector || null;
    const vectorStatus = String(vectorSummary?.status || '').toLowerCase();
    const vectorRuns = Array.isArray(vectorPayload?.runs) ? vectorPayload.runs : [];
    steps.push({
      ...IMPORT_STEPS[1],
      state: 'done',
      progress: 100,
      detail: 'Existing extraction reused.',
      stats: `run ${extraction.extraction_run_id || 'latest'}`,
    });
    steps.push({
      ...IMPORT_STEPS[2],
      state: 'done',
      progress: 100,
      detail: 'Structured data already available.',
      stats: `${summary.tables_found ?? 0} tables  ${summary.table_rows_total ?? 0} rows  ${summary.table_cols_total ?? 0} cols  ${summary.table_cells_total ?? 0} cells`,
    });
    const hasVectorRuns = vectorRuns.length > 0;
    const vectorStepState = vectorStatus === 'failed'
      ? 'error'
      : ((vectorStatus === 'success' || vectorStatus === 'skipped' || hasVectorRuns) ? 'done' : 'skipped');
    const vectorDetail = vectorStatus === 'failed'
      ? (vectorSummary?.error || 'Vector indexing failed while reusing extraction.')
      : (vectorStatus === 'success'
        ? `${vectorSummary?.chunks_indexed ?? 0}/${vectorSummary?.chunks_total ?? 0} chunks indexed.`
        : (vectorStatus === 'skipped'
          ? 'Existing vector index reused for current extraction.'
          : (hasVectorRuns ? 'Existing vector runs detected.' : 'No vector runs found for this resource yet.')));
    steps.push({
      ...IMPORT_STEPS[3],
      state: vectorStepState,
      progress: 100,
      detail: vectorDetail,
      stats: (vectorSummary && Number.isFinite(Number(vectorSummary?.chunks_total)))
        ? `${vectorSummary?.chunks_indexed ?? 0}/${vectorSummary?.chunks_total ?? 0} chunks`
        : (hasVectorRuns ? `${vectorRuns.length} run(s)` : ''),
    });
    return steps;
  }

  if (extraction.reason === 'media_type_not_extractable') {
    steps.push({ ...IMPORT_STEPS[1], state: 'skipped', progress: 100, detail: 'Media type is not extractable.' });
    steps.push({ ...IMPORT_STEPS[2], state: 'skipped', progress: 100, detail: 'No extraction means no table parsing.' });
    steps.push({ ...IMPORT_STEPS[3], state: 'skipped', progress: 100, detail: 'No extraction means no vector indexing.' });
    return steps;
  }

  steps.push({ ...IMPORT_STEPS[1], state: 'skipped', progress: 100, detail: 'Extraction not attempted.' });
  steps.push({ ...IMPORT_STEPS[2], state: 'skipped', progress: 100, detail: 'Not available.' });
  steps.push({ ...IMPORT_STEPS[3], state: 'skipped', progress: 100, detail: 'Not available.' });
  return steps;
}

function importFinalMetrics(payload, vectorPayload) {
  const extraction = payload?.extraction || {};
  const summary = extraction.summary || {};
  const latestVectorRun = Array.isArray(vectorPayload?.runs) && vectorPayload.runs.length
    ? vectorPayload.runs[0]
    : null;
  const vectorStatus = summary.vector_status || extraction?.vector?.status || latestVectorRun?.status || 'n/a';
  const vectorChunksIndexed = summary.vector_chunks_indexed
    ?? extraction?.vector?.chunks_indexed
    ?? latestVectorRun?.chunks_indexed
    ?? 0;
  const vectorChunksTotal = summary.vector_chunks_total
    ?? extraction?.vector?.chunks_total
    ?? latestVectorRun?.chunks_total
    ?? 0;
  const metrics = [
    { k: 'Import Status', v: payload?.status || 'unknown' },
    { k: 'Media Type', v: payload?.resource?.media_type || 'n/a' },
    { k: 'Pages', v: summary.page_count ?? 0 },
    { k: 'Words', v: summary.text_words ?? 0 },
    { k: 'Sentences', v: summary.text_sentences ?? 0 },
    { k: 'Paragraphs', v: summary.text_paragraphs ?? 0 },
    { k: 'Tables', v: summary.tables_found ?? 0 },
    { k: 'Table Rows', v: summary.table_rows_total ?? 0 },
    { k: 'Table Cols', v: summary.table_cols_total ?? 0 },
    { k: 'Table Cells', v: summary.table_cells_total ?? 0 },
    { k: 'Segments', v: summary.segments_persisted ?? 0 },
    { k: 'Annotations', v: summary.annotations_persisted ?? 0 },
    { k: 'Vector Status', v: vectorStatus },
    { k: 'Vector Chunks', v: `${vectorChunksIndexed}/${vectorChunksTotal}` },
  ];
  if (vectorPayload && vectorPayload.ok) {
    metrics.push({ k: 'Vector Runs', v: Array.isArray(vectorPayload.runs) ? vectorPayload.runs.length : 0 });
    metrics.push({ k: 'Qdrant Points', v: vectorPayload.qdrant_points ?? 0 });
  }
  return metrics;
}

async function importOpenInDatabase(resourceId) {
  if (!resourceId) return;
  setActivePane('database');
  await dbListTables();
  const select = document.getElementById('db-table-select');
  if (select) select.value = 'resources';
  const limit = document.getElementById('db-limit');
  if (limit) limit.value = '100';
  const offset = document.getElementById('db-offset');
  if (offset) offset.value = '0';
  await dbViewTable();
  const search = document.getElementById('db-search');
  if (search) {
    search.value = resourceId;
    dbGridState.globalSearch = resourceId;
    if (dbOutputMode() === 'spreadsheet') dbRenderGrid();
  }
}

async function importFinalizeJob(payload, meta) {
  importStopTimers();
  importSetProgress(100, false);
  const basePayload = (payload && typeof payload === 'object') ? payload : {};
  const resourceId = basePayload?.resource?.id || null;
  const extractionPayload = (basePayload.extraction && typeof basePayload.extraction === 'object')
    ? basePayload.extraction
    : null;
  const extractionStatus = extractionPayload ? String(extractionPayload.status || '') : '';
  const needsFallbackExtraction = Boolean(
    basePayload?.ok
      && resourceId
      && (
        !extractionPayload
        || !extractionStatus
        || (extractionStatus === 'skipped' && !extractionPayload.reason)
      )
  );

  let finalizedPayload = basePayload;
  if (needsFallbackExtraction) {
    const status = document.getElementById('import-status-line');
    if (status) status.textContent = 'Running extraction pipeline (fallback)...';
    try {
      const extractPayload = await callApi(
        'POST',
        '/api/extract/run',
        { resource_id: resourceId, profile: 'default' },
        null
      );
      const extractionSummary = extractPayload?.summary || null;
      finalizedPayload = {
        ...basePayload,
        extraction: extractionSummary
          ? { attempted: true, status: 'extracted', summary: extractionSummary, source: 'client_fallback' }
          : { attempted: true, status: 'failed', error: extractPayload?.detail || 'Extraction failed.' },
      };
      const runId = extractionSummary?.run_id;
      if (runId) {
        const vectorIndex = await callApi(
          'POST',
          '/api/vector/index',
          { resource_id: resourceId, extraction_run_id: runId, force: false },
          null
        );
        if (vectorIndex && vectorIndex.ok && vectorIndex.summary) {
          const summary = finalizedPayload.extraction?.summary || {};
          finalizedPayload.extraction.summary = {
            ...summary,
            vector_status: vectorIndex.summary.status,
            vector_chunks_total: vectorIndex.summary.chunks_total,
            vector_chunks_indexed: vectorIndex.summary.chunks_indexed,
            vector_error: vectorIndex.summary.error,
          };
        }
      }
    } catch (e) {
      finalizedPayload = {
        ...basePayload,
        extraction: { attempted: true, status: 'failed', error: String(e), source: 'client_fallback' },
      };
    }
  }

  function hasValue(v) {
    return v !== undefined && v !== null;
  }

  function computeTextStats(text) {
    const content = String(text || '');
    const words = (content.match(/\b\w+\b/g) || []).length;
    const sentences = (content.match(/[^.!?\n]+(?:[.!?]+|$)/g) || [])
      .map((s) => s.trim())
      .filter((s) => s.length > 0)
      .length;
    const paragraphs = content
      .split(/\n\s*\n+/)
      .map((p) => p.trim())
      .filter((p) => p.length > 0)
      .length;
    return { words, sentences, paragraphs };
  }

  function jsonArrayLength(value) {
    if (Array.isArray(value)) return value.length;
    if (typeof value !== 'string') return 0;
    try {
      const parsed = JSON.parse(value);
      return Array.isArray(parsed) ? parsed.length : 0;
    } catch {
      return 0;
    }
  }

  async function enrichExtractionSummary(resourceIdValue, extractionValue) {
    if (!resourceIdValue || extractionValue?.status !== 'extracted') return extractionValue;
    const summaryIn = (extractionValue.summary && typeof extractionValue.summary === 'object')
      ? extractionValue.summary
      : {};
    const summary = { ...summaryIn };
    const runId = summary.run_id;

    const missingTextStats = !hasValue(summary.text_words) || !hasValue(summary.text_sentences) || !hasValue(summary.text_paragraphs);
    if (missingTextStats || !hasValue(summary.text_chars)) {
      try {
        let url = `/api/extract/text?resource_id=${encodeURIComponent(resourceIdValue)}`;
        if (runId) url += `&extraction_run_id=${encodeURIComponent(runId)}`;
        const textPayload = await callApi('GET', url, null, null);
        const doc = textPayload?.document_text || null;
        if (doc) {
          const textContent = String(doc.text_content || '');
          const computed = computeTextStats(textContent);
          if (!hasValue(summary.text_chars)) summary.text_chars = hasValue(doc.char_count) ? doc.char_count : textContent.length;
          if (!hasValue(summary.text_words)) summary.text_words = computed.words;
          if (!hasValue(summary.text_sentences)) summary.text_sentences = computed.sentences;
          if (!hasValue(summary.text_paragraphs)) summary.text_paragraphs = computed.paragraphs;
        }
      } catch (e) {
      }
    }

    const missingTableStats = !hasValue(summary.table_rows_total) || !hasValue(summary.table_cols_total) || !hasValue(summary.table_cells_total);
    if (missingTableStats || !hasValue(summary.tables_found)) {
      try {
        const tablesPayload = await callApi(
          'GET',
          `/api/extract/tables?resource_id=${encodeURIComponent(resourceIdValue)}&limit=100000`,
          null,
          null
        );
        const tables = Array.isArray(tablesPayload?.tables) ? tablesPayload.tables : [];
        if (!hasValue(summary.tables_found)) summary.tables_found = tables.length;
        if (missingTableStats) {
          let rows = 0;
          let cols = 0;
          let cells = 0;
          for (const table of tables) {
            rows += jsonArrayLength(table?.row_headers_json ?? table?.row_headers);
            cols += jsonArrayLength(table?.col_headers_json ?? table?.col_headers);
            cells += jsonArrayLength(table?.cells_json ?? table?.cells);
          }
          if (!hasValue(summary.table_rows_total)) summary.table_rows_total = rows;
          if (!hasValue(summary.table_cols_total)) summary.table_cols_total = cols;
          if (!hasValue(summary.table_cells_total)) summary.table_cells_total = cells;
        }
      } catch (e) {
      }
    }

    return { ...extractionValue, summary };
  }

  if (resourceId && finalizedPayload?.extraction) {
    finalizedPayload = {
      ...finalizedPayload,
      extraction: await enrichExtractionSummary(resourceId, finalizedPayload.extraction),
    };
  }

  document.getElementById('out-ingest').textContent = JSON.stringify(finalizedPayload, null, 2);

  let vectorPayload = null;
  if (resourceId) {
    try {
      vectorPayload = await callApi('GET', `/api/vector/status?resource_id=${encodeURIComponent(resourceId)}&limit_runs=10`, null, null);
    } catch (e) {
      vectorPayload = null;
    }
  }

  const steps = importStepsFromPayload(finalizedPayload, vectorPayload);
  const metrics = importFinalMetrics(finalizedPayload, vectorPayload);
  const ok = Boolean(finalizedPayload?.ok);
  const extraction = finalizedPayload?.extraction || {};
  const summary = extraction.summary || {};
  const actions = resourceId
    ? `<div class="row"><button type="button" class="secondary" onclick="importOpenInDatabase('${dbEscapeHtml(resourceId)}')">Open In Database Explorer</button></div>`
    : '';

  const statusLine = ok
    ? `Import complete for ${meta.name || 'document'}.`
    : 'Import failed.';
  const countersParts = [];
  if (summary.page_count !== undefined && summary.page_count !== null) countersParts.push(`Pages ${summary.page_count}`);
  if (summary.text_words !== undefined && summary.text_words !== null) countersParts.push(`Words ${summary.text_words}`);
  if (summary.text_sentences !== undefined && summary.text_sentences !== null) countersParts.push(`Sentences ${summary.text_sentences}`);
  if (summary.text_paragraphs !== undefined && summary.text_paragraphs !== null) countersParts.push(`Paragraphs ${summary.text_paragraphs}`);
  if (summary.tables_found !== undefined && summary.tables_found !== null) countersParts.push(`Tables ${summary.tables_found}`);
  if (summary.table_rows_total !== undefined && summary.table_rows_total !== null) countersParts.push(`Rows ${summary.table_rows_total}`);
  if (summary.table_cols_total !== undefined && summary.table_cols_total !== null) countersParts.push(`Cols ${summary.table_cols_total}`);
  if (summary.table_cells_total !== undefined && summary.table_cells_total !== null) countersParts.push(`Cells ${summary.table_cells_total}`);
  if (summary.vector_chunks_total !== undefined && summary.vector_chunks_total !== null) {
    countersParts.push(`Vector chunks ${summary.vector_chunks_indexed ?? 0}/${summary.vector_chunks_total}`);
  }
  if (!countersParts.length && extraction.reason === 'already_extracted' && extraction?.vector) {
    countersParts.push(`Existing extraction reused`);
    if (extraction.vector.chunks_total !== undefined && extraction.vector.chunks_total !== null) {
      countersParts.push(`Vector chunks ${extraction.vector.chunks_indexed ?? 0}/${extraction.vector.chunks_total}`);
    }
    if (extraction.vector.status) {
      countersParts.push(`Vector status ${extraction.vector.status}`);
    }
  }
  const counters = countersParts.length
    ? countersParts.join('  ')
    : (extraction.reason === 'media_type_not_extractable'
      ? 'No extraction/vectorization for this media type.'
      : 'No extraction summary available.');

  importRenderLive(meta, {
    title: meta.name || 'Import Job',
    meta: `${meta.sourceLabel || 'Import'}  ${finalizedPayload?.resource?.id || 'no resource id'}`,
    statusLine,
    countersLine: counters,
    steps,
    metrics,
    actionsHtml: actions,
    progress: 100,
    progressActive: false,
  });

  const doneTone = ok ? (steps.some((s) => s.state === 'error') ? 'error' : 'ok') : 'error';
  importAddHistory({
    statusTone: doneTone,
    statusLabel: ok ? 'completed' : 'failed',
    name: meta.name || finalizedPayload?.uploaded_filename || finalizedPayload?.resource?.original_filename || 'document',
    summary: resourceId
      ? `resource=${resourceId}  vector=${summary.vector_status || extraction.status || 'n/a'}`
      : (finalizedPayload?.detail || finalizedPayload?.error || 'No resource id'),
  });
}

function importStreamInitStepState() {
  const map = {};
  IMPORT_STEPS.forEach((step) => {
    map[step.id] = { state: 'pending', progress: 0, detail: '', stats: '' };
  });
  return map;
}

function importStreamStepArray(stepMap) {
  return IMPORT_STEPS.map((step) => ({
    ...step,
    ...(stepMap[step.id] || { state: 'pending', progress: 0, detail: '', stats: '' }),
  }));
}

function importStreamOverallProgress(stepMap) {
  const weights = { archive: 0.2, extract: 0.35, tables: 0.2, vector: 0.25 };
  let total = 0;
  let used = 0;
  Object.entries(weights).forEach(([stage, weight]) => {
    const step = stepMap[stage];
    if (!step) return;
    const raw = Number(step.progress);
    const value = Number.isFinite(raw) ? Math.max(0, Math.min(100, raw)) : 0;
    total += value * weight;
    used += weight;
  });
  if (!used) return 0;
  return Math.max(0, Math.min(100, Math.round(total / used)));
}

function importRenderStreamLive(meta, stepMap, statusLine, countersLine='') {
  importRenderLive(meta, {
    title: meta.name || 'Import Job',
    meta: `${meta.sourceLabel || 'Import'}  streaming backend progress`,
    statusLine: statusLine || 'Import running...',
    countersLine: countersLine || '',
    steps: importStreamStepArray(stepMap),
    metrics: [],
    progress: importStreamOverallProgress(stepMap),
    progressActive: true,
  });
}

function importApplyStreamStage(stepMap, stagePayload) {
  const stage = stagePayload?.stage;
  if (!stage || !stepMap[stage]) return;
  stepMap[stage] = {
    ...stepMap[stage],
    state: stagePayload?.state || stepMap[stage].state || 'pending',
    progress: Number.isFinite(Number(stagePayload?.progress))
      ? Number(stagePayload.progress)
      : stepMap[stage].progress,
    detail: stagePayload?.detail || stepMap[stage].detail || '',
    stats: stagePayload?.stats || stepMap[stage].stats || '',
  };
}

function importParseSseFrame(frame) {
  if (!frame || !frame.trim()) return null;
  let event = 'message';
  const dataLines = [];
  frame.split(/\r?\n/).forEach((line) => {
    if (line.startsWith('event:')) {
      event = line.slice(6).trim();
      return;
    }
    if (line.startsWith('data:')) {
      dataLines.push(line.slice(5).trimStart());
    }
  });
  const dataRaw = dataLines.join('\n');
  let data;
  try {
    data = dataRaw ? JSON.parse(dataRaw) : {};
  } catch {
    data = { detail: dataRaw };
  }
  return { event, data };
}

async function importOpenStream(url, opts) {
  const attempts = candidateApiUrls(url);
  let lastPayload = null;
  for (const attemptUrl of attempts) {
    const res = await fetch(attemptUrl, opts);
    if (res.status === 404) {
      const contentType = (res.headers.get('content-type') || '').toLowerCase();
      lastPayload = contentType.includes('application/json') ? await res.json() : { detail: await res.text() };
      continue;
    }
    if (!res.ok) {
      const contentType = (res.headers.get('content-type') || '').toLowerCase();
      const payload = contentType.includes('application/json') ? await res.json() : { detail: await res.text() };
      throw new Error(payload?.detail || `HTTP ${res.status}`);
    }
    return res;
  }
  throw new Error(lastPayload?.detail || `Stream endpoint not found for ${url}`);
}

async function importRunWithStreamVisuals(meta, streamUrl, body, isFormData=false, fallbackRequestFn=null) {
  const stepMap = importStreamInitStepState();
  importStopTimers();
  importRenderStreamLive(meta, stepMap, 'Starting import...');

  const opts = { method: 'POST', headers: { Accept: 'text/event-stream' } };
  if (body !== null && body !== undefined) {
    if (isFormData) {
      opts.body = body;
    } else {
      opts.headers['Content-Type'] = 'application/json';
      opts.body = JSON.stringify(body);
    }
  }

  let finalPayload = null;
  let statusLine = 'Import running...';
  let countersLine = '';

  try {
    const response = await importOpenStream(streamUrl, opts);
    if (!response.body) throw new Error('Streaming response body is unavailable.');
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';
    let done = false;
    while (!done) {
      const read = await reader.read();
      done = Boolean(read.done);
      buffer += decoder.decode(read.value || new Uint8Array(), { stream: !done });

      let split = buffer.indexOf('\n\n');
      while (split >= 0) {
        const frame = buffer.slice(0, split);
        buffer = buffer.slice(split + 2);
        split = buffer.indexOf('\n\n');

        const parsed = importParseSseFrame(frame);
        if (!parsed) continue;
        const { event, data } = parsed;
        if (event === 'stage') {
          importApplyStreamStage(stepMap, data || {});
          const stageLabel = (data?.stage || '').replace(/^\w/, (c) => c.toUpperCase());
          statusLine = data?.detail || (stageLabel ? `${stageLabel} in progress...` : statusLine);
          countersLine = data?.stats || countersLine;
          importRenderStreamLive(meta, stepMap, statusLine, countersLine);
          continue;
        }
        if (event === 'payload') {
          finalPayload = data || null;
          continue;
        }
        if (event === 'error') {
          throw new Error(data?.error || data?.detail || 'Import stream failed.');
        }
      }
    }
  } catch (e) {
    if (fallbackRequestFn) {
      return importRunWithVisuals(meta, fallbackRequestFn);
    }
    throw e;
  }

  if (!finalPayload) {
    if (fallbackRequestFn) {
      return importRunWithVisuals(meta, fallbackRequestFn);
    }
    throw new Error('Import stream finished without a payload.');
  }
  await importFinalizeJob(finalPayload, meta);
}

async function importRunWithVisuals(meta, requestFn) {
  importStartAnimatedJob(meta);
  try {
    const payload = await requestFn();
    await importFinalizeJob(payload, meta);
  } catch (e) {
    importStopTimers();
    const message = String(e);
    importRenderLive(meta, {
      title: meta.name || 'Import Job',
      meta: `${meta.sourceLabel || 'Import'}  failed`,
      statusLine: 'Import failed before completion.',
      countersLine: '',
      steps: [
        { ...IMPORT_STEPS[0], state: 'error', detail: message },
        { ...IMPORT_STEPS[1], state: 'skipped', detail: 'Skipped' },
        { ...IMPORT_STEPS[2], state: 'skipped', detail: 'Skipped' },
        { ...IMPORT_STEPS[3], state: 'skipped', detail: 'Skipped' },
      ],
      metrics: [],
      progress: 100,
      progressActive: false,
    });
    document.getElementById('out-ingest').textContent = JSON.stringify({ error: message }, null, 2);
    importAddHistory({
      statusTone: 'error',
      statusLabel: 'failed',
      name: meta.name || 'document',
      summary: message,
    });
  }
}

async function ingestPath() {
  const path = (document.getElementById('ingest-path').value || '').trim();
  if (!path) {
    document.getElementById('out-ingest').textContent = JSON.stringify({ error: 'Provide an absolute file path.' }, null, 2);
    return;
  }
  await importRunWithStreamVisuals(
    { name: importPathBasename(path), sourceLabel: 'Path Import', path },
    '/api/ingest/path/stream',
    { path },
    false,
    () => callApi('POST', '/api/ingest/path', { path }, null)
  );
}

async function listResources() {
  const limit = encodeURIComponent(document.getElementById('resources-limit').value || '20');
  const payload = await callApi('GET', `/api/resources?limit=${limit}`, null, 'out-ingest');
  if (!payload || payload.ok !== true || !Array.isArray(payload.resources)) return;
  importHistoryItems = payload.resources.slice(0, 12).map((r) => ({
    statusTone: 'neutral',
    statusLabel: 'resource',
    name: r.original_filename || r.id,
    summary: `id=${r.id}  digest=${String(r.digest_sha256 || '').slice(0, 12)}...`,
  }));
  importRenderHistory();
}

async function importBib() {
  await callApi('POST', '/api/refs/import-bib', {
    bib_path: document.getElementById('bib-path').value
  }, 'out-refs');
}

async function linkReference() {
  await callApi('POST', '/api/refs/link-resource', {
    cite_id: document.getElementById('link-cite-id').value,
    resource_digest: document.getElementById('link-digest').value
  }, 'out-refs');
}

async function extractRun() {
  await callApi('POST', '/api/extract/run', {
    resource_id: document.getElementById('extract-resource-id').value || null,
    resource_digest: document.getElementById('extract-digest').value || null,
    profile: 'default'
  }, 'out-extract');
}

async function extractTables() {
  const id = encodeURIComponent(document.getElementById('extract-tables-id').value || '');
  const digest = encodeURIComponent(document.getElementById('extract-tables-digest').value || '');
  const qs = id ? `resource_id=${id}` : `resource_digest=${digest}`;
  await callApi('GET', `/api/extract/tables?${qs}`, null, 'out-extract');
}

function extractionInspectorError(message) {
  document.getElementById('out-extract-inspector').textContent = JSON.stringify({ error: message }, null, 2);
  extractionInspectorSetCardsHtml('<p class="small err">' + dbEscapeHtml(message) + '</p>');
}

let extractionInspectorCopyPayloads = [];

function extractionInspectorSetCardsHtml(html) {
  const container = document.getElementById('extract-inspector-list');
  if (!container) return;
  container.innerHTML = html;
  container.querySelectorAll('[data-copy-idx]').forEach((button) => {
    button.addEventListener('click', async () => {
      const idx = Number(button.getAttribute('data-copy-idx'));
      await extractionInspectorCopyPayloadByIndex(idx);
    });
  });
}

function extractionInspectorSetCopyStatus(message, isError=false) {
  const el = document.getElementById('extract-inspector-copy-status');
  if (!el) return;
  el.textContent = message || '';
  if (isError) {
    el.classList.add('err');
  } else {
    el.classList.remove('err');
  }
}

async function extractionInspectorCopyText(text) {
  if (navigator.clipboard && navigator.clipboard.writeText) {
    await navigator.clipboard.writeText(text);
    return;
  }
  const area = document.createElement('textarea');
  area.value = text;
  area.setAttribute('readonly', 'readonly');
  area.style.position = 'absolute';
  area.style.left = '-9999px';
  document.body.appendChild(area);
  area.select();
  document.execCommand('copy');
  document.body.removeChild(area);
}

async function extractionInspectorCopyPayloadByIndex(index) {
  if (!Number.isInteger(index) || index < 0 || index >= extractionInspectorCopyPayloads.length) {
    extractionInspectorSetCopyStatus('Unable to copy selector JSON: payload missing.', true);
    return;
  }
  const payload = extractionInspectorCopyPayloads[index];
  try {
    await extractionInspectorCopyText(JSON.stringify(payload, null, 2));
    extractionInspectorSetCopyStatus('Copied selector JSON to clipboard.');
  } catch (e) {
    extractionInspectorSetCopyStatus('Failed to copy selector JSON: ' + String(e), true);
  }
}

function extractionInspectorResetCards(message='No inspector items loaded yet.') {
  extractionInspectorCopyPayloads = [];
  extractionInspectorSetCardsHtml('<p class="small">' + dbEscapeHtml(message) + '</p>');
  extractionInspectorSetCopyStatus('');
}

function extractionInspectorSegmentSelector(segment) {
  return {
    type: 'TextPositionSelector',
    start: Number(segment.start_offset),
    end: Number(segment.end_offset),
    segment_type: segment.segment_type || null,
    extraction_run_id: segment.extraction_run_id || null,
  };
}

function extractionInspectorAnnotationSelector(annotation) {
  const spans = Array.isArray(annotation.spans)
    ? annotation.spans.map((s) => ({
        start: Number(s.start),
        end: Number(s.end),
      }))
    : [];
  const selector = {
    type: 'TextAnnotationSelector',
    annotation_id: annotation.id,
    layer: annotation.layer || null,
    category: annotation.category || null,
    label: annotation.label || null,
    spans,
  };
  if (spans.length === 1) {
    selector.start = spans[0].start;
    selector.end = spans[0].end;
  }
  return selector;
}

function extractionInspectorRenderSegments(data) {
  const segments = Array.isArray(data?.segments) ? data.segments : [];
  if (!segments.length) {
    extractionInspectorResetCards('No segments matched the current inspector query.');
    return;
  }
  extractionInspectorCopyPayloads = segments.map((segment) => extractionInspectorSegmentSelector(segment));
  const html = segments
    .map((segment, idx) => {
      const start = Number(segment.start_offset);
      const end = Number(segment.end_offset);
      const length = Number.isFinite(start) && Number.isFinite(end) ? Math.max(0, end - start) : '';
      return `
        <article class="inspector-card">
          <h4>${dbEscapeHtml(segment.segment_type || 'segment')} (#${idx + 1})</h4>
          <p class="inspector-meta">start=${dbEscapeHtml(String(segment.start_offset))}, end=${dbEscapeHtml(String(segment.end_offset))}, len=${dbEscapeHtml(String(length))}, page=${dbEscapeHtml(String(segment.page_index ?? 'n/a'))}</p>
          <div class="inspector-copy-row">
            <button class="secondary" type="button" data-copy-idx="${idx}">Copy Selector JSON</button>
          </div>
        </article>
      `;
    })
    .join('');
  extractionInspectorSetCardsHtml(html);
  extractionInspectorSetCopyStatus('Ready: click "Copy Selector JSON" on any segment.');
}

function extractionInspectorRenderAnnotations(data) {
  const annotations = Array.isArray(data?.annotations) ? data.annotations : [];
  if (!annotations.length) {
    extractionInspectorResetCards('No annotations matched the current inspector query.');
    return;
  }
  extractionInspectorCopyPayloads = annotations.map((annotation) =>
    extractionInspectorAnnotationSelector(annotation)
  );
  const html = annotations
    .map((annotation, idx) => {
      const spans = Array.isArray(annotation.spans) ? annotation.spans.length : 0;
      return `
        <article class="inspector-card">
          <h4>${dbEscapeHtml(annotation.layer || 'annotation')} / ${dbEscapeHtml(annotation.category || 'uncategorized')} (#${idx + 1})</h4>
          <p class="inspector-meta">label=${dbEscapeHtml(String(annotation.label || ''))}, spans=${dbEscapeHtml(String(spans))}, source=${dbEscapeHtml(String(annotation.source || 'n/a'))}</p>
          <div class="inspector-copy-row">
            <button class="secondary" type="button" data-copy-idx="${idx}">Copy Selector JSON</button>
          </div>
        </article>
      `;
    })
    .join('');
  extractionInspectorSetCardsHtml(html);
  extractionInspectorSetCopyStatus('Ready: click "Copy Selector JSON" on any annotation.');
}

function extractionInspectorTargetQuery() {
  const id = (document.getElementById('inspect-resource-id').value || '').trim();
  const digest = (document.getElementById('inspect-resource-digest').value || '').trim();
  const runId = (document.getElementById('inspect-run-id').value || '').trim();

  if (!id && !digest) {
    extractionInspectorError('Provide inspector resource ID or digest.');
    return null;
  }

  let qs = id
    ? `resource_id=${encodeURIComponent(id)}`
    : `resource_digest=${encodeURIComponent(digest)}`;
  if (runId) qs += `&extraction_run_id=${encodeURIComponent(runId)}`;
  return qs;
}

function extractionInspectorLimit(defaultValue='200') {
  const raw = (document.getElementById('inspect-limit').value || defaultValue).trim();
  const parsed = Number(raw);
  if (!Number.isFinite(parsed) || parsed <= 0) return defaultValue;
  return String(Math.floor(parsed));
}

async function extractInspectorText() {
  const qs = extractionInspectorTargetQuery();
  if (!qs) return;
  const data = await callApi('GET', `/api/extract/text?${qs}`, null, 'out-extract-inspector');
  if (!data || data.ok !== true || !data.document_text) {
    extractionInspectorResetCards('No extracted text found for this resource/run.');
    return;
  }
  const meta = data.document_text;
  extractionInspectorResetCards(
    `Loaded text: ${meta.char_count || 0} chars (digest ${meta.text_digest_sha256 || 'n/a'}).`
  );
}

async function extractInspectorSegments() {
  const qs = extractionInspectorTargetQuery();
  if (!qs) return;
  const segmentType = (document.getElementById('inspect-segment-type').value || '').trim();
  const limit = extractionInspectorLimit('200');
  let url = `/api/extract/segments?${qs}&limit=${encodeURIComponent(limit)}`;
  if (segmentType) url += `&segment_type=${encodeURIComponent(segmentType)}`;
  const data = await callApi('GET', url, null, 'out-extract-inspector');
  if (!data || data.ok !== true) {
    extractionInspectorError(data?.detail || 'Failed to load segments.');
    return;
  }
  extractionInspectorRenderSegments(data);
}

async function extractInspectorAnnotations() {
  const qs = extractionInspectorTargetQuery();
  if (!qs) return;
  const layer = (document.getElementById('inspect-layer').value || '').trim();
  const category = (document.getElementById('inspect-category').value || '').trim();
  const limit = extractionInspectorLimit('200');
  let url = `/api/extract/annotations?${qs}&limit=${encodeURIComponent(limit)}`;
  if (layer) url += `&layer=${encodeURIComponent(layer)}`;
  if (category) url += `&category=${encodeURIComponent(category)}`;
  const data = await callApi('GET', url, null, 'out-extract-inspector');
  if (!data || data.ok !== true) {
    extractionInspectorError(data?.detail || 'Failed to load annotations.');
    return;
  }
  extractionInspectorRenderAnnotations(data);
}

function extractionInspectorDumpLimit(id, fallback) {
  const raw = (document.getElementById(id).value || String(fallback)).trim();
  const parsed = Number(raw);
  if (!Number.isFinite(parsed) || parsed <= 0) return String(fallback);
  return String(Math.floor(parsed));
}

async function extractInspectorDump() {
  const qs = extractionInspectorTargetQuery();
  if (!qs) return;
  const segmentLimit = extractionInspectorDumpLimit('inspect-segment-limit', 2000);
  const annotationLimit = extractionInspectorDumpLimit('inspect-annotation-limit', 2000);
  const tableLimit = extractionInspectorDumpLimit('inspect-table-limit', 500);
  const url = `/api/extract/dump?${qs}&segment_limit=${encodeURIComponent(segmentLimit)}&annotation_limit=${encodeURIComponent(annotationLimit)}&table_limit=${encodeURIComponent(tableLimit)}`;
  const data = await callApi('GET', url, null, 'out-extract-inspector');
  if (!data || data.ok !== true || !data.dump) {
    extractionInspectorError(data?.detail || 'Failed to load extraction dump.');
    return;
  }
  const dump = data.dump;
  extractionInspectorResetCards(
    `Dump loaded: tables=${(dump.tables || []).length}, segments=${(dump.segments || []).length}, annotations=${(dump.annotations || []).length}.`
  );
}

async function importClaims() {
  await callApi('POST', '/api/claims/import', {
    file_path: document.getElementById('claims-file').value,
    fmt: document.getElementById('claims-format').value,
    claim_set: document.getElementById('claim-set').value
  }, 'out-claims');
}

async function listClaims() {
  const set = encodeURIComponent(document.getElementById('claims-list-set').value || '');
  const url = set ? `/api/claims?claim_set=${set}` : '/api/claims';
  await callApi('GET', url, null, 'out-claims');
}

async function bindAdd() {
  let selectors;
  try {
    selectors = JSON.parse(document.getElementById('bind-selectors').value);
  } catch (e) {
    document.getElementById('out-bind').textContent = JSON.stringify({error: 'Invalid selectors JSON'}, null, 2);
    return;
  }
  await callApi('POST', '/api/bind/add', {
    claim_id: document.getElementById('bind-claim-id').value,
    resource_id: document.getElementById('bind-resource-id').value || null,
    resource_digest: document.getElementById('bind-digest').value || null,
    role: document.getElementById('bind-role').value,
    selectors
  }, 'out-bind');
}

async function bindValidate() {
  await callApi('POST', '/api/bind/validate', {
    claim_id: document.getElementById('bind-claim-id').value
  }, 'out-bind');
}

async function verifyClaim() {
  await callApi('POST', '/api/verify/claim', {
    claim_id: document.getElementById('verify-claim-id').value,
    policy: 'strict'
  }, 'out-verify');
}

async function verifySet() {
  await callApi('POST', '/api/verify/set', {
    claim_set: document.getElementById('verify-claim-set').value,
    policy: 'strict'
  }, 'out-verify');
}

async function reportVerification() {
  const run = encodeURIComponent(document.getElementById('report-run-id').value);
  const jsonOut = encodeURIComponent(document.getElementById('report-json-out').value || '');
  const mdOut = encodeURIComponent(document.getElementById('report-md-out').value || '');
  let qs = `run_id=${run}`;
  if (jsonOut) qs += `&json_out=${jsonOut}`;
  if (mdOut) qs += `&md_out=${mdOut}`;
  await callApi('GET', `/api/report/verification?${qs}`, null, 'out-verify');
}

async function traceClaim() {
  const claim = encodeURIComponent(document.getElementById('trace-claim-id').value);
  await callApi('GET', `/api/trace/claim?claim_id=${claim}`, null, 'out-trace');
}

async function traceResource() {
  const rid = document.getElementById('trace-resource-id').value;
  const digest = document.getElementById('trace-resource-digest').value;
  const qs = rid ? `resource_id=${encodeURIComponent(rid)}` : `resource_digest=${encodeURIComponent(digest)}`;
  await callApi('GET', `/api/trace/resource?${qs}`, null, 'out-trace');
}

async function traceCitation() {
  const cite = encodeURIComponent(document.getElementById('trace-cite-id').value);
  await callApi('GET', `/api/trace/citation?cite_id=${cite}`, null, 'out-trace');
}

async function addProposition() {
  let proposition;
  try {
    proposition = JSON.parse(document.getElementById('ceapf-prop').value);
  } catch (e) {
    document.getElementById('out-ceapf').textContent = JSON.stringify({error: 'Invalid proposition JSON'}, null, 2);
    return;
  }
  const data = await callApi('POST', '/api/ceapf/proposition', { proposition }, 'out-ceapf');
  if (data.proposition_id) document.getElementById('ceapf-prop-id').value = data.proposition_id;
}

async function addAssertion() {
  const data = await callApi('POST', '/api/ceapf/assertion', {
    proposition_id: document.getElementById('ceapf-prop-id').value,
    asserting_agent: document.getElementById('ceapf-agent').value,
    modality: document.getElementById('ceapf-modality').value,
    evidence_id: null
  }, 'out-ceapf');
  if (data.assertion_id) document.getElementById('ceapf-from-id').value = data.assertion_id;
}

async function addRelation() {
  await callApi('POST', '/api/ceapf/relation', {
    relation_type: document.getElementById('ceapf-rel-type').value,
    from_node_type: document.getElementById('ceapf-from-type').value,
    from_node_id: document.getElementById('ceapf-from-id').value,
    to_node_type: document.getElementById('ceapf-to-type').value,
    to_node_id: document.getElementById('ceapf-to-id').value || document.getElementById('ceapf-prop-id').value
  }, 'out-ceapf');
}

async function listPropositions() {
  await callApi('GET', '/api/ceapf/propositions', null, 'out-ceapf');
}

async function runMassImport() {
  const maxRaw = document.getElementById('pipe-max').value.trim();
  const root = (document.getElementById('pipe-root').value || '').trim();
  if (!root) {
    document.getElementById('out-ingest').textContent = JSON.stringify({ error: 'Provide a root path for mass import.' }, null, 2);
    return;
  }
  importStartAnimatedJob({
    name: importPathBasename(root),
    sourceLabel: 'Mass Import',
  });
  let payload;
  try {
    payload = await callApi('POST', '/api/import/mass', {
      root,
      max_files: maxRaw ? Number(maxRaw) : null,
      skip_extraction: document.getElementById('pipe-skip').value === 'true',
      extract_timeout_seconds: Number(document.getElementById('pipe-timeout').value || '300')
    }, 'out-ingest');
  } catch (e) {
    importStopTimers();
    const message = String(e);
    importRenderLive(
      { name: importPathBasename(root), sourceLabel: 'Mass Import' },
      {
        title: `Mass Import: ${importPathBasename(root)}`,
        meta: 'Recursive import run failed.',
        statusLine: 'Mass import failed before completion.',
        countersLine: '',
        steps: [
          { ...IMPORT_STEPS[0], state: 'error', detail: message },
          { ...IMPORT_STEPS[1], state: 'skipped', detail: 'Skipped' },
          { ...IMPORT_STEPS[2], state: 'skipped', detail: 'Skipped' },
          { ...IMPORT_STEPS[3], state: 'skipped', detail: 'Skipped' },
        ],
        metrics: [],
        progress: 100,
        progressActive: false,
      }
    );
    importAddHistory({
      statusTone: 'error',
      statusLabel: 'failed',
      name: importPathBasename(root),
      summary: message,
    });
    return;
  }
  importStopTimers();

  const stats = payload?.stats || {};
  importRenderLive(
    { name: importPathBasename(root), sourceLabel: 'Mass Import' },
    {
      title: `Mass Import: ${importPathBasename(root)}`,
      meta: 'Recursive import run complete.',
      statusLine: payload?.ok ? 'Mass import completed.' : 'Mass import failed.',
      countersLine: `Processed ${stats.processed ?? 0} file(s), extracted ${stats.extracted ?? 0}, failures ${stats.failed ?? 0}.`,
      steps: [
        { ...IMPORT_STEPS[0], state: 'done', detail: `${stats.ingested ?? 0} ingested, ${stats.duplicates ?? 0} duplicates.` },
        { ...IMPORT_STEPS[1], state: (stats.extracted ?? 0) > 0 ? 'done' : 'skipped', detail: `${stats.extracted ?? 0} extracted.` },
        { ...IMPORT_STEPS[2], state: 'done', detail: 'Batch summaries written to log/state files.' },
        { ...IMPORT_STEPS[3], state: 'done', detail: 'Vector indexing occurs for extracted resources.' },
      ],
      metrics: [
        { k: 'Candidates', v: stats.candidates ?? 0 },
        { k: 'Processed', v: stats.processed ?? 0 },
        { k: 'Extracted', v: stats.extracted ?? 0 },
        { k: 'Failed', v: stats.failed ?? 0 },
      ],
      progress: 100,
      progressActive: false,
    }
  );
  importAddHistory({
    statusTone: payload?.ok ? ((stats.failed ?? 0) > 0 ? 'warn' : 'ok') : 'error',
    statusLabel: payload?.ok ? 'mass run' : 'failed',
    name: importPathBasename(root),
    summary: `processed=${stats.processed ?? 0} extracted=${stats.extracted ?? 0} failed=${stats.failed ?? 0}`,
  });
}

const dz = document.getElementById('dropzone');
function prevent(e) { e.preventDefault(); e.stopPropagation(); }
['dragenter','dragover','dragleave','drop'].forEach(evt => dz.addEventListener(evt, prevent));
['dragenter','dragover'].forEach(evt => dz.addEventListener(evt, () => dz.classList.add('drag')));
['dragleave','drop'].forEach(evt => dz.addEventListener(evt, () => dz.classList.remove('drag')));
dz.addEventListener('drop', async (e) => {
  const files = e.dataTransfer.files;
  if (!files || !files.length) return;
  const file = files[0];
  const streamFd = new FormData();
  streamFd.append('file', file);
  await importRunWithStreamVisuals(
    {
      name: file.name || 'Dropped File',
      sourceLabel: 'Drag-and-drop Import',
      file,
      sizeBytes: file.size,
    },
    '/api/ingest/upload/stream',
    streamFd,
    true,
    async () => {
      const fd = new FormData();
      fd.append('file', file);
      return callApi('POST', '/api/ingest/upload', fd, null, true);
    }
  );
});

document.getElementById('help-modal').addEventListener('click', (e) => {
  if (e.target.id === 'help-modal') closeHelp();
});
initTheme();
initWorkspaceNav();
installHelpButtons();
initDbExplorer();
initResizableOutputs();
dbListTables();
loadDashboard();
vectorStatus();
</script>
</body>
</html>
